<!doctype html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>ETABS 梁自動編號工具 v2.1</title>

    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />

    <style>
      /* --- 全局 box-sizing --- */
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      /* --- 淺色主題 --- */
      :root {
        --theme-bg: #f1f5f9;
        --theme-surface: #ffffff;
        --theme-border: #e2e8f0;
        --theme-shadow: rgba(0, 0, 0, 0.05);
        --theme-text-primary: #1e293b;
        --theme-text-secondary: #64748b;
        --theme-accent: #f97316;
        --theme-accent-hover: #ea580c;
        --theme-success: #22c55e;
        --theme-success-hover: #16a34a;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      body {
        font-family: "Inter", "Microsoft JhengHei", sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        padding: 26px 14px;
        color: var(--theme-text-primary);
        background-color: var(--theme-bg);
        position: relative;
      }

      #container {
        width: 90%;
        max-width: none;
        background: var(--theme-surface);
        padding: 20px;
        border-radius: 18px;
        border: 1px solid var(--theme-border);
        box-shadow:
          0 10px 25px -5px var(--theme-shadow),
          0 8px 10px -6px var(--theme-shadow);
        animation: fadeIn 0.8s ease-out forwards;
        position: relative;
        z-index: 1;
      }

      h1 {
        font-size: 2.25rem;
        font-weight: 700;
        color: var(--theme-text-primary);
        text-align: center;
        margin-bottom: 2.5rem;
        position: relative;
      }

      h1::after {
        content: "";
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 80px;
        height: 3px;
        background: var(--theme-accent);
        border-radius: 2px;
      }

      h3 {
        color: var(--theme-text-primary);
        font-weight: 500;
        border-bottom: 1px solid var(--theme-border);
        padding-bottom: 0.5rem;
        margin-bottom: 1rem;
        opacity: 0.9;
      }

      .control-area {
        margin-bottom: 25px;
        padding: 20px;
        border-radius: 12px;
        background: var(--theme-bg);
        border: 1px solid var(--theme-border);
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .control-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }

      .control-group {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      label {
        font-weight: 500;
        color: var(--theme-text-secondary);
      }

      input[type="file"]::file-selector-button {
        background-color: #ffffff;
        color: var(--theme-text-secondary);
        border: 1px solid var(--theme-border);
        padding: 8px 15px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      input[type="file"]::file-selector-button:hover {
        background-color: var(--theme-bg);
        border-color: var(--theme-accent);
        color: var(--theme-accent);
      }

      select {
        background-color: #ffffff;
        color: var(--theme-text-primary);
        border: 1px solid var(--theme-border);
        padding: 8px 15px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      select:hover {
        border-color: var(--theme-accent);
      }

      select option {
        background-color: #ffffff;
        color: #000000;
      }

      /* 隱藏數字輸入框的上下箭頭 */
      input[type="number"]::-webkit-inner-spin-button,
      input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      input[type="number"] {
        -moz-appearance: textfield;
        appearance: textfield;
      }

      /* File Input Styles */
      .file-input-group {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 20px;
      }

      .file-label {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 12px 24px;
        background-color: var(--theme-accent);
        color: white;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      .file-label:hover {
        background-color: var(--theme-accent-hover);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(251, 146, 60, 0.3);
      }

      .file-label svg {
        width: 20px;
        height: 20px;
      }

      .file-name-display {
        color: var(--theme-text-secondary);
        font-size: 14px;
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
      }

      .checkbox-group input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }

      .checkbox-group label {
        cursor: pointer;
        user-select: none;
      }

      /* Toggle Switch Styles */
      .switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 26px;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .switch .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.3s;
        border-radius: 26px;
      }
      .switch .slider:before {
        position: absolute;
        content: "";
        height: 20px;
        width: 20px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
      }
      .switch input:checked + .slider {
        background-color: #f97316;
      }
      .switch input:checked + .slider:before {
        transform: translateX(24px);
      }

      /* Button Row Styles */
      .button-row {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
        margin-bottom: 20px;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 14px 20px;
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      .btn svg {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
      }

      .btn:hover {
        transform: translateY(-2px);
      }

      .btn:disabled {
        background-color: #9ca3af;
        cursor: not-allowed;
        transform: none;
      }

      .btn-primary {
        background-color: #3b82f6;
      }

      .btn-primary:hover:not(:disabled) {
        background-color: #2563eb;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      }

      .btn-secondary {
        background-color: #8b5cf6;
      }

      .btn-secondary:hover:not(:disabled) {
        background-color: #7c3aed;
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
      }

      .btn-success {
        background-color: var(--theme-success);
      }

      .btn-success:hover:not(:disabled) {
        background-color: var(--theme-success-hover);
        box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
      }

      .btn-autocad {
        background-color: #dc2626;
      }

      .btn-autocad:hover:not(:disabled) {
        background-color: #b91c1c;
        box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
      }

      /* Filter Row Styles */
      .filter-row {
        display: flex;
        gap: 16px;
        align-items: center;
        margin-bottom: 20px;
      }

      .filter-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .filter-group label {
        font-weight: 500;
        color: var(--theme-text-primary);
        white-space: nowrap;
      }

      .filter-group select {
        min-width: 120px;
      }

      /* Old button styles - keeping for backward compatibility */
      button {
        padding: 12px 24px;
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.2s ease;
      }

      .btn-process {
        background-color: var(--theme-accent);
      }

      .btn-process:hover {
        background-color: var(--theme-accent-hover);
      }

      .btn-export {
        background-color: var(--theme-success);
      }

      .btn-export:hover {
        background-color: var(--theme-success-hover);
      }

      .btn-export:disabled {
        background-color: #9ca3af;
        cursor: not-allowed;
      }

      #output {
        margin-top: 20px;
      }

      #drawing {
        width: 100%;
        padding: 20px;
        max-height: 65vh;
        overflow: auto;
        border-radius: 12px;
        background: #ffffff;
        border: 1px solid var(--theme-border);
      }

      #drawing-svg {
        width: 100%;
        height: 60vh;
        border-radius: 8px;
        background-color: #ffffff;
        border: 1px solid var(--theme-border);
        cursor: grab;
        /* [優化] 減少切換時的閃爍 */
        will-change: transform;
        contain: layout style paint;
      }

      /* [優化] SVG 內容過渡效果 */
      #drawing-svg > * {
        transition: opacity 0.1s ease-out;
      }

      /* 全螢幕模式樣式 */
      #drawing.fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        max-width: 100vw !important;
        max-height: 100vh !important;
        padding: 0 !important;
        margin: 0 !important;
        z-index: 9999 !important;
        border-radius: 0 !important;
        border: none !important;
        background: #ffffff !important;
        overflow: hidden !important;
        box-sizing: border-box !important;
      }

      #drawing.fullscreen #drawing-svg {
        width: 100vw !important;
        height: 100vh !important;
        max-width: 100vw !important;
        max-height: 100vh !important;
        min-width: 100vw !important;
        min-height: 100vh !important;
        border-radius: 0 !important;
        border: none !important;
        display: block !important;
        position: fixed !important;
        top: -150px !important;
        left: -80px !important;
        right: 0 !important;
        bottom: 0 !important;
        box-sizing: border-box !important;
        background: #ffffff !important;
        margin: 0 !important;
        padding: 0 !important;
        z-index: 10000 !important;
      }

      /* 全螢幕模式下隱藏所有控制元素（只保留 SVG） */
      #drawing.fullscreen > div {
        display: none !important;
        visibility: hidden !important;
        width: 0 !important;
        height: 0 !important;
        overflow: hidden !important;
        position: absolute !important;
        pointer-events: none !important;
      }

      /* 全螢幕模式時，隱藏其他所有容器內容（但保留對話框和樓層 Bubble） */
      body:has(#drawing.fullscreen) > *:not(#drawing):not(script):not(style):not(link):not(#batch-edit-dialog):not(#batch-edit-overlay):not(#search-member-dialog):not(#search-member-overlay):not(#fixed-label-dialog):not(#fixed-label-overlay):not(#beam-edit-dialog):not(#fullscreen-floor-bubble) {
        visibility: hidden !important;
      }

      body:has(#drawing.fullscreen) #container {
        visibility: hidden !important;
      }

      body:has(#drawing.fullscreen) #drawing.fullscreen {
        visibility: visible !important;
      }

      /* 全螢幕模式時，確保 html 和 body 的背景也是白色 */
      body:has(#drawing.fullscreen) {
        background: #ffffff !important;
        padding: 0 !important;
        margin: 0 !important;
        overflow: hidden !important;
      }

      html:has(#drawing.fullscreen) {
        background: #ffffff !important;
        padding: 0 !important;
        margin: 0 !important;
        overflow: hidden !important;
        width: 100vw !important;
        height: 100vh !important;
      }

      html:has(#drawing.fullscreen) body {
        width: 100vw !important;
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
      }

      /* 確保全螢幕時移除所有可能的滾動條空間 */
      html:has(#drawing.fullscreen),
      html:has(#drawing.fullscreen) body {
        scrollbar-width: none !important;
        -ms-overflow-style: none !important;
      }

      html:has(#drawing.fullscreen)::-webkit-scrollbar,
      html:has(#drawing.fullscreen) body::-webkit-scrollbar {
        display: none !important;
        width: 0 !important;
        height: 0 !important;
      }

      /* 全螢幕模式下確保對話框可見 */
      body:has(#drawing.fullscreen) #batch-edit-overlay,
      body:has(#drawing.fullscreen) #search-member-overlay,
      body:has(#drawing.fullscreen) #fixed-label-overlay {
        z-index: 10003 !important;
        visibility: visible !important;
      }

      body:has(#drawing.fullscreen) #beam-edit-dialog,
      body:has(#drawing.fullscreen) #batch-edit-dialog,
      body:has(#drawing.fullscreen) #search-member-dialog,
      body:has(#drawing.fullscreen) #fixed-label-dialog {
        z-index: 10004 !important;
        visibility: visible !important;
      }

      /* 全螢幕控制器（完全隱藏） */
      #fullscreen-controls {
        display: none !important;
      }

      /* [新增] 全螢幕模式樓層顯示 Bubble（類似 Grid Bubble 樣式） */
      #fullscreen-floor-bubble {
        display: none;
        position: fixed;
        top: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        background: white;
        border: 3px solid #22c55e; /* 綠色邊框，類似 Grid Bubble */
        border-radius: 50%;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        pointer-events: none;
        user-select: none;
      }

      #fullscreen-floor-bubble.visible {
        display: flex !important;
        visibility: visible !important;
        align-items: center;
        justify-content: center;
      }

      #fullscreen-floor-text {
        font-size: 14px;
        font-weight: 600;
        color: #000000;
        text-align: center;
      }

      #drawing-svg:active {
        cursor: grabbing;
      }

      .error {
        color: #ef4444;
        font-weight: bold;
      }

      /* --- SVG 樣式 --- */
      .grid-lines line {
        stroke: #475569;
        stroke-width: 0.5px;
        stroke-dasharray: 12 6; /* [修改] 更長的虛線線段，更稀疏 */
        vector-effect: non-scaling-stroke;
      }

      /* [新增] Grid Bubble 連接線樣式 */
      .grid-bubble-connector {
        stroke-width: 1px;
        stroke-dasharray: 8 4; /* 虛線 */
        vector-effect: non-scaling-stroke;
        opacity: 0.6;
      }

      .grid-bubble {
        fill: white; /* [修改] 中間留白 */
        /* stroke color is controlled by JS for coordsystem colors */
        stroke-width: 3px; /* [修改] 加粗 */
        vector-effect: non-scaling-stroke; /* [新增] 防止縮放時描邊變粗 */
      }

      .grid-bubble-text {
        fill: #000000; /* [修改] 字體保持黑色 */
        font-weight: 600; /* [修改] 加粗字體 */
        text-anchor: middle;
        dominant-baseline: middle;
        font-size: 14px; /* [修改] 設定基礎字體大小，會隨 SVG 縮放自然放大縮小 */
        /* [修改] 讓點擊穿透到 hitarea，統一由 hitarea 處理所有點擊 */
        pointer-events: none;
        user-select: none;
      }

      .beam-line {
        stroke: #d1d5db;
        stroke-width: 1px;
        vector-effect: non-scaling-stroke; /* 讓所有梁寬度固定 */
      }

      .labeled-beam-line {
        stroke: #3b82f6; /* 大梁：藍色 */
        stroke-width: 1.5px;
        vector-effect: non-scaling-stroke;
      }

      .secondary-beam-line {
        stroke: #f97316; /* 小梁：橘色 */
        stroke-width: 1px;
        vector-effect: non-scaling-stroke;
      }

      .special-beam-line {
        stroke: var(--theme-accent);
        stroke-width: 1.5px;
        vector-effect: non-scaling-stroke;
      }

      .wall-beam-line {
        stroke: #000000; /* WB/FWB 梁：黑色 */
        stroke-width: 1.5px;
        vector-effect: non-scaling-stroke;
      }

      .beam-label {
        fill: #1e293b;
        font-weight: 500;
        cursor: move;  /* [新增] 顯示可移動游標 */
        pointer-events: all;  /* [新增] 確保可以接收點擊事件 */
        /* font-size 由 JavaScript 動態設定，不在 CSS 中固定 */
      }

      /* 圈选功能相关样式 */
      .selection-rect {
        fill: rgba(59, 130, 246, 0.15);
        stroke: #3b82f6;
        stroke-width: 2;
        stroke-dasharray: 5, 5;
        pointer-events: none;
        shape-rendering: crispEdges;
        vector-effect: non-scaling-stroke; /* [新增] 防止縮放時線條變粗 */
      }

      .selection-rect-crossing {
        fill: rgba(34, 197, 94, 0.15);
        stroke: #22c55e;
        stroke-width: 2;
        stroke-dasharray: 5, 5;
        pointer-events: none;
        shape-rendering: crispEdges;
        vector-effect: non-scaling-stroke; /* [新增] 防止縮放時線條變粗 */
      }

      /* AutoCAD 風格十字線游標 */
      .autocad-crosshair {
        cursor: crosshair !important;
      }

      /* 對稱軸線樣式 */
      .symmetry-axis-line {
        stroke: #5D4037;           /* 深咖啡色 */
        stroke-opacity: 0.64;      /* 透明度 (比 Grid Line 低 20%) */
        stroke-width: 1.15;        /* 粗細 (比 Grid Line 粗 15%) */
        stroke-dasharray: 8, 4;    /* 虛線樣式 */
        pointer-events: none;
        vector-effect: non-scaling-stroke;
      }

      .symmetry-axis-line.hidden {
        display: none;
      }

      .beam-selected {
        stroke: #ef4444 !important;
        stroke-width: 2 !important;
      }

      /* 標籤選取使用相同的 class */
      text.beam-selected {
        fill: #ef4444 !important;
        font-weight: 500 !important; /* 保持與 .beam-label 相同的字體粗細 */
      }

      /* 批量编辑对话框样式 */
      .batch-edit-dialog {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 24px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        z-index: 20000;
        min-width: 400px;
      }

      .batch-edit-dialog h3 {
        margin-top: 0;
        margin-bottom: 20px;
      }

      .batch-edit-dialog .dialog-content {
        margin-bottom: 20px;
      }

      .batch-edit-dialog .input-group {
        margin-bottom: 15px;
      }

      .batch-edit-dialog label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
      }

      .batch-edit-dialog input {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--theme-border);
        border-radius: 8px;
        font-size: 14px;
      }

      .batch-edit-dialog .button-group {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }

      .dialog-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 10001;
      }

      /* [新增] Grid System Toggle Switches */
      .grid-system-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 15px;
        background: var(--theme-surface);
        border: 2px solid var(--theme-border);
        border-radius: 8px;
        transition: all 0.2s ease;
      }

      .grid-system-toggle:hover {
        border-color: var(--theme-accent);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .grid-system-toggle label {
        font-weight: 500;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .grid-system-color-indicator {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 2px solid #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      /* Toggle Switch Styling */
      .toggle-switch {
        position: relative;
        width: 50px;
        height: 26px;
        background-color: #ccc;
        border-radius: 13px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .toggle-switch input {
        display: none;
      }

      .toggle-switch-slider {
        position: absolute;
        top: 3px;
        left: 3px;
        width: 20px;
        height: 20px;
        background-color: white;
        border-radius: 50%;
        transition: transform 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .toggle-switch input:checked + .toggle-switch-slider {
        transform: translateX(24px);
      }

      .toggle-switch.active {
        background-color: var(--theme-accent);
      }

      /* [新增] Draggable Grid Bubble Styles */
      .grid-bubble.draggable {
        cursor: move;
        transition: r 0.2s ease, stroke-width 0.2s ease;
        user-select: none;
        pointer-events: all;  /* [修改] 保留 pointer-events 讓 bubble 本身可以顯示 hover 效果 */
        stroke-width: 3px;
      }

      .grid-bubble.draggable:hover {
        r: 22;
        stroke-width: 2.5;
      }

      /* [新增] 為 bubble 添加不可見的點擊區域 - 僅用於擴大點擊範圍 */
      .grid-bubble-hitarea {
        fill: rgba(255,255,255,0.01);  /* [修改] 使用近乎透明的填充來接收點擊 */
        stroke: transparent;
        stroke-width: 0;
        pointer-events: all;
        cursor: move;  /* [修改] 游標顯示為 move 表示可拖動 */
      }

      .grid-bubble.dragging {
        cursor: grabbing;
        opacity: 0.8;
        user-select: none;
      }

      .grid-bubble-connector.rubber-band {
        stroke-dasharray: 5, 5;
        animation: dash 0.5s linear infinite;
      }

      @keyframes dash {
        to {
          stroke-dashoffset: -10;
        }
      }

      /* [新增] 拖動時防止選取文字 */
      body.dragging-bubble {
        user-select: none !important;
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
      }

      body.dragging-bubble * {
        user-select: none !important;
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
      }

      /* [新增] Hidden state for grid elements */
      .grid-bubble.hidden,
      .grid-bubble-text.hidden,
      .grid-bubble-connector.hidden,
      .grid-line-element.hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <h1>ETABS 梁自動編號工具</h1>

      <div class="control-area">
        <!-- 第一排：檔案選擇與選項 -->
        <div class="control-row">
          <div class="file-input-group">
            <label for="e2kFile" class="file-label">
              <svg
                width="20"
                height="20"
                viewBox="0 0 20 20"
                fill="none"
                style="margin-right: 8px"
              >
                <path
                  d="M13 2H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7l-3-5z"
                  stroke="currentColor"
                  stroke-width="2"
                />
              </svg>
              請選擇 ETABS .e2k 檔案
            </label>
            <input
              type="file"
              id="e2kFile"
              accept=".e2k"
              style="display: none"
            />
            <span id="fileName" class="file-name-display">未選擇檔案</span>
          </div>
        </div>


        <!-- 第二排：主要操作按鈕 -->
        <div class="button-row">
          <button
            class="btn btn-secondary"
            id="configBtn"
            onclick="showGridConfig()"
            disabled
          >
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              style="margin-right: 6px"
            >
              <circle
                cx="12"
                cy="12"
                r="3"
                stroke="currentColor"
                stroke-width="2"
              />
              <path
                d="M12 1v6m0 6v6M5.6 5.6l4.2 4.2m4.4 4.4l4.2 4.2M1 12h6m6 0h6M5.6 18.4l4.2-4.2m4.4-4.4l4.2-4.2"
                stroke="currentColor"
                stroke-width="2"
              />
            </svg>
            設定規則並編號
          </button>
          <button
            class="btn btn-success"
            id="exportBtn"
            onclick="exportToExcel()"
            disabled
          >
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              style="margin-right: 6px"
            >
              <path
                d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
                stroke="currentColor"
                stroke-width="2"
              />
              <polyline
                points="14,2 14,8 20,8"
                stroke="currentColor"
                stroke-width="2"
              />
            </svg>
            匯出 Excel
          </button>
          <button
            class="btn btn-autocad"
            id="exportJsonBtn"
            onclick="exportToJSONV2()"
            disabled
          >
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              style="margin-right: 6px"
            >
              <path
                d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"
                stroke="currentColor"
                stroke-width="2"
              />
            </svg>
            匯出 AutoCAD
          </button>
        </div>

        <!-- 第三排：所有控制項在一行 -->
        <div class="filter-row" style="justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 0;">
          <div style="display: flex; gap: 15px; align-items: center;">
            <div class="filter-group">
              <label for="storySelector">樓層</label>
              <select
                id="storySelector"
                onchange="handleStoryChange()"
                disabled
              ></select>
            </div>
            <div class="filter-group">
              <label for="beamTypeSelector">類型</label>
              <select
                id="beamTypeSelector"
                onchange="handleStoryChange()"
                disabled
              >
                <option value="all">全部</option>
                <option value="main">大梁</option>
                <option value="secondary">小梁</option>
              </select>
            </div>
            <div class="filter-group">
              <label for="fontSizeInput">字體大小</label>
              <input
                type="number"
                id="fontSizeInput"
                value="14"
                min="1"
                max="72"
                step="1"
                style="width: 60px; padding: 8px 12px; border: 1px solid var(--theme-border); border-radius: 8px; background-color: #ffffff; color: var(--theme-text-primary);"
                onchange="updateFontSize()"
              />
            </div>
          </div>
          <div style="display: flex; gap: 10px;">
            <button class="btn-process" onclick="toggleGridBubbleControlPanel()" style="padding: 8px 16px;" title="Grid Line 顯示控制">
              🎯 Grid
            </button>
            <button class="btn-process" onclick="openSearchMemberDialog()" style="padding: 8px 16px;">
              🔍 搜尋桿件 (Ctrl+F)
            </button>
            <button class="btn-process" onclick="toggleFullscreen()" style="padding: 8px 16px;" title="全螢幕顯示">
              <span id="fullscreen-icon-top">⛶</span> 全螢幕
            </button>
          </div>
          <!-- [新增] 狀態訊息區域（動態顯示） -->
          <div id="status-inline" style="display: none; width: 100%;"></div>
        </div>
      </div>
      <div id="status" style="display: none;"></div>

      <!-- 格線編號配置面板 -->
      <div id="grid-config-panel" style="display: none; margin-bottom: 20px">
        <div class="control-area" style="position: relative;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0;">格線編號規則設定</h3>
            <button
              onclick="toggleGridConfigHelp()"
              style="
                min-width: 32px;
                width: 32px;
                height: 32px;
                border-radius: 50%;
                background-color: var(--theme-accent);
                color: white;
                border: none;
                font-size: 16px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
                padding: 0;
                flex-shrink: 0;
              "
              onmouseover="this.style.backgroundColor='var(--theme-accent-hover)'"
              onmouseout="this.style.backgroundColor='var(--theme-accent)'"
              title="格線編號說明"
            >💡</button>
          </div>

          <!-- 編號選項 - 上下兩排黑色按鈕 -->
          <div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 15px;">
            <!-- MIRROR 按鈕列 -->
            <div style="display: flex; gap: 10px; align-items: center;">
              <button id="mirrorModeBtn" onclick="openMirrorSettingsModal()" style="
                padding: 8px 16px;
                font-size: 0.9em;
                font-weight: 600;
                background: #1e293b;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                min-width: 90px;
              ">MIRROR</button>
              <span id="mirrorStatusText" style="font-size: 0.85em; color: #1e293b; font-weight: 500;"></span>
            </div>
            <!-- FIXED 按鈕列 -->
            <div style="display: flex; gap: 10px; align-items: center;">
              <button id="fixedLabelBtn" onclick="toggleFixedLabelMode()" style="
                padding: 8px 16px;
                font-size: 0.9em;
                font-weight: 600;
                background: #1e293b;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                min-width: 90px;
              ">FIXED</button>
              <!-- 固定編號摘要顯示 -->
              <div id="fixedLabelSummary" style="font-size: 0.85em; color: #1e293b; font-weight: 500;"></div>
            </div>
            <!-- 隱藏的 checkbox 用於保持相容性 -->
            <input type="checkbox" id="mirrorModeToggle" style="display: none;" />
            <input type="checkbox" id="fixedLabelToggle" style="display: none;" />
          </div>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px">
            <div style="display: flex; flex-direction: column; align-items: center;">
              <h4
                style="color: var(--theme-text-secondary); margin-bottom: 10px;"
              >
                X 軸格線 (垂直方向)
              </h4>
              <div
                id="x-grid-config"
                style="max-height: 300px; overflow-y: auto; width: 100%;"
              ></div>
            </div>
            <div style="display: flex; flex-direction: column; align-items: center;">
              <h4
                style="color: var(--theme-text-secondary); margin-bottom: 10px;"
              >
                Y 軸格線 (水平方向)
              </h4>
              <div
                id="y-grid-config"
                style="max-height: 300px; overflow-y: auto; width: 100%;"
              ></div>
            </div>
          </div>
          <div style="margin-top: 15px; text-align: right">
            <button class="btn-process" onclick="applyGridConfig()">
              套用設定並執行編號
            </button>
            <button class="btn-export" onclick="cancelGridConfig()">
              取消
            </button>
          </div>
        </div>
      </div>

      <!-- [修改] Grid Bubble 顯示控制 Modal -->
      <div id="grid-bubble-overlay" class="dialog-overlay" onclick="closeGridBubbleModal()" style="display: none;"></div>
      <div id="grid-bubble-control-panel" style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10002;
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        min-width: 300px;
        max-width: 450px;
      ">
        <h3 style="margin-top: 0;">🎯 Grid Line 顯示控制</h3>
        <p style="color: var(--theme-text-secondary); margin-bottom: 15px; font-size: 0.9em;">
          💡 可以針對不同 Grid Line 系統開關顯示
        </p>
        <div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px;" id="grid-system-toggles">
          <!-- 動態生成的開關將顯示在這裡 -->
        </div>
        <div style="display: flex; justify-content: flex-end;">
          <button class="btn-export" onclick="closeGridBubbleModal()">關閉</button>
        </div>
      </div>

      <div id="output">
        <div id="drawing">
          <!-- 全螢幕控制器 -->
          <div id="fullscreen-controls">
            <div class="controls-group">
              <button onclick="previousFloor()" title="上一個樓層 (↑)">↑ 上一層</button>
              <div class="floor-info">
                <span id="fullscreen-story-name">所有樓層合併</span>
              </div>
              <button onclick="nextFloor()" title="下一個樓層 (↓)">↓ 下一層</button>
            </div>
            <div class="controls-group">
              <select id="fullscreen-story-selector" onchange="handleFullscreenStoryChange()">
                <option value="all">All Floors</option>
              </select>
              <span class="keyboard-hint">↑↓ 切換樓層 | Esc 離開全螢幕</span>
            </div>
            <button onclick="toggleFullscreen()">✕ 離開全螢幕</button>
          </div>

          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">結構平面圖 (<span id="plan-story-name">所有樓層合併</span>)</h3>
            <button
              onclick="toggleHelpDialog()"
              style="
                min-width: 32px;
                width: 32px;
                height: 32px;
                border-radius: 50%;
                background-color: var(--theme-accent);
                color: white;
                border: none;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
                padding: 0;
                flex-shrink: 0;
              "
              onmouseover="this.style.backgroundColor='var(--theme-accent-hover)'"
              onmouseout="this.style.backgroundColor='var(--theme-accent)'"
              title="選取功能說明"
            >?</button>
          </div>
          <div id="help-info-box" style="display: none; margin-bottom: 10px; padding: 10px; background: var(--theme-bg); border-radius: 8px; font-size: 0.9em; color: var(--theme-text-secondary);">
            <strong style="color: var(--theme-accent);">💡 選取功能說明（類似 AutoCAD）：</strong><br>
            • <strong>點擊梁</strong>：累加選擇（持續選取多個梁）<br>
            • <strong>拖曳</strong>：框選多個梁（左→右藍框完全包含，右→左綠框碰到即選）<br>
            • <strong>Shift + 點擊</strong>：取消選擇指定的梁<br>
            • <strong>Esc</strong>：清除所有選擇<br>
            • <strong>Enter</strong>：批量修改選中梁的編號 | <strong>Ctrl+F</strong>：搜尋桿件
          </div>
          <svg id="drawing-svg"></svg>
        </div>
      </div>
    </div>

    <!-- 梁編號編輯對話框 (移到 container 外面，相對於整個視窗定位) -->
    <div
      id="beam-edit-dialog"
      style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10002;
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        min-width: 400px;
      "
    >
      <h3 style="margin-top: 0">編輯梁編號</h3>
      <div style="margin-bottom: 15px">
        <label
          style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          "
          >ETABS 編號:</label
        >
        <input
          type="text"
          id="edit-etabs-name"
          readonly
          style="
            width: 100%;
            padding: 8px;
            background: var(--theme-bg);
            border: 1px solid var(--theme-border);
            border-radius: 6px;
          "
        />
      </div>
      <div style="margin-bottom: 15px">
        <label
          style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          "
          >樓層:</label
        >
        <input
          type="text"
          id="edit-story"
          readonly
          style="
            width: 100%;
            padding: 8px;
            background: var(--theme-bg);
            border: 1px solid var(--theme-border);
            border-radius: 6px;
          "
        />
      </div>
      <div style="margin-bottom: 20px">
        <label
          style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          "
          >新編號:</label
        >
        <input
          type="text"
          id="edit-new-label"
          style="
            width: 100%;
            padding: 8px;
            border: 1px solid var(--theme-border);
            border-radius: 6px;
          "
          placeholder="輸入新的編號"
        />
      </div>
      <!-- [新增] 連動標準層選項 -->
      <div id="link-standard-floor-group" style="margin-bottom: 15px; display: none;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="link-standard-floor" checked />
          <span>連動標準層</span>
        </label>
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end">
        <button class="btn-export" onclick="closeBeamEditDialog()">取消</button>
        <button class="btn-process" onclick="saveBeamEdit()">儲存</button>
      </div>
    </div>
    <!-- 遮罩層 -->
    <div
      id="dialog-overlay"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 10001;
      "
      onclick="closeBeamEditDialog()"
    ></div>

    <!-- 批量编辑对话框 -->
    <div id="batch-edit-overlay" class="dialog-overlay" onclick="closeBatchEditDialog()"></div>
    <div id="batch-edit-dialog" class="batch-edit-dialog">
      <h3>批量編輯梁編號 (<span id="batch-count">0</span> 個)</h3>
      <div class="dialog-content">
        <div class="input-group">
          <label>新編號:</label>
          <input type="text" id="batch-new-label" placeholder="輸入新的編號 (例如: g1)" />
        </div>
        <div style="color: var(--theme-text-secondary); font-size: 0.9em; margin-top: 10px;">
          提示: 所有選中的梁都會被改成相同的編號
        </div>
        <!-- [新增] 連動標準層選項 -->
        <div id="batch-link-standard-floor-group" style="margin-top: 15px; display: none;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="batch-link-standard-floor" checked />
            <span>連動標準層</span>
          </label>
        </div>
      </div>
      <div class="button-group">
        <button class="btn-export" onclick="closeBatchEditDialog()">取消</button>
        <button class="btn-process" onclick="saveBatchEdit()">確定修改</button>
      </div>
    </div>

    <!-- 搜尋桿件對話框 -->
    <div id="search-member-overlay" class="dialog-overlay" onclick="closeSearchMemberDialog()"></div>
    <div id="search-member-dialog" style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10002;
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        min-width: 450px;
        max-width: 600px;
      ">
      <h3 style="margin-top: 0">🔍 搜尋桿件</h3>
      <div style="margin-bottom: 15px">
        <label style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          ">輸入 ETABS 編號:</label>
        <div style="display: flex; gap: 10px;">
          <input
            type="text"
            id="search-member-input"
            style="
              flex: 1;
              padding: 10px;
              border: 1px solid var(--theme-border);
              border-radius: 6px;
              font-size: 14px;
            "
            placeholder="例如: B65, B1, G2A..."
            onkeypress="if(event.key === 'Enter') searchMember()"
          />
          <button class="btn-process" onclick="searchMember()" style="padding: 10px 20px;">搜尋</button>
        </div>
      </div>
      <div id="search-results" style="
          margin-top: 15px;
          padding: 15px;
          background: var(--theme-bg);
          border-radius: 8px;
          max-height: 300px;
          overflow-y: auto;
        ">
        <div style="color: var(--theme-text-secondary); text-align: center;">
          輸入 ETABS 編號並點擊搜尋
        </div>
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
        <button class="btn-export" onclick="closeSearchMemberDialog()">關閉</button>
      </div>
    </div>

    <!-- 固定編號設定對話框 -->
    <div id="fixed-label-overlay" class="dialog-overlay" onclick="closeFixedLabelModal()"></div>
    <div id="fixed-label-dialog" style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10002;
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        min-width: 500px;
        max-width: 700px;
      ">
      <h3 style="margin-top: 0">固定編號設定</h3>
      <p style="color: var(--theme-text-secondary); margin-bottom: 15px; font-size: 0.9em;">
        💡 將特定尺寸的梁指定為固定編號（例如：樓梯梁 sb25×50 → g1），其他梁編號時會跳過這個號碼<br>
        • 斷面名稱不區分大小寫（sb25×50 和 SB25X50 相同）<br>
        • 固定編號請填寫完整編號（例如：g1, b1, ga1 等）
      </p>
      <div id="fixed-label-modal-rules">
        <div class="fixed-label-rule" style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
          <input type="text" id="fixedSectionModal" placeholder="梁斷面 (例如: sb25×50)"
            style="flex: 1; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; background: var(--theme-bg);" />
          <span style="color: var(--theme-text-secondary);">→</span>
          <input type="text" id="fixedLabelModal" placeholder="完整編號 (例如: g1)"
            style="width: 150px; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; background: var(--theme-bg);" />
          <button onclick="addFixedLabelRuleModal()" class="btn-process" style="padding: 8px 15px;">+ 新增</button>
        </div>
        <div id="fixed-label-modal-list" style="max-height: 300px; overflow-y: auto;"></div>
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
        <button class="btn-export" onclick="closeFixedLabelModal()">關閉</button>
      </div>
    </div>

    <!-- MIRROR 對稱設定對話框 -->
    <div id="mirror-settings-overlay" class="dialog-overlay" onclick="closeMirrorSettingsModal()"></div>
    <div id="mirror-settings-dialog" style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10002;
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        min-width: 400px;
        max-width: 500px;
      ">
      <h3 style="margin-top: 0">⚖️ MIRROR 鏡像模式設定</h3>

      <!-- 啟用開關 -->
      <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px; padding: 12px; background: var(--theme-bg); border-radius: 8px;">
        <label style="font-weight: 600; color: var(--theme-text-primary);">啟用鏡像模式</label>
        <label class="switch" style="margin-left: auto;">
          <input type="checkbox" id="mirrorModeToggleInModal" onchange="toggleMirrorModeFromModal()">
          <span class="slider"></span>
        </label>
        <span id="mirrorModeStatusInModal" style="font-size: 0.9em; min-width: 40px;">關閉</span>
      </div>

      <!-- 主要設定：及格分數、配對容許誤差 (只在啟用鏡像模式時顯示) -->
      <div id="mirrorSettingsSection" style="display: none;">
        <p style="color: var(--theme-text-secondary); margin-bottom: 15px; font-size: 0.9em;">
          • <b>及格分數</b>：對稱匹配分數需達到此值才會啟用鏡像編號<br>
          • <b>配對容許誤差</b>：鏡像梁配對時允許的中點距離誤差
        </p>
        <div style="display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px;">
          <div style="display: flex; align-items: center; gap: 15px;">
            <label for="symmetryPassScore" style="min-width: 120px; color: var(--theme-text-secondary);">及格分數 (%)</label>
            <input
              type="number"
              id="symmetryPassScore"
              value="70"
              min="10"
              max="100"
              step="1"
              style="flex: 1; padding: 10px 12px; border: 1px solid var(--theme-border); border-radius: 8px; background-color: #ffffff; color: var(--theme-text-primary); text-align: center; font-weight: 600; font-size: 1.1em;"
              onchange="updateSymmetrySettings()"
              title="🖱️ 滾輪調整"
            />
          </div>
          <div style="display: flex; align-items: center; gap: 15px;">
            <label for="matchingTolerance" style="min-width: 120px; color: var(--theme-text-secondary);">配對容許誤差 (m)</label>
            <input
              type="number"
              id="matchingTolerance"
              value="0.80"
              min="0.01"
              max="2.00"
              step="0.01"
              style="flex: 1; padding: 10px 12px; border: 1px solid var(--theme-border); border-radius: 8px; background-color: #ffffff; color: var(--theme-text-primary); text-align: center; font-size: 1.1em;"
              onchange="updateSymmetrySettings()"
              title="🖱️ 滾輪調整"
            />
          </div>
        </div>
      </div>

      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button class="btn-export" onclick="closeMirrorSettingsModal()">關閉</button>
      </div>
    </div>

    <script>
      // [修改] 擴充AutoCAD模式縮放的初始尺寸常數
      const INITIAL_BEAM_FONT_SIZE = 6; // [修改] 放大300% (6 * 3)
      const ZOOM_DAMPING_FACTOR = 0.6; // 縮放阻尼係數 (0-1)，越小字體變化越不敏感
      const INITIAL_GRID_FONT_SIZE = 7; // [修改] 再縮小30%（10 * 0.7）
      const INITIAL_GRID_BUBBLE_RADIUS = 18; // [修改] 加大 Bubble
      const INITIAL_BEAM_LABEL_STROKE = 1.5;
      const INITIAL_GRID_BUBBLE_STROKE = 1;
      // [修改] 定義梁標籤與梁中點之間的基準距離 (單位：SVG座標)
      // 這些值會根據字體大小動態調整
      const BASE_OFFSET = 2;  // 基礎固定偏移距離
      const OFFSET_RATIO = 0.25; // 字體大小的偏移比例（偏移 = BASE_OFFSET + fontSize * OFFSET_RATIO）

      // 動態計算偏移距離的函數
      function calculateOffset(fontSize) {
        // 偏移距離 = 固定基礎值 + 字體大小的比例
        // 例如：fontSize=14 時，offset = 2 + 14*0.25 = 5.5
        //      fontSize=8 時，offset = 2 + 8*0.25 = 4
        //      fontSize=20 時，offset = 2 + 20*0.25 = 7
        return BASE_OFFSET + fontSize * OFFSET_RATIO;
      }

      let panZoomInstance = null;
      let fullProcessedBeams = [];
      let fullDrawableBeams = [];
      let availableStories = [];
      let gridData = {};
      let storyOrderInfo = {};
      const TOLERANCE = 0.1;

      // [新增] 預覽模式用的全域變數
      let previewFileContent = null;
      let previewJoints = null;
      let userGridConfig = null; // 使用者自訂的格線編號配置

      // [新增] 梁編輯功能用的全域變數
      let currentEditingBeam = null;

      // [新增] 固定編號設定
      let fixedLabelRules = []; // 儲存 { section: "sb25x50", label: "g1" }

      // [新增] 圈选功能的全域變數
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let selectedBeams = new Set(); // 儲存選中梁的唯一 key (格式: "story|name|joint1|joint2")
      let svgElement = null;

      // [新增] 對稱偵測參數 (可由 UI 調整，這裡設定預設值供後續覆寫)
      let SYMMETRY_PASS_SCORE = 0.7; // 對稱分數及格門檻 (70%)
      let SYMMETRY_TOLERANCE = 0.5; // 幾何容許誤差 (公尺)
      let MATCHING_TOLERANCE = 0.8; // 配對容許誤差 (公尺)

      // [新增] 對稱軸設定相關變數
      let symmetryAxisDirection = 'vertical';  // 'vertical' | 'horizontal'
      let userSymmetryAxisValue = null;        // 用戶自訂的對稱軸值 (null = 自動偵測)
      let detectedSymmetryAxis = null;         // 自動偵測的結果 { direction, value }
      let showSymmetryAxisLine = true;         // 是否顯示對稱軸線
      let axisInputMethod = 'grid';            // 'grid' | 'click' - 對稱軸輸入方式
      let isAxisClickModeActive = false;       // 是否正在等待用戶點選對稱軸位置

      // [新增] 兩點定位對稱軸的變數
      let axisPoint1 = null;  // 第一個 PIN 點 { x, y } (ETABS 座標)
      let axisPoint2 = null;  // 第二個 PIN 點 { x, y } (ETABS 座標)
      let axisPinClickCount = 0;  // 已點擊的 PIN 數量 (0, 1, 2)

      // [新增] 標準層群組快取
      let standardFloorGroupsCache = null;

      // [新增] 滾輪中鍵拖動畫布的狀態變數（類似 AutoCAD）

      // [新增] 字體大小控制
      let currentFontSize = 14; // 預設字體大小（像素）

      // [新增] 顯示內嵌狀態訊息（在控制列內動態顯示，使用原本的樣式）
      function showInlineStatus(message, type = 'success') {
        const statusInline = document.getElementById('status-inline');
        if (!statusInline) return;

        // 使用原本的 <p> 樣式，與舊的 status div 相同
        statusInline.innerHTML = `<p>${message}</p>`;
        statusInline.style.display = 'block';
      }

      // [新增] 隱藏內嵌狀態訊息
      function hideInlineStatus() {
        const statusInline = document.getElementById('status-inline');
        if (statusInline) {
          statusInline.style.display = 'none';
          statusInline.innerHTML = '';
        }
      }

      function updateFontSize() {
        const fontSizeInput = document.getElementById("fontSizeInput");
        currentFontSize = parseInt(fontSizeInput.value) || 14;

        console.log("字體大小已更新為:", currentFontSize);

        // 重新繪製圖表以應用新的字體大小和動態偏移距離
        // 這會確保標籤位置隨字體大小自動調整
        if (typeof handleStoryChange === 'function') {
          handleStoryChange();
        }
      }

      // 為字體大小輸入框添加滑鼠滾輪支援
      document.addEventListener("DOMContentLoaded", function() {
        const fontSizeInput = document.getElementById("fontSizeInput");

        if (fontSizeInput) {
          fontSizeInput.addEventListener("wheel", function(e) {
            e.preventDefault();

            const delta = e.deltaY > 0 ? -1 : 1;
            let newValue = parseInt(this.value) + delta;

            // 限制範圍
            newValue = Math.max(1, Math.min(72, newValue));

            this.value = newValue;
            updateFontSize();
          });
        }

        // 為對稱評分設定輸入框添加滑鼠滾輪支援
        initSymmetrySettingsWheelSupport();

        // 載入儲存的對稱評分設定
        loadSymmetrySettings();
      });

      // [新增] 初始化對稱評分設定的滾輪支援
      function initSymmetrySettingsWheelSupport() {
        const passScoreInput = document.getElementById("symmetryPassScore");
        const matchingToleranceInput = document.getElementById("matchingTolerance");

        // 及格分數滾輪支援 (步長 1%)
        if (passScoreInput) {
          passScoreInput.addEventListener("wheel", function(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -1 : 1;
            let newValue = parseInt(this.value) + delta;
            newValue = Math.max(10, Math.min(100, newValue));
            this.value = newValue;
            updateSymmetrySettings();
          });
        }

        // 配對容許誤差滾輪支援 (步長 0.01m)
        if (matchingToleranceInput) {
          matchingToleranceInput.addEventListener("wheel", function(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.01 : 0.01;
            let newValue = parseFloat(this.value) + delta;
            newValue = Math.max(0.01, Math.min(2.0, newValue));
            this.value = newValue.toFixed(2);
            updateSymmetrySettings();
          });
        }

        // [新增] 對稱軸 Grid Line 下拉選單滾輪支援
        const symmetryGridSelect = document.getElementById("symmetryAxisGridSelect");
        if (symmetryGridSelect) {
          symmetryGridSelect.addEventListener("wheel", function(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 1 : -1;
            const options = this.options;
            let newIndex = this.selectedIndex + delta;

            // 限制範圍 (跳過第一個 "-- 選擇 --" 選項)
            newIndex = Math.max(1, Math.min(options.length - 1, newIndex));

            if (newIndex !== this.selectedIndex && newIndex >= 1) {
              this.selectedIndex = newIndex;
              // 觸發 onchange 事件
              onGridLineSelect();
            }
          });
        }
      }

      // [新增] 更新對稱評分設定 (從 UI 讀取並套用)
      function updateSymmetrySettings() {
        const passScoreInput = document.getElementById("symmetryPassScore");
        const matchingToleranceInput = document.getElementById("matchingTolerance");

        if (passScoreInput) {
          SYMMETRY_PASS_SCORE = parseInt(passScoreInput.value) / 100;
        }
        if (matchingToleranceInput) {
          MATCHING_TOLERANCE = parseFloat(matchingToleranceInput.value);
        }

        // 儲存到 localStorage
        saveSymmetrySettings();

        // 更新 MIRROR 按鈕旁的狀態文字
        if (typeof updateMirrorStatusText === 'function') {
          updateMirrorStatusText();
        }

        console.log(`[對稱評分設定] 及格分數: ${(SYMMETRY_PASS_SCORE * 100).toFixed(0)}%, 配對容許誤差: ${MATCHING_TOLERANCE}m`);
      }

      // [新增] 儲存對稱評分設定到 localStorage
      function saveSymmetrySettings() {
        try {
          const settings = {
            passScore: SYMMETRY_PASS_SCORE,
            matchingTolerance: MATCHING_TOLERANCE
          };
          localStorage.setItem('symmetrySettings', JSON.stringify(settings));
          console.log('✓ 已儲存對稱評分設定');
        } catch (e) {
          console.error('儲存對稱評分設定失敗:', e);
        }
      }

      // [新增] 從 localStorage 載入對稱評分設定
      function loadSymmetrySettings() {
        try {
          const saved = localStorage.getItem('symmetrySettings');
          if (saved) {
            const settings = JSON.parse(saved);

            // 套用設定到全域變數
            if (settings.passScore !== undefined) {
              SYMMETRY_PASS_SCORE = settings.passScore;
            }
            if (settings.matchingTolerance !== undefined) {
              MATCHING_TOLERANCE = settings.matchingTolerance;
            }

            // 更新 UI
            const passScoreInput = document.getElementById("symmetryPassScore");
            const matchingToleranceInput = document.getElementById("matchingTolerance");

            if (passScoreInput) {
              passScoreInput.value = Math.round(SYMMETRY_PASS_SCORE * 100);
            }
            if (matchingToleranceInput) {
              matchingToleranceInput.value = MATCHING_TOLERANCE.toFixed(2);
            }

            console.log(`✓ 已載入對稱評分設定: 及格分數=${(SYMMETRY_PASS_SCORE * 100).toFixed(0)}%, 配對容許誤差=${MATCHING_TOLERANCE}m`);
          }
        } catch (e) {
          console.error('載入對稱評分設定失敗:', e);
        }
      }

      // ============ [新增] 對稱軸設定相關函數 ============

      // 切換對稱軸線顯示
      function toggleSymmetryAxisLine() {
        showSymmetryAxisLine = !showSymmetryAxisLine;

        // 更新 UI 開關狀態
        const checkbox = document.getElementById('toggle-symmetry-axis');
        const toggleSwitch = checkbox?.parentElement;
        if (checkbox) checkbox.checked = showSymmetryAxisLine;
        if (toggleSwitch) {
          if (showSymmetryAxisLine) {
            toggleSwitch.classList.add('active');
          } else {
            toggleSwitch.classList.remove('active');
          }
        }

        // 更新對稱軸線顯示
        const axisLine = document.getElementById('symmetry-axis-line');
        if (axisLine) {
          axisLine.classList.toggle('hidden', !showSymmetryAxisLine);
        }

        saveSymmetryAxisSettings();
        console.log(`對稱軸線 ${showSymmetryAxisLine ? '顯示' : '隱藏'}`);
      }

      // 對稱軸方向變更
      function onAxisDirectionChange() {
        const direction = document.querySelector('input[name="axisDirection"]:checked')?.value || 'vertical';
        symmetryAxisDirection = direction;

        // [修正] 清除之前的自訂值（因為方向改變了），但保持開關狀態
        userSymmetryAxisValue = null;

        // 重新偵測對稱軸
        autoDetectSymmetryAxis();

        // 更新 Grid Line 下拉選單（根據方向顯示 X 或 Y 軸格線）
        populateSymmetryAxisGridDropdown();

        // 重置下拉選單選擇
        const select = document.getElementById('symmetryAxisGridSelect');
        if (select) {
          select.value = '';
        }

        saveSymmetryAxisSettings();
      }

      // 切換自訂對稱軸
      function toggleCustomAxis() {
        const checkbox = document.getElementById('customAxisToggle');
        const toggleSwitch = document.getElementById('customAxisToggleSwitch');

        // 切換 checkbox 狀態
        checkbox.checked = !checkbox.checked;
        const enabled = checkbox.checked;

        // 更新 toggle switch 樣式
        if (enabled) {
          toggleSwitch.classList.add('active');
        } else {
          toggleSwitch.classList.remove('active');
        }

        // 顯示/隱藏選項區塊
        document.getElementById('customAxisOptions').style.display = enabled ? 'block' : 'none';

        if (!enabled) {
          userSymmetryAxisValue = null;  // 恢復使用自動偵測
          disableAxisClickMode();  // [新增] 停用點選模式
          updateAxisDisplay();
          drawSymmetryAxisLine();
        } else {
          // [新增] 如果啟用且輸入方式是 click，則啟動點選模式
          if (axisInputMethod === 'click') {
            enableAxisClickMode();
          }
        }
        saveSymmetryAxisSettings();
      }

      // Grid Line 下拉選單變更
      function onGridLineSelect() {
        const select = document.getElementById('symmetryAxisGridSelect');
        if (select.value) {
          userSymmetryAxisValue = parseFloat(select.value);
          updateAxisDisplay();
          drawSymmetryAxisLine();
          saveSymmetryAxisSettings();
        }
      }

      // [新增] 輸入方式變更
      function onAxisInputMethodChange() {
        const selectedMethod = document.querySelector('input[name="axisInputMethod"]:checked');
        if (!selectedMethod) return;

        axisInputMethod = selectedMethod.value;

        // 切換顯示的輸入區塊
        const gridMethodDiv = document.getElementById('axisInputGridMethod');
        const clickMethodDiv = document.getElementById('axisInputClickMethod');

        if (axisInputMethod === 'grid') {
          gridMethodDiv.style.display = 'flex';
          clickMethodDiv.style.display = 'none';
          disableAxisClickMode();
        } else {
          gridMethodDiv.style.display = 'none';
          clickMethodDiv.style.display = 'block';
          enableAxisClickMode();
        }

        saveSymmetryAxisSettings();
      }

      // [新增] 點選模式的滑鼠狀態追蹤
      let axisClickStartPos = null;
      let axisClickStartTime = null;

      // [新增] 啟用點選模式
      function enableAxisClickMode() {
        isAxisClickModeActive = true;
        const svg = document.getElementById('drawing-svg');
        if (svg) {
          svg.style.cursor = 'crosshair';
        }
        document.addEventListener('mousedown', handleAxisMouseDown, true);
        document.addEventListener('mouseup', handleAxisMouseUp, true);
        console.log('[對稱軸] 點選模式已啟用');
      }

      // [新增] 停用點選模式
      function disableAxisClickMode() {
        isAxisClickModeActive = false;
        const svg = document.getElementById('drawing-svg');
        if (svg) {
          svg.style.cursor = '';
        }
        document.removeEventListener('mousedown', handleAxisMouseDown, true);
        document.removeEventListener('mouseup', handleAxisMouseUp, true);
        axisClickStartPos = null;
        axisClickStartTime = null;
        console.log('[對稱軸] 點選模式已停用');
      }

      // [新增] 檢查點擊是否在 SVG 範圍內
      function isClickInsideSvg(event) {
        const svg = document.getElementById('drawing-svg');
        if (!svg) return false;
        const rect = svg.getBoundingClientRect();
        return (
          event.clientX >= rect.left &&
          event.clientX <= rect.right &&
          event.clientY >= rect.top &&
          event.clientY <= rect.bottom
        );
      }

      // [新增] 處理滑鼠按下
      function handleAxisMouseDown(event) {
        if (!isAxisClickModeActive) return;
        if (event.button !== 0) return;  // 只處理左鍵
        if (!isClickInsideSvg(event)) return;  // 只處理 SVG 範圍內的點擊

        axisClickStartPos = { x: event.clientX, y: event.clientY };
        axisClickStartTime = Date.now();
      }

      // [新增] 處理滑鼠放開（判斷是否為點擊而非拖動）
      function handleAxisMouseUp(event) {
        if (!isAxisClickModeActive) return;
        if (!axisClickStartPos || !axisClickStartTime) return;
        if (event.button !== 0) return;  // 只處理左鍵
        if (!isClickInsideSvg(event)) return;  // 只處理 SVG 範圍內的點擊

        const dx = Math.abs(event.clientX - axisClickStartPos.x);
        const dy = Math.abs(event.clientY - axisClickStartPos.y);
        const dt = Date.now() - axisClickStartTime;

        // 判斷是否為點擊（移動距離 < 5px 且時間 < 300ms）
        if (dx < 5 && dy < 5 && dt < 300) {
          handleAxisClick(event);
        }

        axisClickStartPos = null;
        axisClickStartTime = null;
      }

      // [新增] 處理 SVG 點選事件 - 兩點定位模式
      function handleAxisClick(event) {
        if (!isAxisClickModeActive) return;

        const svg = document.getElementById('drawing-svg');
        if (!svg) return;

        const svgRect = svg.getBoundingClientRect();
        let clickX = event.clientX - svgRect.left;
        let clickY = event.clientY - svgRect.top;

        // 考慮 svg-pan-zoom 的縮放和平移
        if (panZoomInstance) {
          const pan = panZoomInstance.getPan();
          const zoom = panZoomInstance.getZoom();
          clickX = (clickX - pan.x) / zoom;
          clickY = (clickY - pan.y) / zoom;
        }

        // 使用儲存的轉換參數將 SVG 座標轉回 ETABS 座標
        const etabsCoord = svgToEtabsCoord(clickX, clickY);

        if (etabsCoord) {
          axisPinClickCount++;

          if (axisPinClickCount === 1) {
            // 第一個點
            axisPoint1 = { x: etabsCoord.x, y: etabsCoord.y, svgX: clickX, svgY: clickY };
            drawAxisPin(clickX, clickY, 1);
            updateClickAxisPositionDisplay();
            showInlineStatus('📍 已設定第一點，請點選第二點', 'info');
            console.log(`[對稱軸] 點 1: (${etabsCoord.x.toFixed(3)}, ${etabsCoord.y.toFixed(3)})`);
          } else if (axisPinClickCount === 2) {
            // 第二個點
            axisPoint2 = { x: etabsCoord.x, y: etabsCoord.y, svgX: clickX, svgY: clickY };
            drawAxisPin(clickX, clickY, 2);
            drawAxisLine();
            updateClickAxisPositionDisplay();

            // 計算對稱軸值（兩點連線的中點）
            calculateAxisFromTwoPoints();

            // 停用點選模式
            disableAxisClickMode();

            showInlineStatus('✅ 對稱軸已設定完成', 'success');
            console.log(`[對稱軸] 點 2: (${etabsCoord.x.toFixed(3)}, ${etabsCoord.y.toFixed(3)})`);
          }
        }
      }

      // [新增] 繪製 PIN 標記（類似 Google Maps）
      function drawAxisPin(svgX, svgY, pinNumber) {
        const svg = document.getElementById('drawing-svg');
        if (!svg) return;

        // 獲取 viewport 元素（svg-pan-zoom 創建的）
        let viewport = svg.querySelector('.svg-pan-zoom_viewport');
        if (!viewport) viewport = svg;

        // 創建 PIN 圖形群組
        const pinGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        pinGroup.setAttribute('id', `axis-pin-${pinNumber}`);
        pinGroup.setAttribute('class', 'axis-pin-marker');

        // PIN 的大小
        const pinHeight = 30;
        const pinWidth = 20;

        // 創建 PIN 形狀（淚滴形）
        const pin = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        // 淚滴形 SVG path：從頂點開始，畫圓弧和尖端
        const d = `M ${svgX} ${svgY - pinHeight}
                   C ${svgX - pinWidth/2} ${svgY - pinHeight}
                     ${svgX - pinWidth/2} ${svgY - pinHeight/2}
                     ${svgX} ${svgY}
                   C ${svgX + pinWidth/2} ${svgY - pinHeight/2}
                     ${svgX + pinWidth/2} ${svgY - pinHeight}
                     ${svgX} ${svgY - pinHeight}`;
        pin.setAttribute('d', d);
        pin.setAttribute('fill', '#E53935');
        pin.setAttribute('stroke', '#B71C1C');
        pin.setAttribute('stroke-width', '2');
        pin.style.filter = 'drop-shadow(2px 2px 3px rgba(0,0,0,0.4))';

        // PIN 內的圓點
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', svgX);
        circle.setAttribute('cy', svgY - pinHeight * 0.65);
        circle.setAttribute('r', pinWidth / 4);
        circle.setAttribute('fill', 'white');

        // PIN 編號
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', svgX);
        text.setAttribute('y', svgY - pinHeight * 0.6);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('dominant-baseline', 'middle');
        text.setAttribute('fill', '#E53935');
        text.setAttribute('font-size', '10');
        text.setAttribute('font-weight', 'bold');
        text.textContent = pinNumber;

        pinGroup.appendChild(pin);
        pinGroup.appendChild(circle);
        pinGroup.appendChild(text);
        viewport.appendChild(pinGroup);
      }

      // [新增] 繪製兩點之間的軸線
      function drawAxisLine() {
        if (!axisPoint1 || !axisPoint2) return;

        const svg = document.getElementById('drawing-svg');
        if (!svg) return;

        let viewport = svg.querySelector('.svg-pan-zoom_viewport');
        if (!viewport) viewport = svg;

        // 移除舊的軸線
        const oldLine = document.getElementById('custom-axis-line');
        if (oldLine) oldLine.remove();

        // 創建軸線
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('id', 'custom-axis-line');
        line.setAttribute('x1', axisPoint1.svgX);
        line.setAttribute('y1', axisPoint1.svgY);
        line.setAttribute('x2', axisPoint2.svgX);
        line.setAttribute('y2', axisPoint2.svgY);
        line.setAttribute('stroke', '#E53935');
        line.setAttribute('stroke-width', '3');
        line.setAttribute('stroke-dasharray', '10,5');
        line.style.filter = 'drop-shadow(1px 1px 2px rgba(0,0,0,0.3))';

        viewport.appendChild(line);
      }

      // [新增] 從兩點計算對稱軸
      function calculateAxisFromTwoPoints() {
        if (!axisPoint1 || !axisPoint2) return;

        // 計算兩點的中點
        const midX = (axisPoint1.x + axisPoint2.x) / 2;
        const midY = (axisPoint1.y + axisPoint2.y) / 2;

        // 判斷軸的方向（根據兩點的位置關係）
        const dx = Math.abs(axisPoint2.x - axisPoint1.x);
        const dy = Math.abs(axisPoint2.y - axisPoint1.y);

        if (dx > dy) {
          // 水平線（Y = 常數）
          symmetryAxisDirection = 'horizontal';
          userSymmetryAxisValue = midY;
        } else {
          // 垂直線（X = 常數）
          symmetryAxisDirection = 'vertical';
          userSymmetryAxisValue = midX;
        }

        // 更新 UI 中的方向選擇
        const directionRadio = document.querySelector(`input[name="axisDirection"][value="${symmetryAxisDirection}"]`);
        if (directionRadio) directionRadio.checked = true;

        saveSymmetryAxisSettings();
        console.log(`[對稱軸] 計算結果: ${symmetryAxisDirection === 'vertical' ? 'X' : 'Y'} = ${userSymmetryAxisValue.toFixed(3)}`);
      }

      // [新增] 清除 PIN 和軸線
      function clearAxisPins() {
        const svg = document.getElementById('drawing-svg');
        if (svg) {
          const pin1 = document.getElementById('axis-pin-1');
          const pin2 = document.getElementById('axis-pin-2');
          const axisLine = document.getElementById('custom-axis-line');
          if (pin1) pin1.remove();
          if (pin2) pin2.remove();
          if (axisLine) axisLine.remove();
        }
        axisPoint1 = null;
        axisPoint2 = null;
        axisPinClickCount = 0;
      }

      // [新增] 更新點選位置顯示
      function updateClickAxisPositionDisplay() {
        const posDisplay = document.getElementById('clickAxisPosition');
        const clearBtn = document.getElementById('clearClickAxisBtn');

        if (posDisplay) {
          if (axisPoint1 && axisPoint2 && userSymmetryAxisValue !== null) {
            // 兩點都已設定，顯示完整資訊
            const axisLabel = symmetryAxisDirection === 'vertical' ? 'X' : 'Y';
            posDisplay.innerHTML = `
              <div style="font-size: 0.85em;">
                <div>📍 點1: (${axisPoint1.x.toFixed(2)}, ${axisPoint1.y.toFixed(2)})</div>
                <div>📍 點2: (${axisPoint2.x.toFixed(2)}, ${axisPoint2.y.toFixed(2)})</div>
                <div style="color: #2196f3; font-weight: 500; margin-top: 4px;">對稱軸: ${axisLabel} = ${userSymmetryAxisValue.toFixed(3)}</div>
              </div>
            `;
            if (clearBtn) clearBtn.style.display = 'inline-block';
          } else if (axisPoint1) {
            // 只有第一點
            posDisplay.innerHTML = `
              <div style="font-size: 0.85em; color: #ff9800;">
                📍 點1: (${axisPoint1.x.toFixed(2)}, ${axisPoint1.y.toFixed(2)})<br>
                等待設定第二點...
              </div>
            `;
            if (clearBtn) clearBtn.style.display = 'inline-block';
          } else {
            posDisplay.textContent = '-- 尚未設定 --';
            posDisplay.style.color = '';
            if (clearBtn) clearBtn.style.display = 'none';
          }
        }
      }

      // [新增] 清除點選位置
      function clearClickAxisPosition() {
        userSymmetryAxisValue = null;
        // [修正] 同時清除 PIN 標記
        clearAxisPins();
        updateClickAxisPositionDisplay();
        updateAxisDisplay();
        drawSymmetryAxisLine();
        saveSymmetryAxisSettings();
        console.log('[對稱軸] 已清除點選位置');
      }

      // [新增] 開始點選模式（關閉 Modal 並啟用點選）
      function startAxisClickMode() {
        closeMirrorSettingsModal();
        clearAxisPins();
        enableAxisClickMode();
        showInlineStatus('🎯 請在結構平面圖上點選第一個定位點', 'info');
      }

      // [新增] 儲存的座標轉換參數（供反向轉換使用）
      let savedTransformParams = null;

      // [新增] SVG 座標轉換回 ETABS 座標
      function svgToEtabsCoord(svgX, svgY) {
        if (!savedTransformParams) {
          console.warn('[對稱軸] 尚未有座標轉換參數，請確認已載入檔案');
          return null;
        }

        const { scale, offsetX, offsetY, minX, minY, svgHeight } = savedTransformParams;
        const etabsX = (svgX - offsetX) / scale + minX;
        const etabsY = (svgHeight - offsetY - svgY) / scale + minY;

        return { x: etabsX, y: etabsY };
      }

      // 更新對稱軸顯示
      function updateAxisDisplay() {
        const display = document.getElementById('currentAxisDisplay');
        if (!display) return;

        const axisValue = userSymmetryAxisValue ?? detectedSymmetryAxis?.value;
        const axisLabel = symmetryAxisDirection === 'vertical' ? 'X' : 'Y';

        if (axisValue !== null && axisValue !== undefined) {
          const source = userSymmetryAxisValue !== null ? '自訂' : '自動偵測';
          display.textContent = `目前對稱軸: ${axisLabel} = ${axisValue.toFixed(2)} (${source})`;
        } else {
          display.textContent = `目前對稱軸: -- (尚未偵測)`;
        }
      }

      // 填充 Grid Line 下拉選單（根據方向顯示 X 或 Y 軸格線）
      function populateSymmetryAxisGridDropdown() {
        const select = document.getElementById('symmetryAxisGridSelect');
        if (!select) return;

        select.innerHTML = '<option value="">-- 選擇 --</option>';

        // 根據方向選擇 X 或 Y 軸格線
        const grids = symmetryAxisDirection === 'vertical' ? gridData?.x : gridData?.y;
        const axisLabel = symmetryAxisDirection === 'vertical' ? 'X' : 'Y';

        if (grids) {
          grids.forEach(grid => {
            const option = document.createElement('option');
            option.value = grid.ordinate;
            // [修正] 使用 grid.name 而非 grid.label，顯示格式: "Grid名稱 (X/Y=座標)"
            option.textContent = `${grid.name} (${axisLabel}=${grid.ordinate})`;
            select.appendChild(option);
          });
        }
      }

      // 自動偵測對稱軸（載入 E2K 後呼叫）
      function autoDetectSymmetryAxis() {
        // 需要有梁資料才能偵測
        if (!fullProcessedBeams || fullProcessedBeams.length === 0) {
          console.log('[對稱軸偵測] 沒有梁資料，跳過偵測');
          return;
        }

        // 使用現有的 detectSymmetryAxis 函數進行偵測
        // 這裡我們使用所有樓層的梁來偵測全域對稱軸
        const allBeams = fullProcessedBeams.flatMap(floor => floor.beams || []);

        if (allBeams.length === 0) {
          console.log('[對稱軸偵測] 沒有梁資料，跳過偵測');
          return;
        }

        // 根據方向偵測對稱軸 (修正: joints → previewJoints)
        const axisValue = detectSymmetryAxisWithDirection(allBeams, previewJoints, gridData, symmetryAxisDirection);

        if (axisValue !== null) {
          detectedSymmetryAxis = {
            direction: symmetryAxisDirection,
            value: axisValue
          };
          console.log(`[對稱軸偵測] ${symmetryAxisDirection === 'vertical' ? 'X' : 'Y'} = ${axisValue.toFixed(3)}`);
        } else {
          detectedSymmetryAxis = null;
          console.log('[對稱軸偵測] 未找到明顯對稱結構');
        }

        updateAxisDisplay();
        drawSymmetryAxisLine();
      }

      // 偵測對稱軸（支援方向參數）
      function detectSymmetryAxisWithDirection(beams, joints, gridData, direction = 'vertical') {
        if (!beams || beams.length === 0) return null;

        // 收集所有座標
        const coords = [];
        beams.forEach(beam => {
          const j1 = joints[beam.joint1];
          const j2 = joints[beam.joint2];
          if (j1 && j2) {
            if (direction === 'vertical') {
              coords.push(j1.x, j2.x);
            } else {
              coords.push(j1.y, j2.y);
            }
          }
        });

        if (coords.length === 0) return null;

        // 計算範圍和中心
        const minCoord = Math.min(...coords);
        const maxCoord = Math.max(...coords);
        const centerCoord = (minCoord + maxCoord) / 2;

        // 測試候選對稱軸（幾何中心 + 格線位置）
        const candidates = [centerCoord];

        const grids = direction === 'vertical' ? gridData?.x : gridData?.y;
        if (grids) {
          grids.forEach(grid => {
            if (grid.ordinate > minCoord && grid.ordinate < maxCoord) {
              candidates.push(grid.ordinate);
            }
          });
        }

        // 評估每個候選軸的對稱性
        let bestAxis = null;
        let bestScore = 0;

        candidates.forEach(axisCoord => {
          let matchCount = 0;
          let totalCount = 0;

          beams.forEach(beam => {
            const j1 = joints[beam.joint1];
            const j2 = joints[beam.joint2];
            if (!j1 || !j2) return;

            const midCoord = direction === 'vertical'
              ? (j1.x + j2.x) / 2
              : (j1.y + j2.y) / 2;
            const otherCoord = direction === 'vertical'
              ? (j1.y + j2.y) / 2
              : (j1.x + j2.x) / 2;
            const length = Math.sqrt((j2.x - j1.x) ** 2 + (j2.y - j1.y) ** 2);

            // 跳過在軸上的梁
            if (Math.abs(midCoord - axisCoord) < SYMMETRY_TOLERANCE) return;

            totalCount++;

            // 尋找鏡像梁
            const mirroredCoord = 2 * axisCoord - midCoord;
            const hasMatch = beams.some(otherBeam => {
              if (otherBeam === beam) return false;
              const oj1 = joints[otherBeam.joint1];
              const oj2 = joints[otherBeam.joint2];
              if (!oj1 || !oj2) return false;

              const otherMidCoord = direction === 'vertical'
                ? (oj1.x + oj2.x) / 2
                : (oj1.y + oj2.y) / 2;
              const otherOtherCoord = direction === 'vertical'
                ? (oj1.y + oj2.y) / 2
                : (oj1.x + oj2.x) / 2;
              const otherLength = Math.sqrt((oj2.x - oj1.x) ** 2 + (oj2.y - oj1.y) ** 2);

              return Math.abs(otherMidCoord - mirroredCoord) < MATCHING_TOLERANCE &&
                     Math.abs(otherOtherCoord - otherCoord) < MATCHING_TOLERANCE &&
                     Math.abs(otherLength - length) < 1.0;
            });

            if (hasMatch) matchCount++;
          });

          const score = totalCount > 0 ? matchCount / totalCount : 0;
          if (score > bestScore) {
            bestScore = score;
            bestAxis = axisCoord;
          }
        });

        // 如果對稱分數 > 及格門檻，返回對稱軸
        if (bestScore > SYMMETRY_PASS_SCORE) {
          // Snap to Grid: 如果最佳軸接近某個 grid line，校正到 grid line
          const SNAP_TOLERANCE = 0.5;
          if (grids) {
            for (const grid of grids) {
              if (Math.abs(bestAxis - grid.ordinate) < SNAP_TOLERANCE) {
                console.log(`[對稱軸偵測] 校正: ${bestAxis.toFixed(3)} → Grid ${grid.label} (${grid.ordinate})`);
                bestAxis = grid.ordinate;
                break;
              }
            }
          }
          return bestAxis;
        }

        return null;
      }

      // 繪製對稱軸線
      function drawSymmetryAxisLine() {
        // 移除舊的對稱軸線
        const oldLine = document.getElementById('symmetry-axis-line');
        if (oldLine) oldLine.remove();

        if (!showSymmetryAxisLine) return;

        const axisValue = userSymmetryAxisValue ?? detectedSymmetryAxis?.value;
        if (axisValue === null || axisValue === undefined) return;

        const svg = document.getElementById('drawing-svg');
        if (!svg) return;

        // 取得 SVG 視圖範圍
        const viewBox = svg.getAttribute('viewBox')?.split(' ').map(Number);
        if (!viewBox || viewBox.length < 4) return;

        const [vbX, vbY, vbW, vbH] = viewBox;

        // 建立對稱軸線
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('id', 'symmetry-axis-line');
        line.setAttribute('class', 'symmetry-axis-line');

        const direction = userSymmetryAxisValue !== null
          ? symmetryAxisDirection
          : (detectedSymmetryAxis?.direction || 'vertical');

        if (direction === 'vertical') {
          // 垂直線 (X = 常數)
          line.setAttribute('x1', axisValue);
          line.setAttribute('y1', vbY);
          line.setAttribute('x2', axisValue);
          line.setAttribute('y2', vbY + vbH);
        } else {
          // 水平線 (Y = 常數)
          line.setAttribute('x1', vbX);
          line.setAttribute('y1', axisValue);
          line.setAttribute('x2', vbX + vbW);
          line.setAttribute('y2', axisValue);
        }

        // 插入到 viewport 中（放在最底層）
        const viewport = getViewportElement();
        if (viewport) {
          viewport.insertBefore(line, viewport.firstChild);
        }
      }

      // 儲存對稱軸設定
      function saveSymmetryAxisSettings() {
        try {
          const settings = {
            direction: symmetryAxisDirection,
            userValue: userSymmetryAxisValue,
            showLine: showSymmetryAxisLine,
            inputMethod: axisInputMethod  // [新增] 儲存輸入方式
          };
          localStorage.setItem('symmetryAxisSettings', JSON.stringify(settings));
        } catch (e) {
          console.error('儲存對稱軸設定失敗:', e);
        }
      }

      // 載入對稱軸設定 (僅自動偵測，不再支援自訂)
      function loadSymmetryAxisSettings() {
        try {
          const saved = localStorage.getItem('symmetryAxisSettings');
          if (saved) {
            const settings = JSON.parse(saved);
            symmetryAxisDirection = settings.direction ?? 'vertical';
            // 不再載入自訂值，強制使用自動偵測
            userSymmetryAxisValue = null;
            showSymmetryAxisLine = settings.showLine ?? true;

            console.log(`✓ 已載入對稱軸設定: 方向=${symmetryAxisDirection}, 顯示=${showSymmetryAxisLine} (僅自動偵測)`);
          }
        } catch (e) {
          console.error('載入對稱軸設定失敗:', e);
        }
      }

      // ============ 對稱軸設定函數結束 ============

      let isMiddleMousePanning = false;
      let middleMouseStartPos = null;

      // [新增] 從 localStorage 載入固定編號規則
      function loadFixedLabelRules() {
        try {
          const saved = localStorage.getItem('fixedLabelRules');
          if (saved) {
            fixedLabelRules = JSON.parse(saved);
            updateFixedLabelList();
            console.log('✓ 已載入固定編號規則:', fixedLabelRules);
          }
        } catch (e) {
          console.error('載入固定編號規則失敗:', e);
        }
      }

      // [新增] 儲存固定編號規則到 localStorage
      function saveFixedLabelRules() {
        try {
          localStorage.setItem('fixedLabelRules', JSON.stringify(fixedLabelRules));
          console.log('✓ 已儲存固定編號規則');
        } catch (e) {
          console.error('儲存固定編號規則失敗:', e);
        }
      }

      // [新增] MIRROR 模式切換和設定函數
      function toggleMirrorModeFromModal() {
        const modalCheckbox = document.getElementById('mirrorModeToggleInModal');
        const mainCheckbox = document.getElementById('mirrorModeToggle');
        const statusInModal = document.getElementById('mirrorModeStatusInModal');
        const settingsSection = document.getElementById('mirrorSettingsSection');

        // 同步兩個 checkbox
        mainCheckbox.checked = modalCheckbox.checked;

        // 更新彈窗內的狀態文字和設定區塊顯示
        if (modalCheckbox.checked) {
          statusInModal.textContent = '開啟';
          statusInModal.style.color = '#f97316';
          settingsSection.style.display = 'block';
        } else {
          statusInModal.textContent = '關閉';
          statusInModal.style.color = 'var(--theme-text-secondary)';
          settingsSection.style.display = 'none';
        }

        updateMirrorStatusText();
      }

      function updateMirrorStatusText() {
        const statusText = document.getElementById('mirrorStatusText');
        if (document.getElementById('mirrorModeToggle').checked) {
          statusText.innerHTML = `已啟用：及格 ${Math.round(SYMMETRY_PASS_SCORE * 100)}% | 誤差 ${MATCHING_TOLERANCE.toFixed(2)}m`;
        } else {
          statusText.textContent = '未啟用';
        }
        // 按鈕保持黑色，不隨啟用狀態改變顏色
      }

      function openMirrorSettingsModal() {
        // 同步彈窗內的開關狀態
        const mainCheckbox = document.getElementById('mirrorModeToggle');
        const modalCheckbox = document.getElementById('mirrorModeToggleInModal');
        const statusInModal = document.getElementById('mirrorModeStatusInModal');
        const settingsSection = document.getElementById('mirrorSettingsSection');

        modalCheckbox.checked = mainCheckbox.checked;
        if (mainCheckbox.checked) {
          statusInModal.textContent = '開啟';
          statusInModal.style.color = '#f97316';
          settingsSection.style.display = 'block';
        } else {
          statusInModal.textContent = '關閉';
          statusInModal.style.color = 'var(--theme-text-secondary)';
          settingsSection.style.display = 'none';
        }

        document.getElementById('mirror-settings-dialog').style.display = 'block';
        document.getElementById('mirror-settings-overlay').style.display = 'block';
        // 防止背景滾動
        document.body.style.overflow = "hidden";
      }

      function closeMirrorSettingsModal() {
        document.getElementById('mirror-settings-dialog').style.display = 'none';
        document.getElementById('mirror-settings-overlay').style.display = 'none';
        // 恢復背景滾動
        document.body.style.overflow = "";
        updateMirrorStatusText();
      }

      // [新增] 格線編號說明提示
      function toggleGridConfigHelp() {
        // 檢查是否已有提示框
        const existingHelp = document.getElementById('grid-config-help-popup');
        const existingOverlay = document.getElementById('grid-config-help-overlay');
        if (existingHelp) {
          existingHelp.remove();
          if (existingOverlay) existingOverlay.remove();
          return;
        }

        // 創建提示框
        const helpPopup = document.createElement('div');
        helpPopup.id = 'grid-config-help-popup';
        helpPopup.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          z-index: 10003;
          background: var(--theme-surface);
          border: 1px solid var(--theme-border);
          border-radius: 12px;
          padding: 20px;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
          max-width: 450px;
        `;
        helpPopup.innerHTML = `
          <h3 style="margin-top: 0; display: flex; align-items: center; gap: 8px;">
            <span style="font-size: 1.2em;">💡</span> 格線編號說明
          </h3>
          <div style="color: var(--theme-text-secondary); font-size: 0.95em; line-height: 1.6;">
            <p style="margin-bottom: 10px;">
              • 輸入<b>數字</b>後，系統會自動幫後面的格線<b>順號</b><br>
              <span style="color: var(--theme-text-secondary); font-size: 0.9em; margin-left: 12px;">
                例如：設定 A=1，系統自動設定 B=2, C=3...
              </span>
            </p>
            <p style="margin-bottom: 10px;">
              • 輸入 <code style="background: var(--theme-bg); padding: 2px 6px; border-radius: 3px;">-</code> /
              <code style="background: var(--theme-bg); padding: 2px 6px; border-radius: 3px;">skip</code> / 留空<br>
              <span style="color: var(--theme-text-secondary); font-size: 0.9em; margin-left: 12px;">
                來跳過不編號的格線
              </span>
            </p>
            <p style="margin-bottom: 0;">
              • 您隨時可以手動修改任何格線的編號
            </p>
          </div>
          <div style="text-align: right; margin-top: 15px;">
            <button onclick="document.getElementById('grid-config-help-popup').remove(); document.getElementById('grid-config-help-overlay').remove();"
                    class="btn-export" style="padding: 8px 20px;">
              知道了
            </button>
          </div>
        `;

        // 創建遮罩
        const overlay = document.createElement('div');
        overlay.id = 'grid-config-help-overlay';
        overlay.className = 'dialog-overlay';
        overlay.style.display = 'block';
        overlay.onclick = function() {
          helpPopup.remove();
          overlay.remove();
        };

        document.body.appendChild(overlay);
        document.body.appendChild(helpPopup);
      }

      // [新增] 固定編號功能函數
      function toggleFixedLabelConfig() {
        updateFixedLabelSummary();
      }

      function toggleFixedLabelMode() {
        // 開啟設定對話框
        openFixedLabelModal();
      }

      function openFixedLabelModal() {
        document.getElementById('fixed-label-dialog').style.display = 'block';
        document.getElementById('fixed-label-overlay').style.display = 'block';
        updateFixedLabelModalList();
        // 防止背景滾動
        document.body.style.overflow = 'hidden';
      }

      function closeFixedLabelModal() {
        document.getElementById('fixed-label-dialog').style.display = 'none';
        document.getElementById('fixed-label-overlay').style.display = 'none';
        updateFixedLabelSummary();
        updateFixedLabelButtonState();
        // 恢復背景滾動
        document.body.style.overflow = '';
      }

      function updateFixedLabelSummary() {
        const summaryDiv = document.getElementById('fixedLabelSummary');
        if (fixedLabelRules.length === 0) {
          summaryDiv.innerHTML = '<span style="color: var(--theme-text-secondary);">尚未設定任何規則</span>';
        } else {
          const summary = fixedLabelRules.map(r => `${r.section} → ${r.label}`).join(', ');
          summaryDiv.innerHTML = `<span style="color: var(--theme-accent);">已設定 ${fixedLabelRules.length} 條規則：</span> ${summary}`;
        }
      }

      function updateFixedLabelButtonState() {
        const checkbox = document.getElementById('fixedLabelToggle');

        if (fixedLabelRules.length > 0) {
          // 有規則時：啟用功能
          checkbox.checked = true;
        } else {
          // 沒有規則時：停用功能
          checkbox.checked = false;
        }
      }

      // 固定編號彈出視窗版本的函數
      function addFixedLabelRuleModal() {
        const sectionInput = document.getElementById("fixedSectionModal");
        const labelInput = document.getElementById("fixedLabelModal");

        const section = sectionInput.value.trim().toLowerCase(); // 統一轉小寫儲存
        const label = labelInput.value.trim().toLowerCase(); // 統一轉小寫儲存

        if (!section || !label) {
          alert("請填寫梁斷面和固定編號");
          return;
        }

        // 檢查編號格式（至少要有一個字母和數字）
        if (!/^[a-z]+\d+/.test(label)) {
          alert("固定編號格式錯誤，請填寫完整編號（例如：g1, b1, ga1）");
          return;
        }

        // 檢查是否已存在
        if (fixedLabelRules.some(r => r.section === section)) {
          alert(`斷面 "${section}" 已設定過固定編號`);
          return;
        }

        fixedLabelRules.push({ section, label });

        // 儲存到 localStorage
        saveFixedLabelRules();

        // 清空輸入框
        sectionInput.value = "";
        labelInput.value = "";

        // 更新顯示列表
        updateFixedLabelModalList();
        updateFixedLabelSummary();
        updateFixedLabelButtonState();
      }

      function updateFixedLabelModalList() {
        const listDiv = document.getElementById("fixed-label-modal-list");

        if (fixedLabelRules.length === 0) {
          listDiv.innerHTML = '<p style="color: var(--theme-text-secondary); font-size: 0.9em; text-align: center;">尚未新增任何規則</p>';
          return;
        }

        listDiv.innerHTML = fixedLabelRules.map((rule, index) => `
          <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px; padding: 10px; background: var(--theme-bg); border-radius: 6px;">
            <span style="flex: 1; color: var(--theme-text);">${rule.section}</span>
            <span style="color: var(--theme-text-secondary);">→</span>
            <span style="width: 120px; color: var(--theme-accent); font-weight: 500;">${rule.label}</span>
            <button onclick="removeFixedLabelRuleModal(${index})" class="btn-export" style="padding: 6px 12px; font-size: 0.85em;">刪除</button>
          </div>
        `).join('');
      }

      function removeFixedLabelRuleModal(index) {
        fixedLabelRules.splice(index, 1);
        saveFixedLabelRules(); // 儲存變更
        updateFixedLabelModalList();
        updateFixedLabelSummary();
        updateFixedLabelButtonState();
      }

      // [新增] 預覽檔案函式
      async function previewFile() {
        console.log("[DEBUG] previewFile() called");

        try {
          const fileInput = document.getElementById("e2kFile");
          const statusDiv = document.getElementById("status");
          const storySelector = document.getElementById("storySelector");
          const beamTypeSelector = document.getElementById("beamTypeSelector");
          const drawingSvg = document.getElementById("drawing-svg");
          const gridConfigPanel = document.getElementById("grid-config-panel");

          // 檢查必要的 DOM 元素是否存在
          if (!fileInput || !statusDiv || !storySelector || !drawingSvg) {
            console.error("[ERROR] Required DOM elements not found");
            if (statusDiv) {
              statusDiv.innerHTML = '<p class="error">頁面初始化錯誤，請重新載入頁面</p>';
            }
            return;
          }

          statusDiv.innerHTML = "";

          // [修正] 在清空 SVG 之前先銷毀 panZoomInstance，避免 removeChild 錯誤
          if (panZoomInstance) {
            try {
              panZoomInstance.destroy();
            } catch (e) {
              console.warn("[WARN] Failed to destroy panZoomInstance:", e);
            }
            panZoomInstance = null;
          }

          drawingSvg.innerHTML = "";
          if (gridConfigPanel) {
            gridConfigPanel.style.display = "none";
          }

          // [修正] 清空編號資料，確保切換檔案時進入預覽模式
          fullProcessedBeams = [];

          if (fileInput.files.length === 0) {
            statusDiv.innerHTML = '<p class="error">請先選擇 .e2k 檔案</p>';
            return;
          }

          const file = fileInput.files[0];
          statusDiv.innerHTML = `<p>正在讀取檔案 "${file.name}"...</p>`;
          console.log(`[DEBUG] Reading file: ${file.name}`);

          previewFileContent = await file.text();

          // 解析樓層
          const storySectionMatch = previewFileContent.match(
            /\$ STORIES - IN SEQUENCE FROM TOP([\s\S]*?)(?=\$|$)/i,
          );
          if (!storySectionMatch) throw new Error("找不到樓層定義");

          const allStoryNames = storySectionMatch[1]
            .trim()
            .split("\n")
            .map((line) => line.match(/STORY\s+"([^"]+)"/i)?.[1])
            .filter(Boolean);
          if (allStoryNames.length === 0) throw new Error("樓層定義為空");

          availableStories = allStoryNames;
          populateStorySelector();

          // 解析格線和節點
          gridData = parseGrids(previewFileContent);
          previewJoints = parseJoints(previewFileContent);

          // [新增] 載入已儲存的格線配置
          try {
            const saved = localStorage.getItem('userGridConfig');
            if (saved) {
              userGridConfig = JSON.parse(saved);
              console.log('✓ 已載入格線編號規則');
            }
          } catch (e) {
            console.error('載入格線編號規則失敗:', e);
          }

          // 解析所有梁並顯示
          let allBeamsAcrossStories = [];
          for (const story of availableStories) {
            const frames = parseFrames(previewFileContent, story);
            if (frames.length > 0) allBeamsAcrossStories.push(...frames);
          }

          fullDrawableBeams = allBeamsAcrossStories.map((f) => ({
            ...f,
            j1: previewJoints[f.joint1],
            j2: previewJoints[f.joint2],
          }));

          storyOrderInfo = availableStories.reduce((acc, story, index) => {
            acc[story] = index;
            return acc;
          }, {});

          // 顯示預覽圖
          if (availableStories.includes("2F")) {
            storySelector.value = "2F";
          }
          handleStoryChange();

          // [修改] 顯示狀態訊息到控制列的內嵌區域
          showInlineStatus(`✅ 預覽完成！找到 ${availableStories.length} 個樓層，${allBeamsAcrossStories.length} 根梁`, 'success');
          console.log(`[DEBUG] Preview completed: ${availableStories.length} floors, ${allBeamsAcrossStories.length} beams`);

          // 啟用「設定編號規則並執行」按鈕
          const configBtn = document.getElementById("configBtn");
          if (configBtn) {
            configBtn.disabled = false;
          }
        } catch (error) {
          console.error("[ERROR] Preview failed:", error);
          const statusDiv = document.getElementById("status");
          if (statusDiv) {
            statusDiv.innerHTML = `<p class="error">預覽失敗: ${error.message}</p><p class="error">請查看瀏覽器控制台以獲取詳細錯誤信息</p>`;
          }
          // 重新拋出錯誤以便在控制台看到完整堆疊
          throw error;
        }
      }

      // [新增] 顯示格線配置介面
      function showGridConfig() {
        if (!gridData || (!gridData.x.length && !gridData.y.length)) {
          alert("請先預覽檔案");
          return;
        }

        const panel = document.getElementById("grid-config-panel");
        const xConfigDiv = document.getElementById("x-grid-config");
        const yConfigDiv = document.getElementById("y-grid-config");

        // [新增] 獲取已儲存的格線配置值
        const getSavedValue = (axis, gridName, defaultIndex) => {
          if (userGridConfig && userGridConfig[axis]) {
            const savedConfig = userGridConfig[axis].find(c => c.name === gridName);
            if (savedConfig) {
              if (savedConfig.serialValue === null) {
                return '-'; // 跳過的格線
              }
              return savedConfig.serialValue;
            }
          }
          return defaultIndex + 1; // 預設值
        };

        // [新增] Grid Line 系統顏色配置（與結構平面圖的 Grid Bubble 一致）
        const COORDSYSTEM_COLORS = {
          'GLOBAL': '#4A90E2',  // 藍色 - GLOBAL 系統
          'O2': '#E24A4A',      // 紅色
          'A2': '#50C878',      // 綠色
          'A3': '#F39C12',      // 橙色
          'DEFAULT': '#9B59B6'  // 紫色 - 其他系統
        };

        const getCoordSystemColor = (coordsystem) => {
          return COORDSYSTEM_COLORS[coordsystem] || COORDSYSTEM_COLORS['DEFAULT'];
        };

        // [修正] 計算 X 和 Y 軸所有 Grid 名稱中最長的，統一所有圓的大小
        let globalMaxLen = 0;
        [...gridData.x, ...gridData.y].forEach(g => {
          if (g.name.length > globalMaxLen) globalMaxLen = g.name.length;
        });
        // 統一圓的直徑（基於最長名稱，最小 60px，確保所有系統一致）
        const globalCircleSize = Math.max(60, 40 + globalMaxLen * 10);

        // 輔助函數：按 COORDSYSTEM 分組生成格線配置 HTML (圓形分割設計)
        const generateGridConfigHTML = (grids, axis) => {
          let html = '';
          let currentCoordSystem = null;
          let globalIndex = 0;
          let cardsInGroup = [];
          let groupStartIndex = 0;

          // 使用全域統一的圓大小
          const circleSize = globalCircleSize;

          const flushCards = () => {
            if (cardsInGroup.length > 0) {
              // [修正] 使用 CSS Grid 固定每排 5 顆圓，置中對齊
              html += `<div style="display: grid; grid-template-columns: repeat(5, ${circleSize}px); gap: 12px; margin-bottom: 15px; justify-content: center;">${cardsInGroup.join('')}</div>`;
              cardsInGroup = [];
            }
          };

          grids.forEach((grid) => {
            const coordsystem = grid.coordsystem || 'GLOBAL';

            // 如果是新的 COORDSYSTEM，先輸出之前的卡片，再添加分組標題
            if (coordsystem !== currentCoordSystem) {
              flushCards();
              currentCoordSystem = coordsystem;
              groupStartIndex = globalIndex;
              html += `
                <div style="margin-top: ${globalIndex > 0 ? '15px' : '0'}; margin-bottom: 8px; padding: 6px 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-weight: 600; font-size: 0.85em; border-radius: 4px; display: inline-block;">
                  📐 ${coordsystem}
                </div>
              `;
            }

            const savedValue = getSavedValue(axis, grid.name, globalIndex);
            const bgColor = getCoordSystemColor(coordsystem);
            // 根據圓的大小動態調整字體大小
            const fontSize = circleSize <= 60 ? '0.85em' : (circleSize <= 70 ? '0.8em' : '0.75em');
            const inputFontSize = circleSize <= 60 ? '0.9em' : '0.85em';

            // 圓形分割設計：上半圓顯示 Grid 名稱，下半圓顯示可編輯流水號
            cardsInGroup.push(`
              <div style="
                width: ${circleSize}px;
                height: ${circleSize}px;
                border-radius: 50%;
                overflow: hidden;
                box-shadow: 0 2px 6px rgba(0,0,0,0.15);
                display: flex;
                flex-direction: column;
                border: 2px solid ${bgColor};
              ">
                <!-- 上半圓：Grid 名稱 -->
                <div style="
                  height: 50%;
                  background: ${bgColor};
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  color: white;
                  font-weight: 600;
                  font-size: ${fontSize};
                  white-space: nowrap;
                  padding: 0 4px;
                  box-sizing: border-box;
                ">${grid.name}</div>
                <!-- 下半圓：可編輯流水號 -->
                <div style="
                  height: 50%;
                  background: white;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  padding: 0 2px;
                  box-sizing: border-box;
                ">
                  <input type="text"
                    id="${axis}-grid-${globalIndex}"
                    value="${savedValue}"
                    style="
                      width: 100%;
                      height: 100%;
                      border: none;
                      background: transparent;
                      text-align: center;
                      font-size: ${inputFontSize};
                      font-weight: 500;
                      color: var(--theme-text-primary);
                      outline: none;
                      padding: 0;
                    "
                    placeholder="-"
                    title="輸入數字、名稱，或使用 - / skip / 空白 來跳過此格線"
                    data-axis="${axis}"
                    data-index="${globalIndex}"
                  />
                </div>
              </div>
            `);
            globalIndex++;
          });

          // 輸出最後一組的卡片
          flushCards();

          return html;
        };

        // 生成 X 軸格線配置（按 COORDSYSTEM 分組）
        xConfigDiv.innerHTML = generateGridConfigHTML(gridData.x, 'x');

        // 生成 Y 軸格線配置（按 COORDSYSTEM 分組）
        yConfigDiv.innerHTML = generateGridConfigHTML(gridData.y, 'y');

        // [新增] 為所有輸入框添加自動順號事件
        attachAutoIncrementListeners();

        panel.style.display = "block";
      }

      // [新增] 自動順號功能
      function attachAutoIncrementListeners() {
        const allInputs = document.querySelectorAll(
          "#x-grid-config input, #y-grid-config input",
        );

        allInputs.forEach((input) => {
          // [修正] 使用 blur 事件而非 change，確保離開輸入框時觸發
          input.addEventListener("blur", function () {
            handleAutoIncrement(this);
          });

          // [新增] 按 Enter 鍵也觸發自動順號
          input.addEventListener("keydown", function (e) {
            if (e.key === "Enter") {
              e.preventDefault();
              this.blur(); // 觸發 blur 事件
            }
          });
        });
      }

      // [新增] 自動順號處理函數
      function handleAutoIncrement(inputElement) {
        const axis = inputElement.dataset.axis; // 'x' 或 'y'
        const currentIndex = parseInt(inputElement.dataset.index);
        const currentValue = inputElement.value.trim();

        // 如果輸入的是數字，才自動順號
        const parsedNum = parseInt(currentValue, 10);
        if (
          isNaN(parsedNum) ||
          currentValue === "" ||
          currentValue === "-" ||
          currentValue.toLowerCase() === "skip"
        ) {
          return; // 非數字或跳過標記，不自動順號
        }

        // [修正] 獲取當前格線的座標系統
        const gridsArray = axis === "x" ? gridData.x : gridData.y;
        const currentGrid = gridsArray[currentIndex];
        const currentCoordSystem = currentGrid.coordsystem || 'GLOBAL';

        // 自動更新後面的格線編號（只更新同一座標系統內的格線）
        const totalGrids = gridsArray.length;
        let nextValue = parsedNum + 1;

        for (let i = currentIndex + 1; i < totalGrids; i++) {
          const nextGrid = gridsArray[i];
          const nextCoordSystem = nextGrid.coordsystem || 'GLOBAL';

          // [新增] 檢查是否為同一座標系統
          if (nextCoordSystem !== currentCoordSystem) {
            // 遇到不同座標系統，停止自動順號
            break;
          }

          const nextInput = document.getElementById(`${axis}-grid-${i}`);
          if (nextInput) {
            const nextInputValue = nextInput.value.trim();
            // 只更新數字類型的輸入框（保留使用者手動設定的非數字值）
            const nextParsedNum = parseInt(nextInputValue, 10);
            if (
              !isNaN(nextParsedNum) &&
              nextInputValue !== "" &&
              nextInputValue !== "-" &&
              nextInputValue.toLowerCase() !== "skip"
            ) {
              nextInput.value = nextValue;
              nextValue++;
            } else {
              // 遇到非數字或跳過標記，停止自動順號
              break;
            }
          }
        }
      }

      // [新增] 套用使用者配置
      function applyGridConfig() {
        // 收集使用者輸入
        userGridConfig = {
          x: gridData.x.map((grid, index) => {
            const inputValue = document
              .getElementById(`x-grid-${index}`)
              .value.trim();
            // [修改] 支援空值、"-" 或 "skip" 來跳過該格線
            if (
              inputValue === "" ||
              inputValue === "-" ||
              inputValue.toLowerCase() === "skip"
            ) {
              return {
                name: grid.name,
                serialValue: null, // null 表示跳過，不會被用於編號
                lineType: grid.lineType,
              };
            }
            return {
              name: grid.name,
              serialValue: isNaN(inputValue)
                ? inputValue
                : parseInt(inputValue, 10),
              lineType: grid.lineType,
            };
          }),
          y: gridData.y.map((grid, index) => {
            const inputValue = document
              .getElementById(`y-grid-${index}`)
              .value.trim();
            // [修改] 支援空值、"-" 或 "skip" 來跳過該格線
            if (
              inputValue === "" ||
              inputValue === "-" ||
              inputValue.toLowerCase() === "skip"
            ) {
              return {
                name: grid.name,
                serialValue: null, // null 表示跳過，不會被用於編號
                lineType: grid.lineType,
              };
            }
            return {
              name: grid.name,
              serialValue: isNaN(inputValue)
                ? inputValue
                : parseInt(inputValue, 10),
              lineType: grid.lineType,
            };
          }),
        };

        // [新增] 儲存格線配置到 localStorage
        try {
          localStorage.setItem('userGridConfig', JSON.stringify(userGridConfig));
          console.log('✓ 已儲存格線編號規則');
        } catch (e) {
          console.error('儲存格線編號規則失敗:', e);
        }

        document.getElementById("grid-config-panel").style.display = "none";

        // 自動執行編號
        processE2k();
      }

      // [新增] 取消配置
      function cancelGridConfig() {
        document.getElementById("grid-config-panel").style.display = "none";
      }

      // [新增] Grid Bubble 顯示控制相關函數
      let gridSystemVisibility = {}; // 儲存各 COORDSYSTEM 的顯示狀態
      let currentGridData = null; // 儲存當前的 grid 資料供拖曳使用

      // 切換說明對話框的顯示
      function toggleHelpDialog() {
        const helpBox = document.getElementById("help-info-box");
        if (helpBox.style.display === "none") {
          helpBox.style.display = "block";
        } else {
          helpBox.style.display = "none";
        }
      }

      // 開啟 Grid Bubble 控制 Modal
      function toggleGridBubbleControlPanel() {
        openGridBubbleModal();
      }

      function openGridBubbleModal() {
        const panel = document.getElementById("grid-bubble-control-panel");
        const overlay = document.getElementById("grid-bubble-overlay");
        // 初始化控制面板（如果還沒有初始化）
        initializeGridBubbleControls();
        panel.style.display = "block";
        overlay.style.display = "block";
        // 防止背景滾動
        document.body.style.overflow = "hidden";
      }

      function closeGridBubbleModal() {
        const panel = document.getElementById("grid-bubble-control-panel");
        const overlay = document.getElementById("grid-bubble-overlay");
        panel.style.display = "none";
        overlay.style.display = "none";
        // 恢復背景滾動
        document.body.style.overflow = "";
      }

      // 初始化 Grid Bubble 控制開關
      function initializeGridBubbleControls() {
        if (!gridData || !gridData.coordSystems) {
          console.log("No grid data available");
          return;
        }

        const togglesContainer = document.getElementById("grid-system-toggles");
        togglesContainer.innerHTML = ""; // 清空現有內容

        // 獲取所有 COORDSYSTEM
        const coordSystems = Object.keys(gridData.coordSystems);

        if (coordSystems.length === 0) {
          togglesContainer.innerHTML = '<p style="color: var(--theme-text-secondary);">沒有可用的 Grid Line 系統</p>';
          return;
        }

        // 顏色配置（與繪圖時使用的相同）
        const COORDSYSTEM_COLORS = {
          'GLOBAL': '#4A90E2',
          'O2': '#E24A4A',
          'A2': '#50C878',
          'A3': '#F39C12',
          'DEFAULT': '#9B59B6'
        };

        // 為每個 COORDSYSTEM 創建開關
        coordSystems.forEach(systemName => {
          // 初始化為顯示狀態
          if (gridSystemVisibility[systemName] === undefined) {
            gridSystemVisibility[systemName] = true;
          }

          const color = COORDSYSTEM_COLORS[systemName] || COORDSYSTEM_COLORS['DEFAULT'];
          const isVisible = gridSystemVisibility[systemName];

          const toggleDiv = document.createElement('div');
          toggleDiv.className = 'grid-system-toggle';
          toggleDiv.innerHTML = `
            <label for="toggle-${systemName}">
              <span class="grid-system-color-indicator" style="background-color: ${color};"></span>
              <span>${systemName}</span>
            </label>
            <div class="toggle-switch ${isVisible ? 'active' : ''}" onclick="toggleGridSystem('${systemName}')">
              <input type="checkbox" id="toggle-${systemName}" ${isVisible ? 'checked' : ''}>
              <div class="toggle-switch-slider"></div>
            </div>
          `;
          togglesContainer.appendChild(toggleDiv);
        });

        // [新增] 對稱軸線開關
        const symmetryToggleDiv = document.createElement('div');
        symmetryToggleDiv.className = 'grid-system-toggle';
        symmetryToggleDiv.innerHTML = `
          <label for="toggle-symmetry-axis">
            <span class="grid-system-color-indicator" style="background-color: #5D4037;"></span>
            <span>對稱軸</span>
          </label>
          <div class="toggle-switch ${showSymmetryAxisLine ? 'active' : ''}" onclick="toggleSymmetryAxisLine()">
            <input type="checkbox" id="toggle-symmetry-axis" ${showSymmetryAxisLine ? 'checked' : ''}>
            <div class="toggle-switch-slider"></div>
          </div>
        `;
        togglesContainer.appendChild(symmetryToggleDiv);
      }

      // 切換特定 Grid System 的顯示狀態
      function toggleGridSystem(systemName) {
        // 切換狀態
        gridSystemVisibility[systemName] = !gridSystemVisibility[systemName];
        const isVisible = gridSystemVisibility[systemName];

        // 更新 UI 開關狀態
        const checkbox = document.getElementById(`toggle-${systemName}`);
        const toggleSwitch = checkbox.parentElement;
        checkbox.checked = isVisible;
        if (isVisible) {
          toggleSwitch.classList.add('active');
        } else {
          toggleSwitch.classList.remove('active');
        }

        // 更新 SVG 中的元素顯示狀態
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // 找出所有該 COORDSYSTEM 的 bubble, text, connector, grid line
        const bubbles = svg.querySelectorAll(`.grid-bubble[data-coordsystem="${systemName}"]`);
        const texts = svg.querySelectorAll(`.grid-bubble-text[data-coordsystem="${systemName}"]`);
        const connectors = svg.querySelectorAll(`.grid-bubble-connector[data-coordsystem="${systemName}"]`);
        const gridLines = svg.querySelectorAll(`.grid-line-element[data-coordsystem="${systemName}"]`);

        // 切換 hidden class
        [bubbles, texts, connectors, gridLines].forEach(elements => {
          elements.forEach(el => {
            if (isVisible) {
              el.classList.remove('hidden');
            } else {
              el.classList.add('hidden');
            }
          });
        });

        console.log(`${systemName} system ${isVisible ? 'shown' : 'hidden'}`);
      }

      // [新增] 套用已儲存的 Grid System 顯示狀態（重繪後呼叫）
      function applyGridSystemVisibility() {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        Object.keys(gridSystemVisibility).forEach(systemName => {
          const isVisible = gridSystemVisibility[systemName];
          if (isVisible) return; // 預設是顯示的，只需處理隱藏的

          // 隱藏該系統的所有元素
          const bubbles = svg.querySelectorAll(`.grid-bubble[data-coordsystem="${systemName}"]`);
          const texts = svg.querySelectorAll(`.grid-bubble-text[data-coordsystem="${systemName}"]`);
          const connectors = svg.querySelectorAll(`.grid-bubble-connector[data-coordsystem="${systemName}"]`);
          const gridLines = svg.querySelectorAll(`.grid-line-element[data-coordsystem="${systemName}"]`);

          [bubbles, texts, connectors, gridLines].forEach(elements => {
            elements.forEach(el => el.classList.add('hidden'));
          });
        });
      }

      // [新增] Grid Bubble 拖曳功能
      let dragState = {
        isDragging: false,
        currentBubble: null,
        currentText: null,
        currentConnector: null,
        originalBubblePos: null,  // 記錄原始位置
        gridLineEnd: null,
        gridLineDirection: null,  // [新增] grid line 方向向量
        startMousePos: null,
        maxDragDistance: null     // [新增] 最大拖曳距離 (±5 bubble)
      };

      // 初始化拖曳事件監聽器（在繪製完成後呼叫）
      function initializeBubbleDragging() {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // [修改] 先移除舊的全域事件監聽器，避免重複綁定
        // 綁定到 document 而不是 svg，確保即使鼠標移出 SVG 範圍也能繼續拖曳
        document.removeEventListener("mousemove", handleBubbleMouseMove);
        document.removeEventListener("mouseup", handleBubbleMouseUp);

        // [修改] 移除個別 hitarea 的事件監聽器，改用 SVG 統一處理
        // 這樣可以在 mousedown 時找到最接近鼠標的 bubble，避免重疊 bubble 誤判
        svg.removeEventListener("mousedown", handleBubbleMouseDown);
        svg.addEventListener("mousedown", handleBubbleMouseDown);

        // 全域 mousemove 和 mouseup 事件綁定到 document
        document.addEventListener("mousemove", handleBubbleMouseMove);
        document.addEventListener("mouseup", handleBubbleMouseUp);

        const hitareas = svg.querySelectorAll(".grid-bubble-hitarea.draggable");
        console.log("[DEBUG] Bubble dragging initialized successfully, hitareas:", hitareas.length);
      }

      function handleBubbleMouseDown(e) {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // [修改] 先獲取鼠標在 SVG 座標系中的位置
        const pt = getSVGPoint(svg, e);
        if (!pt) {
          // SVG 尚未完全渲染，讓事件正常傳播
          return;
        }
        const mouseX = pt.x;
        const mouseY = pt.y;

        // [修改] 找到所有 hitareas，並計算與鼠標的距離，選擇最近的那個
        const hitareas = svg.querySelectorAll(".grid-bubble-hitarea.draggable");
        let closestHitarea = null;
        let minDistance = Infinity;

        // [修改] 設定合理的最大點擊距離（SVG 座標單位）
        // 使用 hitarea 的實際半徑（INITIAL_GRID_BUBBLE_RADIUS + 5 = 23）
        // 這樣只有在點擊位置確實在 bubble 範圍內才會觸發拖動
        const MAX_CLICK_DISTANCE = INITIAL_GRID_BUBBLE_RADIUS + 5;

        hitareas.forEach(ha => {
          const cx = parseFloat(ha.getAttribute("cx"));
          const cy = parseFloat(ha.getAttribute("cy"));
          const dist = Math.sqrt((mouseX - cx) ** 2 + (mouseY - cy) ** 2);

          // [修改] 只要距離是最近的，就選擇它（不再限制必須在 r 範圍內）
          if (dist < minDistance) {
            closestHitarea = ha;
            minDistance = dist;
          }
        });

        // [修改] 如果最近的 bubble 距離太遠（超過閾值），說明沒有點擊在 bubble 上
        if (!closestHitarea || minDistance > MAX_CLICK_DISTANCE) {
          return;  // 讓其他事件（如圈選）處理
        }

        // 防止與圈選功能衝突
        e.stopPropagation();
        e.preventDefault();

        const hitarea = closestHitarea;
        const coordsystem = hitarea.getAttribute("data-coordsystem");

        // 找到對應的 bubble、text 和 connector
        const hitareaCx = parseFloat(hitarea.getAttribute("cx"));
        const hitareaCy = parseFloat(hitarea.getAttribute("cy"));

        console.log("[DEBUG] Closest hitarea selected:", {
          coordsystem,
          mousePos: { x: mouseX, y: mouseY },
          hitareaPos: { cx: hitareaCx, cy: hitareaCy },
          distance: minDistance,
          maxAllowed: MAX_CLICK_DISTANCE
        });

        const bubbles = svg.querySelectorAll(`.grid-bubble[data-coordsystem="${coordsystem}"]`);  // [新增] 查找真正的 bubble
        const texts = svg.querySelectorAll(`.grid-bubble-text[data-coordsystem="${coordsystem}"]`);
        const connectors = svg.querySelectorAll(`.grid-bubble-connector[data-coordsystem="${coordsystem}"]`);

        console.log("[DEBUG] Hitarea mousedown:", {
          coordsystem,
          hitareaCx,
          hitareaCy,
          bubblesCount: bubbles.length,
          textsCount: texts.length,
          connectorsCount: connectors.length
        });

        // [新增] 找到位置相同的真正 bubble 圓圈
        let matchingBubble = null;
        let minBubbleDist = Infinity;
        bubbles.forEach(bubble => {
          const bx = parseFloat(bubble.getAttribute("cx"));
          const by = parseFloat(bubble.getAttribute("cy"));
          const dist = Math.sqrt((bx - hitareaCx) ** 2 + (by - hitareaCy) ** 2);
          if (dist < 10 && dist < minBubbleDist) {
            matchingBubble = bubble;
            minBubbleDist = dist;
          }
        });

        // 找到位置相同的 text（放寬匹配條件到 10 像素）
        let matchingText = null;
        let minTextDist = Infinity;
        texts.forEach(text => {
          const tx = parseFloat(text.getAttribute("x"));
          const ty = parseFloat(text.getAttribute("y"));
          const dist = Math.sqrt((tx - hitareaCx) ** 2 + (ty - hitareaCy) ** 2);
          if (dist < 10 && dist < minTextDist) {
            matchingText = text;
            minTextDist = dist;
          }
        });

        // 找到連接到這個 bubble 的 connector（放寬匹配條件到 10 像素）
        let matchingConnector = null;
        let minConnDist = Infinity;
        connectors.forEach(conn => {
          const x1 = parseFloat(conn.getAttribute("x1"));
          const y1 = parseFloat(conn.getAttribute("y1"));
          const dist = Math.sqrt((x1 - hitareaCx) ** 2 + (y1 - hitareaCy) ** 2);
          console.log("[DEBUG] Checking connector:", { x1, y1, dist });
          if (dist < 10 && dist < minConnDist) {
            matchingConnector = conn;
            minConnDist = dist;
          }
        });

        // [新增] 檢查是否找到所有必要元素
        if (!matchingBubble) {
          console.warn("[WARN] No matching bubble found at", hitareaCx, hitareaCy);
          return;
        }
        if (!matchingConnector) {
          console.warn("[WARN] No matching connector found for bubble at", hitareaCx, hitareaCy);
          return;
        }

        console.log("[DEBUG] Found all elements:", {
          bubble: matchingBubble,
          text: matchingText,
          connector: {
            x1: matchingConnector.getAttribute("x1"),
            y1: matchingConnector.getAttribute("y1"),
            x2: matchingConnector.getAttribute("x2"),
            y2: matchingConnector.getAttribute("y2")
          }
        });

        // 儲存拖曳狀態 - [修改] 使用真正的 bubble 元素
        dragState.isDragging = true;
        dragState.currentBubble = matchingBubble;  // [修改] 保存真正的 bubble 而不是 hitarea
        dragState.currentText = matchingText;
        dragState.currentConnector = matchingConnector;

        // 記錄原始位置（用於回彈）- [修改] 使用 hitarea 的座標
        dragState.originalBubblePos = {
          x: hitareaCx,
          y: hitareaCy
        };

        // 獲取 grid line 的固定端點（connector 的另一端）
        dragState.gridLineEnd = {
          x: parseFloat(matchingConnector.getAttribute("x2")),
          y: parseFloat(matchingConnector.getAttribute("y2"))
        };

        // [修正] BUBBLE 應該沿著 connector 的方向移動（垂直於 grid line）
        // 計算從 bubble 指向 grid line 的方向向量 - [修改] 使用 hitarea 座標
        const connectorDx = dragState.gridLineEnd.x - hitareaCx;
        const connectorDy = dragState.gridLineEnd.y - hitareaCy;
        const connectorLength = Math.sqrt(connectorDx * connectorDx + connectorDy * connectorDy);

        // connector 的單位向量
        let connectorUnitX = 0;
        let connectorUnitY = 0;

        if (connectorLength > 0.01) {
          connectorUnitX = connectorDx / connectorLength;
          connectorUnitY = connectorDy / connectorLength;

          // [修正] 直接使用 connector 的方向（不需要旋轉）
          // BUBBLE 沿著垂直於 grid line 的方向移動
          dragState.gridLineDirection = {
            x: connectorUnitX,
            y: connectorUnitY
          };
        } else {
          dragState.gridLineDirection = { x: 0, y: 1 }; // 預設垂直方向
        }

        console.log("[DEBUG] Grid line direction:", dragState.gridLineDirection, "Connector unit:", {x: connectorUnitX, y: connectorUnitY});

        // [修正] 設定統一的最大拖曳距離，確保所有 BUBBLE 有相同的移動感受
        // 使用固定距離而非基於 bubble 半徑，避免不同 BUBBLE 有不同的速度感
        dragState.maxDragDistance = 100;  // 固定 100 單位的拖曳範圍

        // 獲取 SVG 座標系中的滑鼠位置（使用之前已經獲取的 pt）
        // 注意：pt 已在函數開頭聲明（line 1894），這裡直接使用
        dragState.startMousePos = pt;

        // [新增] 禁用 svg-pan-zoom 的平移功能，避免拖動時整個畫布跟著移動
        if (panZoomInstance) {
          panZoomInstance.disablePan();
        }

        // 添加樣式防止文字選取 - [修改] 使用真正的 bubble 元素
        matchingBubble.classList.add("dragging");
        matchingConnector.classList.add("rubber-band");
        document.body.classList.add("dragging-bubble");

        console.log("[SUCCESS] Started dragging bubble", coordsystem, "maxDistance:", dragState.maxDragDistance, "isDragging:", dragState.isDragging);
      }

      // [優化] 用於 Bubble 拖拽的 requestAnimationFrame 節流
      let bubbleAnimationFrameId = null;
      let pendingBubbleEvent = null;

      function handleBubbleMouseMove(e) {
        if (!dragState.isDragging) {
          // console.log("[DEBUG] MouseMove but not dragging");
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        // [優化] 使用 requestAnimationFrame 節流
        pendingBubbleEvent = e;
        if (!bubbleAnimationFrameId) {
          bubbleAnimationFrameId = requestAnimationFrame(updateBubblePosition);
        }
      }

      // [優化] 獨立的 Bubble 位置更新函數
      function updateBubblePosition() {
        bubbleAnimationFrameId = null;
        if (!dragState.isDragging || !pendingBubbleEvent) return;

        const e = pendingBubbleEvent;
        const svg = document.getElementById("drawing-svg");
        const pt = getSVGPoint(svg, e);
        if (!pt) {
          pendingBubbleEvent = null;
          return;
        }

        // [修正] 計算鼠標相對於初始點擊位置的移動量（而不是相對於 BUBBLE 原始位置）
        const mouseDx = pt.x - dragState.startMousePos.x;
        const mouseDy = pt.y - dragState.startMousePos.y;

        // 投影到 connector 方向（點積）
        const projectionLength = mouseDx * dragState.gridLineDirection.x +
                                 mouseDy * dragState.gridLineDirection.y;

        // 限制在 ±maxDragDistance 範圍內
        const clampedLength = Math.max(-dragState.maxDragDistance,
                                       Math.min(dragState.maxDragDistance, projectionLength));

        // 計算新的 bubble 位置（從原始位置沿 connector 方向偏移）
        const newCx = dragState.originalBubblePos.x + clampedLength * dragState.gridLineDirection.x;
        const newCy = dragState.originalBubblePos.y + clampedLength * dragState.gridLineDirection.y;

        // console.log("[DEBUG] Moving bubble:", { mouseDx, mouseDy, projectionLength, clampedLength, newCx, newCy });

        // 更新 bubble 位置
        dragState.currentBubble.setAttribute("cx", newCx);
        dragState.currentBubble.setAttribute("cy", newCy);

        // 更新 text 位置
        if (dragState.currentText) {
          dragState.currentText.setAttribute("x", newCx);
          dragState.currentText.setAttribute("y", newCy);
        }

        // 更新 connector (橡膠拉伸效果 - 從 bubble 拉到 grid line 端點)
        dragState.currentConnector.setAttribute("x1", newCx);
        dragState.currentConnector.setAttribute("y1", newCy);

        pendingBubbleEvent = null;
      }

      function handleBubbleMouseUp(e) {
        if (!dragState.isDragging) return;

        console.log("[DEBUG] Mouse up - checking if bubble moved");

        // [修改] 使用簡諧運動（彈簧效果）回到原始位置
        if (dragState.currentBubble && dragState.originalBubblePos) {
          const bubble = dragState.currentBubble;
          const text = dragState.currentText;
          const connector = dragState.currentConnector;
          const targetX = dragState.originalBubblePos.x;
          const targetY = dragState.originalBubblePos.y;

          // 獲取當前位置
          let currentX = parseFloat(bubble.getAttribute("cx"));
          let currentY = parseFloat(bubble.getAttribute("cy"));

          // [新增] 檢查 bubble 是否真的移動了（避免點擊時的跳動）
          const movedDistance = Math.sqrt(
            (currentX - targetX) ** 2 + (currentY - targetY) ** 2
          );

          // 如果移動距離小於 1 像素，視為沒有移動，直接重置狀態不執行動畫
          if (movedDistance < 1) {
            console.log("[DEBUG] Bubble didn't move, skipping animation");
            // 直接移除樣式
            if (dragState.currentBubble) {
              dragState.currentBubble.classList.remove("dragging");
            }
            if (dragState.currentConnector) {
              dragState.currentConnector.classList.remove("rubber-band");
            }
            document.body.classList.remove("dragging-bubble");

            // [新增] 重新啟用 svg-pan-zoom 的平移功能
            if (panZoomInstance) {
              panZoomInstance.enablePan();
            }

            // 重置拖曳狀態
            dragState.isDragging = false;
            dragState.currentBubble = null;
            dragState.currentText = null;
            dragState.currentConnector = null;
            dragState.originalBubblePos = null;
            dragState.gridLineEnd = null;
            dragState.gridLineDirection = null;
            dragState.maxDragDistance = null;
            dragState.startMousePos = null;
            return;
          }

          console.log("[DEBUG] Bubble moved, starting spring animation");

          // [優化] 簡諧運動參數 - 提高剛度和阻尼，讓回彈更快更一致
          let velocity = { x: 0, y: 0 };
          const stiffness = 0.25;      // 彈簧剛度 (提高到 0.25，回彈更快)
          const damping = 0.75;        // 阻尼係數 (提高到 0.75，減少震盪)
          const minDistance = 0.5;     // 停止閾值 (提高到 0.5，更快停止)

          // 動畫循環
          const animate = () => {
            // 計算位移
            const dx = targetX - currentX;
            const dy = targetY - currentY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // 如果已經很接近目標，停止動畫
            if (distance < minDistance && Math.abs(velocity.x) < 0.01 && Math.abs(velocity.y) < 0.01) {
              bubble.setAttribute("cx", targetX);
              bubble.setAttribute("cy", targetY);
              if (text) {
                text.setAttribute("x", targetX);
                text.setAttribute("y", targetY);
              }
              if (connector) {
                connector.setAttribute("x1", targetX);
                connector.setAttribute("y1", targetY);
              }
              return;
            }

            // 彈簧力 F = -k * x
            const forceX = dx * stiffness;
            const forceY = dy * stiffness;

            // 更新速度（加入阻尼）
            velocity.x = (velocity.x + forceX) * damping;
            velocity.y = (velocity.y + forceY) * damping;

            // 更新位置
            currentX += velocity.x;
            currentY += velocity.y;

            // 應用到元素
            bubble.setAttribute("cx", currentX);
            bubble.setAttribute("cy", currentY);
            if (text) {
              text.setAttribute("x", currentX);
              text.setAttribute("y", currentY);
            }
            if (connector) {
              connector.setAttribute("x1", currentX);
              connector.setAttribute("y1", currentY);
            }

            // 繼續動畫
            requestAnimationFrame(animate);
          };

          // 開始動畫
          animate();
        }

        // 移除樣式
        if (dragState.currentBubble) {
          dragState.currentBubble.classList.remove("dragging");
        }
        if (dragState.currentConnector) {
          dragState.currentConnector.classList.remove("rubber-band");
        }
        document.body.classList.remove("dragging-bubble");

        console.log("Stopped dragging bubble - spring animation started");

        // [新增] 重新啟用 svg-pan-zoom 的平移功能
        if (panZoomInstance) {
          panZoomInstance.enablePan();
        }

        // 重置拖曳狀態
        dragState.isDragging = false;
        dragState.currentBubble = null;
        dragState.currentText = null;
        dragState.currentConnector = null;
        dragState.originalBubblePos = null;
        dragState.gridLineEnd = null;
        dragState.gridLineDirection = null;
        dragState.maxDragDistance = null;
        dragState.startMousePos = null;
      }

      // 輔助函數：獲取 SVG 座標系中的滑鼠位置（考慮 svg-pan-zoom 的縮放和平移）
      function getSVGPoint(svg, e) {
        try {
          const pt = svg.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;

          // [修正] 使用 viewport 的 CTM，而不是 SVG 根元素的 CTM
          // svg-pan-zoom 會將所有內容包裝在一個 <g> 元素（viewport）中
          // 使用 viewport 的 CTM 才能正確處理縮放後的座標轉換
          const viewport = svg.querySelector('g');
          const ctm = viewport ? viewport.getScreenCTM() : svg.getScreenCTM();
          if (!ctm) {
            console.warn("[WARN] SVG CTM not available yet");
            return null;
          }
          const svgPt = pt.matrixTransform(ctm.inverse());
          return svgPt;
        } catch (error) {
          console.error("[ERROR] getSVGPoint failed:", error);
          return null;
        }
      }

      // ============ 梁標籤拖曳功能 ============
      // [新增] 梁標籤拖曳狀態
      let beamLabelDragState = {
        isDragging: false,
        currentLabel: null,
        beamName: null,
        orientation: null,  // 'horizontal', 'vertical', 'angled'
        originalPos: null,  // {x, y}
        customOffset: 0,    // 自訂偏移量（沿著垂直於梁的方向）
        startMousePos: null,
        maxDragDistance: 100  // 最大拖曳距離
      };

      // [新增] 儲存所有梁標籤的自訂偏移量 {beamName: offset}
      let beamLabelOffsets = {};

      // 初始化梁標籤拖曳功能
      function initializeBeamLabelDragging() {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // 移除舊的事件監聽器
        svg.removeEventListener("mousedown", handleBeamLabelMouseDown);
        document.removeEventListener("mousemove", handleBeamLabelMouseMove);
        document.removeEventListener("mouseup", handleBeamLabelMouseUp);

        // 添加新的事件監聽器
        svg.addEventListener("mousedown", handleBeamLabelMouseDown);
        document.addEventListener("mousemove", handleBeamLabelMouseMove);
        document.addEventListener("mouseup", handleBeamLabelMouseUp);

        console.log("[DEBUG] Beam label dragging initialized");
      }

      function handleBeamLabelMouseDown(e) {
        // 只處理左鍵點擊
        if (e.button !== 0) return;

        const target = e.target;

        // 檢查是否點擊了梁標籤
        if (!target.classList.contains('beam-label')) return;

        // 避免與圈選功能衝突 - 如果點擊時沒有按住 Ctrl/Shift，允許拖動
        if (!e.ctrlKey && !e.shiftKey) {
          e.stopPropagation();  // 阻止事件冒泡到圈選功能
        } else {
          return;  // 如果按住修飾鍵，讓圈選功能處理
        }

        const svg = document.getElementById("drawing-svg");
        const pt = getSVGPoint(svg, e);
        if (!pt) return;

        // 獲取標籤資訊
        const beamName = target.dataset.beamName;
        const orientation = target.dataset.orientation;

        if (!beamName || !orientation) return;

        // 記錄拖曳狀態
        beamLabelDragState.isDragging = true;
        beamLabelDragState.currentLabel = target;
        beamLabelDragState.beamName = beamName;
        beamLabelDragState.orientation = orientation;
        beamLabelDragState.startMousePos = pt;

        // 記錄原始位置
        beamLabelDragState.originalPos = {
          x: parseFloat(target.getAttribute("x")),
          y: parseFloat(target.getAttribute("y"))
        };

        // 載入之前儲存的偏移量
        beamLabelDragState.customOffset = beamLabelOffsets[beamName] || 0;

        // [新增] 禁用 svg-pan-zoom 的平移功能，避免拖動時整個畫布跟著移動
        if (panZoomInstance) {
          panZoomInstance.disablePan();
        }

        // 添加拖曳樣式
        target.style.cursor = "grabbing";
        target.style.opacity = "0.7";
        document.body.classList.add("dragging-bubble");

        console.log("[DEBUG] Started dragging beam label:", beamName, orientation);
      }

      // [優化] 用於梁標籤拖拽的 requestAnimationFrame 節流
      let beamLabelAnimationFrameId = null;
      let pendingBeamLabelEvent = null;

      function handleBeamLabelMouseMove(e) {
        if (!beamLabelDragState.isDragging) return;

        e.preventDefault();
        e.stopPropagation();

        // [優化] 使用 requestAnimationFrame 節流
        pendingBeamLabelEvent = e;
        if (!beamLabelAnimationFrameId) {
          beamLabelAnimationFrameId = requestAnimationFrame(updateBeamLabelPosition);
        }
      }

      // [優化] 獨立的梁標籤位置更新函數
      function updateBeamLabelPosition() {
        beamLabelAnimationFrameId = null;
        if (!beamLabelDragState.isDragging || !pendingBeamLabelEvent) return;

        const e = pendingBeamLabelEvent;
        const svg = document.getElementById("drawing-svg");
        const pt = getSVGPoint(svg, e);
        if (!pt) {
          pendingBeamLabelEvent = null;
          return;
        }

        const label = beamLabelDragState.currentLabel;
        const orientation = beamLabelDragState.orientation;

        // 計算鼠標移動量
        const mouseDx = pt.x - beamLabelDragState.startMousePos.x;
        const mouseDy = pt.y - beamLabelDragState.startMousePos.y;

        let projectionLength = 0;

        // 根據梁的方向，計算沿著允許方向的投影
        let moveDirectionX = 0;  // 移動方向的單位向量
        let moveDirectionY = 0;

        if (orientation === 'horizontal') {
          // 水平梁：只允許上下移動
          projectionLength = mouseDy;
          moveDirectionX = 0;
          moveDirectionY = 1;
        } else if (orientation === 'vertical') {
          // 垂直梁：只允許左右移動
          projectionLength = mouseDx;
          moveDirectionX = 1;
          moveDirectionY = 0;
        } else if (orientation === 'angled') {
          // 斜向梁：允許沿著垂直於梁的方向移動
          // 從 transform 屬性中提取旋轉角度
          const transform = label.getAttribute("transform");
          if (transform && transform.includes("rotate")) {
            const rotateMatch = transform.match(/rotate\(([^,]+)/);
            if (rotateMatch) {
              const angleInDegrees = parseFloat(rotateMatch[1]);
              const angleInRadians = (angleInDegrees * Math.PI) / 180;

              // 梁的方向向量（沿著旋轉角度）
              const beamDirX = Math.cos(angleInRadians);
              const beamDirY = Math.sin(angleInRadians);

              // 垂直於梁的方向（順時針旋轉 90 度）
              moveDirectionX = -beamDirY;
              moveDirectionY = beamDirX;

              // 將鼠標移動投影到垂直於梁的方向
              projectionLength = mouseDx * moveDirectionX + mouseDy * moveDirectionY;
            } else {
              // 如果無法解析角度，回退到垂直移動
              projectionLength = mouseDy;
              moveDirectionX = 0;
              moveDirectionY = 1;
            }
          } else {
            // 如果沒有 transform 屬性，回退到垂直移動
            projectionLength = mouseDy;
            moveDirectionX = 0;
            moveDirectionY = 1;
          }
        }

        // 限制在最大拖曳範圍內
        const clampedLength = Math.max(
          -beamLabelDragState.maxDragDistance,
          Math.min(beamLabelDragState.maxDragDistance, projectionLength)
        );

        // 更新自訂偏移量
        beamLabelDragState.customOffset = clampedLength;

        // 計算新位置（沿著移動方向）
        let newX = beamLabelDragState.originalPos.x;
        let newY = beamLabelDragState.originalPos.y;

        if (orientation === 'horizontal') {
          newY += clampedLength;
        } else if (orientation === 'vertical') {
          newX += clampedLength;
        } else if (orientation === 'angled') {
          // 沿著垂直於梁的方向移動
          newX += clampedLength * moveDirectionX;
          newY += clampedLength * moveDirectionY;
        }

        // 更新標籤位置
        label.setAttribute("x", newX);
        label.setAttribute("y", newY);

        // 如果是旋轉的標籤，也需要更新旋轉中心
        const transform = label.getAttribute("transform");
        if (transform && transform.includes("rotate")) {
          const rotateMatch = transform.match(/rotate\(([^,]+),\s*([^,]+),\s*([^)]+)\)/);
          if (rotateMatch) {
            const angle = rotateMatch[1];
            label.setAttribute("transform", `rotate(${angle}, ${newX}, ${newY})`);
          }
        }

        pendingBeamLabelEvent = null;
      }

      function handleBeamLabelMouseUp(e) {
        if (!beamLabelDragState.isDragging) return;

        console.log("[DEBUG] Mouse up - checking if label moved");

        const label = beamLabelDragState.currentLabel;
        const beamName = beamLabelDragState.beamName;
        const orientation = beamLabelDragState.orientation;

        // 獲取當前位置
        let currentX = parseFloat(label.getAttribute("x"));
        let currentY = parseFloat(label.getAttribute("y"));

        // 計算目標位置（回到原始位置，不保留拖動偏移）
        const targetX = beamLabelDragState.originalPos.x;
        const targetY = beamLabelDragState.originalPos.y;

        // 檢查標籤是否真的移動了
        const movedDistance = Math.sqrt(
          (currentX - targetX) ** 2 + (currentY - targetY) ** 2
        );

        // 如果移動距離小於 1 像素，視為沒有移動（點擊）
        if (movedDistance < 1) {
          console.log("[DEBUG] Label didn't move, treating as click - triggering selection");

          // 直接移除樣式
          if (label) {
            label.style.cursor = "move";
            label.style.opacity = "1";
          }
          document.body.classList.remove("dragging-bubble");

          // [新增] 觸發選取功能 - 沒有移動代表是點擊
          const beamStory = label.dataset.beamStory;
          const beamJoint1 = label.dataset.beamJoint1;
          const beamJoint2 = label.dataset.beamJoint2;

          if (beamName && beamStory) {
            const beamKey = `${beamStory}|${beamName}|${beamJoint1}|${beamJoint2}`;

            // Shift+Click：取消選擇
            if (e.shiftKey) {
              if (selectedBeams.has(beamKey)) {
                selectedBeams.delete(beamKey);
                updateBeamVisualState(beamKey, false);
              }
            } else {
              // 普通點擊：累加選擇
              if (!selectedBeams.has(beamKey)) {
                selectedBeams.add(beamKey);
                updateBeamVisualState(beamKey, true);
              }
            }
          }

          // [新增] 重新啟用 svg-pan-zoom 的平移功能
          if (panZoomInstance) {
            panZoomInstance.enablePan();
          }

          // 重置拖曳狀態
          beamLabelDragState.isDragging = false;
          beamLabelDragState.currentLabel = null;
          beamLabelDragState.beamName = null;
          beamLabelDragState.orientation = null;
          beamLabelDragState.originalPos = null;
          beamLabelDragState.customOffset = 0;
          beamLabelDragState.startMousePos = null;
          return;
        }

        console.log("[DEBUG] Label moved, starting spring animation");

        // 不儲存偏移量，讓標籤回到原始位置

        // 彈簧動畫參數
        let velocity = { x: 0, y: 0 };
        const stiffness = 0.25;      // 彈簧剛度
        const damping = 0.75;        // 阻尼係數
        const minDistance = 0.5;     // 停止閾值

        // 動畫循環
        const animate = () => {
          // 計算位移
          const dx = targetX - currentX;
          const dy = targetY - currentY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // 如果已經很接近目標，停止動畫
          if (distance < minDistance && Math.abs(velocity.x) < 0.01 && Math.abs(velocity.y) < 0.01) {
            label.setAttribute("x", targetX);
            label.setAttribute("y", targetY);

            // 更新旋轉中心（如果是旋轉的標籤）
            const transform = label.getAttribute("transform");
            if (transform && transform.includes("rotate")) {
              const rotateMatch = transform.match(/rotate\(([^,]+),\s*([^,]+),\s*([^)]+)\)/);
              if (rotateMatch) {
                const angle = rotateMatch[1];
                label.setAttribute("transform", `rotate(${angle}, ${targetX}, ${targetY})`);
              }
            }
            return;
          }

          // 彈簧力 F = -k * x
          const forceX = dx * stiffness;
          const forceY = dy * stiffness;

          // 更新速度（加入阻尼）
          velocity.x = (velocity.x + forceX) * damping;
          velocity.y = (velocity.y + forceY) * damping;

          // 更新位置
          currentX += velocity.x;
          currentY += velocity.y;

          // 應用到元素
          label.setAttribute("x", currentX);
          label.setAttribute("y", currentY);

          // 更新旋轉中心（如果是旋轉的標籤）
          const transform = label.getAttribute("transform");
          if (transform && transform.includes("rotate")) {
            const rotateMatch = transform.match(/rotate\(([^,]+),\s*([^,]+),\s*([^)]+)\)/);
            if (rotateMatch) {
              const angle = rotateMatch[1];
              label.setAttribute("transform", `rotate(${angle}, ${currentX}, ${currentY})`);
            }
          }

          // 繼續動畫
          requestAnimationFrame(animate);
        };

        // 開始動畫
        animate();

        // 移除拖曳樣式
        if (label) {
          label.style.cursor = "move";
          label.style.opacity = "1";
        }
        document.body.classList.remove("dragging-bubble");

        // [新增] 重新啟用 svg-pan-zoom 的平移功能
        if (panZoomInstance) {
          panZoomInstance.enablePan();
        }

        console.log("[DEBUG] Stopped dragging beam label:", beamName, "offset:", beamLabelDragState.customOffset);

        // 重置拖曳狀態
        beamLabelDragState.isDragging = false;
        beamLabelDragState.currentLabel = null;
        beamLabelDragState.beamName = null;
        beamLabelDragState.orientation = null;
        beamLabelDragState.originalPos = null;
        beamLabelDragState.customOffset = 0;
        beamLabelDragState.startMousePos = null;
      }

      // [新增] 初始化滾輪中鍵拖動畫布功能（類似 AutoCAD）
      function initializeMiddleMousePan() {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // 移除舊的事件監聽器
        svg.removeEventListener("mousedown", handleMiddleMouseDown);
        document.removeEventListener("mousemove", handleMiddleMouseMove);
        document.removeEventListener("mouseup", handleMiddleMouseUp);

        // 添加事件監聽器
        svg.addEventListener("mousedown", handleMiddleMouseDown);
        document.addEventListener("mousemove", handleMiddleMouseMove);
        document.addEventListener("mouseup", handleMiddleMouseUp);

        // 防止中鍵點擊時的自動滾動行為
        svg.addEventListener("auxclick", (e) => {
          if (e.button === 1) {
            e.preventDefault();
          }
        });

        console.log("[DEBUG] Middle mouse pan initialized");
      }

      function handleMiddleMouseDown(e) {
        // 只處理滾輪中鍵（button === 1）
        if (e.button !== 1) return;

        e.preventDefault();
        e.stopPropagation();

        isMiddleMousePanning = true;
        middleMouseStartPos = {
          x: e.clientX,
          y: e.clientY
        };

        // 獲取當前的 pan 位置
        if (panZoomInstance) {
          middleMouseStartPos.pan = panZoomInstance.getPan();
        }

        // 添加拖動游標樣式
        document.body.style.cursor = "grabbing";

        console.log("[DEBUG] Middle mouse pan started at:", middleMouseStartPos);
      }

      function handleMiddleMouseMove(e) {
        if (!isMiddleMousePanning || !panZoomInstance) return;

        e.preventDefault();

        // 計算移動距離
        const dx = e.clientX - middleMouseStartPos.x;
        const dy = e.clientY - middleMouseStartPos.y;

        // 應用新的 pan 位置
        panZoomInstance.pan({
          x: middleMouseStartPos.pan.x + dx,
          y: middleMouseStartPos.pan.y + dy
        });
      }

      function handleMiddleMouseUp(e) {
        if (!isMiddleMousePanning) return;

        // 只處理滾輪中鍵
        if (e.button !== 1) return;

        isMiddleMousePanning = false;
        middleMouseStartPos = null;

        // 恢復游標樣式
        document.body.style.cursor = "";

        console.log("[DEBUG] Middle mouse pan ended");
      }

      async function processE2k() {
        const statusDiv = document.getElementById("status");
        const mirrorModeToggle = document.getElementById("mirrorModeToggle");

        // [修改] 檢查是否已有預覽資料
        if (!previewFileContent || !previewJoints) {
          statusDiv.innerHTML = '<p class="error">請先點擊「預覽結構」按鈕</p>';
          return;
        }

        statusDiv.innerHTML = "<p>正在執行編號...</p>";
        fullProcessedBeams = [];

        try {
          // 使用預覽時已解析好的資料
          const fileContent = previewFileContent;
          const joints = previewJoints;

          let allBeamsAcrossStories = [];
          for (const story of availableStories) {
            const frames = parseFrames(fileContent, story);
            if (frames.length > 0) allBeamsAcrossStories.push(...frames);
          }
          if (allBeamsAcrossStories.length === 0)
            throw new Error("No qualifying beams found on any story.");

          fullDrawableBeams = allBeamsAcrossStories.map((f) => ({
            ...f,
            j1: joints[f.joint1],
            j2: joints[f.joint2],
          }));
          storyOrderInfo = availableStories.reduce((acc, story, index) => {
            acc[story] = index;
            return acc;
          }, {});

          const mainBeams = allBeamsAcrossStories.filter((b) => {
            const prop = b.prop.toUpperCase();
            const isNumericBeam = /^\d+(\.\d+)?B/.test(prop);
            return (
              (isNumericBeam ||
                prop.startsWith("B") ||
                prop.startsWith("G") ||
                prop.startsWith("FB") ||
                prop.startsWith("FGB")) &&
              !prop.startsWith("SB") &&
              !prop.startsWith("FSB") &&
              !prop.startsWith("WB") &&
              !prop.startsWith("FWB")
            );
          });
          const secondaryBeams = allBeamsAcrossStories.filter(
            (b) =>
              b.prop.toUpperCase().startsWith("SB") &&
              !b.prop.toUpperCase().startsWith("FSB"),
          );
          const secondaryFoundationBeams = allBeamsAcrossStories.filter((b) =>
            b.prop.toUpperCase().startsWith("FSB"),
          );
          const specialBeams = allBeamsAcrossStories.filter(
            (b) =>
              b.prop.toUpperCase().startsWith("WB") ||
              b.prop.toUpperCase().startsWith("FWB"),
          ).map(b => ({
            ...b,
            newLabel: "", // 不顯示編號
            isSpecialBeam: true, // 標記為特殊梁（WB/FWB）
          }));

          let allLabeledBeams = [...specialBeams];

          // [新增] 處理固定編號的梁
          const fixedLabelBeams = [];
          const reservedSerials = new Set(); // 記錄被固定編號佔用的序號（格式: "前綴:序號"，如 "g:1", "b:1"）

          if (document.getElementById("fixedLabelToggle").checked && fixedLabelRules.length > 0) {
            console.log("\n========== 處理固定編號梁 ==========");

            for (const story of availableStories) {
              // [修改] 包含所有梁類型（大梁和小梁都可以設定固定編號）
              const allBeamsInStory = allBeamsAcrossStories.filter((b) => b.story === story);

              allBeamsInStory.forEach(beam => {
                const beamSection = beam.prop.toLowerCase();
                const matchedRule = fixedLabelRules.find(rule =>
                  beamSection.includes(rule.section) || beamSection === rule.section
                );

                if (matchedRule) {
                  const j1 = joints[beam.joint1];
                  const j2 = joints[beam.joint2];

                  if (j1 && j2) {
                    // [修改] 直接使用完整的固定編號（如 "g1", "b1"）
                    const newLabel = matchedRule.label;

                    // [修復] 根據 frame section (beam.prop) 判斷是大梁還是小梁
                    // 小梁：包含 SB 或 FSB 的斷面（支援 4sb、3.5sb 等格式）
                    // 大梁：其他所有斷面
                    const isSecondaryBeam = beam.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(beam.prop);

                    fixedLabelBeams.push({
                      ...beam,
                      newLabel,
                      isFixedLabel: true,
                      isSecondaryBeam // [新增] 標記是否為小梁（根據 section 判斷）
                    });

                    // [修改] 從完整編號中提取前綴和序號部分（如 "g1" → "g:1", "b2" → "b:2", "ga1" → "g:1"）
                    // 大梁前綴統一為 "g"（含 G, GA, GB, GC 等），小梁前綴統一為 "b"
                    const labelLower = matchedRule.label.toLowerCase();
                    const serialMatch = labelLower.match(/\d+$/);
                    if (serialMatch) {
                      // 判斷是大梁還是小梁的前綴
                      const prefixType = labelLower.startsWith('g') ? 'g' : 'b';
                      reservedSerials.add(`${prefixType}:${serialMatch[0]}`);
                    }

                    const beamType = isSecondaryBeam ? '小梁' : '大梁';
                    console.log(`[${story}] ${beam.name} (${beam.prop}) → ${newLabel} [${beamType}]`);
                  }
                }
              });
            }

            allLabeledBeams.push(...fixedLabelBeams);
            console.log(`✓ 共處理 ${fixedLabelBeams.length} 根固定編號梁`);
            console.log(`✓ 預留序號 (格式: 前綴:序號): ${Array.from(reservedSerials).join(', ')}`);
            console.log("==========================================\n");
          }

          // [新增] 鏡像模式：使用智能偵測計算全域對稱軸
          let globalSymmetryAxisX = null;

          // [修正] 優先使用用戶自訂的對稱軸值，其次使用預先偵測的值
          // 移除方向限制，讓自訂值無論方向都能被應用
          if (mirrorModeToggle.checked) {
            if (userSymmetryAxisValue !== null && userSymmetryAxisValue !== undefined) {
              globalSymmetryAxisX = userSymmetryAxisValue;
              console.log(`\n[對稱軸] 使用自訂值 X = ${globalSymmetryAxisX.toFixed(3)}`);
            } else if (detectedSymmetryAxis?.value !== null && detectedSymmetryAxis?.value !== undefined) {
              globalSymmetryAxisX = detectedSymmetryAxis.value;
              console.log(`\n[對稱軸] 使用自動偵測值 X = ${globalSymmetryAxisX.toFixed(3)}`);
            }
          }

          // 如果沒有預設值，才執行即時偵測
          if (globalSymmetryAxisX === null && mirrorModeToggle.checked && secondaryBeams.length > 0) {
            console.log("\n========== 智能偵測全域對稱軸 ==========");
            const axisXCandidates = [];

            // 對每個樓層使用智能偵測
            for (const story of availableStories) {
              const secondaryBeamsInStory = secondaryBeams.filter((b) => b.story === story);
              const mainBeamsInStory = mainBeams.filter((b) => b.story === story);
              const allBeamsInStory = [...secondaryBeamsInStory, ...mainBeamsInStory];

              if (allBeamsInStory.length < 10) continue;

              console.log(`\n[${story}] 智能偵測對稱軸...`);
              const detectedAxis = detectSymmetryAxis(allBeamsInStory, joints, gridData);

              if (detectedAxis) {
                axisXCandidates.push({ story, axisX: detectedAxis });
                console.log(`[${story}] ✓ 偵測成功`);
              } else {
                console.log(`[${story}] ✗ 未偵測到對稱結構`);
              }
            }

            // 找出最常出現的對稱軸（容許 ±0.5m 誤差）
            if (axisXCandidates.length > 0) {
              const AXIS_TOLERANCE = 0.5;
              const groups = [];

              axisXCandidates.forEach((candidate) => {
                let foundGroup = false;
                for (const group of groups) {
                  if (Math.abs(group[0].axisX - candidate.axisX) < AXIS_TOLERANCE) {
                    group.push(candidate);
                    foundGroup = true;
                    break;
                  }
                }
                if (!foundGroup) {
                  groups.push([candidate]);
                }
              });

              // 選擇出現次數最多的群組
              groups.sort((a, b) => b.length - a.length);
              const bestGroup = groups[0];
              globalSymmetryAxisX = bestGroup.reduce((sum, c) => sum + c.axisX, 0) / bestGroup.length;

              console.log(`\n[全域對稱軸] X = ${globalSymmetryAxisX.toFixed(3)} (來自 ${bestGroup.length} 個樓層)`);
              bestGroup.forEach((c) => console.log(`  - ${c.story}`));
            } else {
              console.log("\n[警告] 所有樓層都未偵測到對稱結構");
            }
            console.log("==========================================\n");
          }

          for (const story of availableStories) {
            const mainBeamsInStory = mainBeams.filter((b) => b.story === story);
            const secondaryBeamsInStory = secondaryBeams.filter(
              (b) => b.story === story,
            );
            const secondaryFoundationBeamsInStory =
              secondaryFoundationBeams.filter((b) => b.story === story);

            if (mainBeamsInStory.length > 0) {
              // [修改] 排除已經被固定編號的梁
              const beamsToNumber = mainBeamsInStory.filter(beam => {
                const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
                return !fixedLabelBeams.some(fb =>
                  `${fb.name}|${fb.joint1}|${fb.joint2}` === beamKey
                );
              });

              const labelComponentMap = generateLabelsForStory(
                beamsToNumber,
                joints,
                gridData,
                reservedSerials, // [新增] 傳入預留的序號
              );

              // [修复] 处理所有大梁，包括没有被成功编号的梁
              beamsToNumber.forEach((originalBeam) => {
                const beamKey = `${originalBeam.name}|${originalBeam.joint1}|${originalBeam.joint2}`;
                const components = labelComponentMap.get(beamKey);

                let newLabel = "未編號"; // 默认标签

                if (components) {
                  // 如果成功编号
                  if (components.isDiagonal) {
                    // [修改] 斜向大梁的編號格式：與水平/垂直梁相同
                    const propUpper = originalBeam.prop.toUpperCase();
                    // 斜向梁的前綴：根據方向判斷
                    // isAlongX=true（沿X軸）→ 使用G（水平梁前綴）
                    // isAlongX=false（沿Y軸）→ 使用B（垂直梁前綴）
                    let prefix;
                    if (components.isAlongX) {
                      prefix = propUpper.startsWith("FB") ? "FG" : "G";
                    } else {
                      prefix = propUpper.startsWith("FB") ? "FB" : "B";
                    }

                    const finalPrefix = `${prefix}${components.primaryGridName}${components.subGridMarker}`;
                    newLabel = `${finalPrefix}-${components.serial}`;
                  } else {
                    // 原有的水平/垂直梁編號邏輯
                    const propUpper = originalBeam.prop.toUpperCase();
                    const prefix = components.isVertical
                      ? propUpper.startsWith("FB")
                        ? "FB"
                        : "B"
                      : propUpper.startsWith("FB")
                        ? "FG"
                        : "G";

                    const finalPrefix = `${prefix}${components.primaryGridName}${components.subGridMarker}`;
                    newLabel = `${finalPrefix}-${components.serial}`;
                  }
                }

                allLabeledBeams.push({
                  ...originalBeam,
                  newLabel,
                  isSecondaryBeam: false, // 大梁標記
                });
              });
            }

            if (secondaryBeamsInStory.length > 0) {
              // [新增] 排除已經被固定編號的小梁
              const secondaryBeamsToNumber = secondaryBeamsInStory.filter(beam => {
                const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
                return !fixedLabelBeams.some(fb =>
                  `${fb.name}|${fb.joint1}|${fb.joint2}` === beamKey
                );
              });

              const secondaryBeamLabels = generateSecondaryBeamLabels(
                secondaryBeamsToNumber,
                mainBeamsInStory,
                joints,
                "b",
                globalSymmetryAxisX,
                reservedSerials, // [新增] 傳入預留的序號
                gridData, // [新增] 傳入格線資料以支援座標系統判斷
              );

              // [修复] 处理所有小梁，包括没有被成功编号的梁
              secondaryBeamsToNumber.forEach((originalBeam) => {
                const beamKey = `${originalBeam.name}|${originalBeam.joint1}|${originalBeam.joint2}`;
                const labelInfo = secondaryBeamLabels.get(beamKey);
                const newLabel = labelInfo ? labelInfo.newLabel : "b未編號";

                allLabeledBeams.push({
                  ...originalBeam,
                  newLabel,
                  isSecondaryBeam: true, // 小梁標記
                });
              });
            }

            if (secondaryFoundationBeamsInStory.length > 0) {
              // [新增] 排除已經被固定編號的基礎小梁
              const foundationBeamsToNumber = secondaryFoundationBeamsInStory.filter(beam => {
                const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
                return !fixedLabelBeams.some(fb =>
                  `${fb.name}|${fb.joint1}|${fb.joint2}` === beamKey
                );
              });

              const foundationBeamLabels = generateSecondaryBeamLabels(
                foundationBeamsToNumber,
                mainBeamsInStory,
                joints,
                "fb",
                globalSymmetryAxisX,
                reservedSerials, // [新增] 傳入預留的序號
                gridData, // [新增] 傳入格線資料以支援座標系統判斷
              );

              // [修复] 处理所有基础小梁，包括没有被成功编号的梁
              foundationBeamsToNumber.forEach((originalBeam) => {
                const beamKey = `${originalBeam.name}|${originalBeam.joint1}|${originalBeam.joint2}`;
                const labelInfo = foundationBeamLabels.get(beamKey);
                const newLabel = labelInfo ? labelInfo.newLabel : "fb未編號";

                allLabeledBeams.push({
                  ...originalBeam,
                  newLabel,
                  isSecondaryBeam: true, // 基礎小梁標記
                });
              });
            }
          }

          let finalProcessedData = applySpecialPrefixRules(allLabeledBeams);
          // [修改] 允許特殊梁（WB/FWB）通過過濾，即使沒有編號
          finalProcessedData = finalProcessedData.filter(
            (beam) => beam.newLabel || beam.isSpecialBeam,
          );

          finalProcessedData.sort((a, b) => {
            const storyCompare =
              storyOrderInfo[a.story] - storyOrderInfo[b.story];
            if (storyCompare !== 0) return storyCompare;

            // [修复] 使用 isSecondaryBeam 标记而不是基于编号的第一个字母
            const aIsSecondary = a.isSecondaryBeam || false;
            const bIsSecondary = b.isSecondaryBeam || false;

            if (aIsSecondary && !bIsSecondary) return 1;
            if (!aIsSecondary && bIsSecondary) return -1;

            return (a.newLabel || "").localeCompare(b.newLabel || "", "en", {
              numeric: true,
            });
          });

          fullProcessedBeams = finalProcessedData;

          // [新增] 清除標準層群組快取，讓下次編輯時重新計算
          invalidateStandardFloorGroupsCache();

          if (availableStories.includes("2F")) {
            storySelector.value = "2F";
          }
          handleStoryChange();

          // [修改] 顯示狀態訊息到控制列的內嵌區域
          showInlineStatus(`✅ 編號完成！共處理 ${fullProcessedBeams.length} 根梁`, 'success');
          if (fullProcessedBeams.length > 0) {
            exportBtn.disabled = false;
            exportJsonBtn.disabled = false;
          }
        } catch (error) {
          statusDiv.innerHTML = `<p class="error">Processing failed: ${error.message}</p>`;
          console.error(error);
        }
      }

      function populateStorySelector() {
        const selector = document.getElementById("storySelector");
        const fullscreenSelector = document.getElementById("fullscreen-story-selector");

        // 填充主選擇器
        selector.innerHTML = '<option value="all">All Floors</option>';
        availableStories.forEach((story) => {
          const option = document.createElement("option");
          option.value = story;
          option.textContent = story;
          selector.appendChild(option);
        });

        // 填充全螢幕選擇器
        fullscreenSelector.innerHTML = '<option value="all">All Floors</option>';
        availableStories.forEach((story) => {
          const option = document.createElement("option");
          option.value = story;
          option.textContent = story;
          fullscreenSelector.appendChild(option);
        });

        selector.disabled = false;
        document.getElementById("beamTypeSelector").disabled = false;
        // 【在最後一行後面加上】
        document.getElementById("mirrorModeToggle").disabled = false;
      }

      function handleStoryChange() {
        const storySelector = document.getElementById("storySelector");
        const beamTypeSelector = document.getElementById("beamTypeSelector");
        const selectedStory = storySelector.value;
        const selectedBeamType = beamTypeSelector.value;
        const svg = document.getElementById("drawing-svg");

        const storyDisplayName = selectedStory === "all" ? "All Floors Combined" : selectedStory;
        document.getElementById("plan-story-name").textContent = storyDisplayName;
        document.getElementById("fullscreen-story-name").textContent = storyDisplayName;
        // [新增] 更新全螢幕模式的浮動樓層 Bubble
        document.getElementById("fullscreen-floor-text").textContent = storyDisplayName;

        // 同步全螢幕選擇器
        document.getElementById("fullscreen-story-selector").value = selectedStory;

        let beamsToDisplay = fullProcessedBeams;
        let backgroundBeams = fullDrawableBeams;

        if (selectedStory !== "all") {
          beamsToDisplay = beamsToDisplay.filter(
            (b) => b.story === selectedStory,
          );
          backgroundBeams = backgroundBeams.filter(
            (b) => b.story === selectedStory,
          );
        }

        if (selectedBeamType === "main") {
          beamsToDisplay = beamsToDisplay.filter((b) => {
            if (!b.newLabel) return false;
            // [修复] 统一使用 isSecondaryBeam 标记来判断大梁/小梁
            // 大梁：isSecondaryBeam === false
            return !b.isSecondaryBeam;
          });
          backgroundBeams = backgroundBeams.filter(
            (b) => b.prop && !/SB/.test(b.prop.toUpperCase()),
          );
        } else if (selectedBeamType === "secondary") {
          beamsToDisplay = beamsToDisplay.filter((b) => {
            if (!b.newLabel) return false;
            // [修复] 统一使用 isSecondaryBeam 标记来判断大梁/小梁
            // 小梁：isSecondaryBeam === true
            return b.isSecondaryBeam;
          });
          backgroundBeams = backgroundBeams.filter(
            (b) => b.prop && /SB/.test(b.prop.toUpperCase()),
          );
        }

        // [優化] 保存當前的視圖狀態（使用相對座標，確保跨尺寸一致性）
        let savedViewState = null;
        if (panZoomInstance) {
          const sizes = panZoomInstance.getSizes();
          const pan = panZoomInstance.getPan();
          const zoom = panZoomInstance.getZoom();

          // 計算視圖中心點在 viewBox 中的相對位置（0-1 範圍）
          // 這樣在不同容器尺寸下都能保持相同的視覺位置
          const viewCenterX = (sizes.width / 2 - pan.x) / (sizes.viewBox.width * zoom);
          const viewCenterY = (sizes.height / 2 - pan.y) / (sizes.viewBox.height * zoom);

          savedViewState = {
            zoom: zoom,
            centerX: viewCenterX,
            centerY: viewCenterY
          };

          try {
            panZoomInstance.destroy();
          } catch (e) {
            console.warn("[WARN] Failed to destroy panZoomInstance:", e);
          }
          panZoomInstance = null;
        }

        // [修改] 預覽模式：如果沒有編號資料，直接顯示所有梁（當作背景梁但用藍色顯示）
        const isPreviewMode =
          fullProcessedBeams.length === 0 && backgroundBeams.length > 0;

        const labeledBeamsWithCoords = beamsToDisplay.map((beam) => {
          const originalBeam = fullDrawableBeams.find(
            (b) =>
              b.name === beam.name &&
              b.story === beam.story &&
              b.joint1 === beam.joint1 &&
              b.joint2 === beam.joint2,
          );
          return { ...beam, j1: originalBeam?.j1, j2: originalBeam?.j2 };
        });

        displayResults(
          labeledBeamsWithCoords,
          backgroundBeams,
          svg,
          gridData,
          isPreviewMode,
        );

        // [新增] 套用已儲存的 Grid System 顯示狀態
        applyGridSystemVisibility();

        // [新增] 自動偵測對稱軸並繪製
        if (typeof autoDetectSymmetryAxis === 'function') {
          autoDetectSymmetryAxis();
        }
        if (typeof drawSymmetryAxisLine === 'function') {
          drawSymmetryAxisLine();
        }

        if (beamsToDisplay.length > 0 || gridData.x.length > 0) {
          // [優化] 只在首次創建時自動縮放，否則恢復之前的狀態
          const shouldFitAndCenter = (savedViewState === null);

          // [修改] 移除 onZoom 回調中的字體動態調整
          // 改為使用 CSS 固定字體大小，縮放時字體會自然跟著縮放
          panZoomInstance = svgPanZoom("#drawing-svg", {
            panEnabled: false,  // [修改] 禁用滑鼠拖動平移，只允許滾輪縮放
            zoomEnabled: true,
            dblClickZoomEnabled: true,
            mouseWheelZoomEnabled: true,  // [新增] 明確啟用滾輪縮放
            controlIconsEnabled: true,
            fit: shouldFitAndCenter,
            center: shouldFitAndCenter,
            minZoom: 0.1,
            maxZoom: 50,
          });

          // [優化] 恢復之前保存的視圖狀態（使用相對座標計算新的 pan 值）
          if (!shouldFitAndCenter && savedViewState !== null) {
            // 使用 requestAnimationFrame 確保 DOM 已更新
            requestAnimationFrame(() => {
              const sizes = panZoomInstance.getSizes();
              const zoom = savedViewState.zoom;

              // 從相對座標計算新的 pan 值
              const newPanX = sizes.width / 2 - savedViewState.centerX * sizes.viewBox.width * zoom;
              const newPanY = sizes.height / 2 - savedViewState.centerY * sizes.viewBox.height * zoom;

              panZoomInstance.zoom(zoom);
              panZoomInstance.pan({ x: newPanX, y: newPanY });
            });
          }
        }
      }

      // ============ 全螢幕功能 ============

      function toggleFullscreen() {
        const drawingDiv = document.getElementById("drawing");
        const fullscreenIcon = document.getElementById("fullscreen-icon-top");
        const floorBubble = document.getElementById("fullscreen-floor-bubble");
        const htmlElement = document.documentElement;
        const bodyElement = document.body;

        console.log("=== toggleFullscreen 開始 ===");
        console.log("當前全螢幕狀態:", drawingDiv.classList.contains("fullscreen"));

        if (drawingDiv.classList.contains("fullscreen")) {
          console.log("→ 離開全螢幕模式");

          // 離開全螢幕
          drawingDiv.classList.remove("fullscreen");
          if (fullscreenIcon) fullscreenIcon.textContent = "⛶";

          // [新增] 隱藏樓層 Bubble
          floorBubble.classList.remove("visible");

          // 恢復 html 和 body 的樣式
          htmlElement.style.padding = "";
          htmlElement.style.margin = "";
          htmlElement.style.overflow = "";
          htmlElement.style.background = "";
          bodyElement.style.padding = "";
          bodyElement.style.margin = "";
          bodyElement.style.overflow = "";
          bodyElement.style.background = "";

          // [優化] 重新調整 SVG，使用相對座標保持視覺位置一致
          if (panZoomInstance) {
            // 保存當前視圖狀態（使用相對座標）
            const sizes = panZoomInstance.getSizes();
            const pan = panZoomInstance.getPan();
            const zoom = panZoomInstance.getZoom();
            const viewCenterX = (sizes.width / 2 - pan.x) / (sizes.viewBox.width * zoom);
            const viewCenterY = (sizes.height / 2 - pan.y) / (sizes.viewBox.height * zoom);

            setTimeout(() => {
              console.log("→ 離開全螢幕：調整 SVG（保持位置）");
              panZoomInstance.resize();
              panZoomInstance.updateBBox();

              // 使用相對座標計算新的 pan 值
              requestAnimationFrame(() => {
                const newSizes = panZoomInstance.getSizes();
                const newPanX = newSizes.width / 2 - viewCenterX * newSizes.viewBox.width * zoom;
                const newPanY = newSizes.height / 2 - viewCenterY * newSizes.viewBox.height * zoom;
                panZoomInstance.zoom(zoom);
                panZoomInstance.pan({ x: newPanX, y: newPanY });
              });
            }, 100);
          }
        } else {
          console.log("→ 進入全螢幕模式");

          // [新增] 顯示樓層 Bubble
          floorBubble.classList.add("visible");

          // 進入全螢幕
          drawingDiv.classList.add("fullscreen");
          if (fullscreenIcon) fullscreenIcon.textContent = "✕";

          // 強制移除 html 和 body 的 padding/margin，並設定白色背景
          htmlElement.style.padding = "0";
          htmlElement.style.margin = "0";
          htmlElement.style.overflow = "hidden";
          htmlElement.style.background = "#ffffff";
          bodyElement.style.padding = "0";
          bodyElement.style.margin = "0";
          bodyElement.style.overflow = "hidden";
          bodyElement.style.background = "#ffffff";

          console.log("→ 設置 html/body 樣式完成");
          console.log("  html padding:", htmlElement.style.padding);
          console.log("  body padding:", bodyElement.style.padding);

          // 檢查 SVG 元素
          const svgElement = document.getElementById("drawing-svg");
          if (svgElement) {
            console.log("→ SVG 元素資訊:");
            console.log("  SVG clientWidth:", svgElement.clientWidth);
            console.log("  SVG clientHeight:", svgElement.clientHeight);
            console.log("  Window innerWidth:", window.innerWidth);
            console.log("  Window innerHeight:", window.innerHeight);
            console.log("  SVG viewBox:", svgElement.getAttribute("viewBox"));
          }

          // [優化] 進入全螢幕時，使用相對座標保持視覺位置一致
          if (panZoomInstance) {
            console.log("→ 開始調整 panZoomInstance...");

            // 保存當前視圖狀態（使用相對座標）
            const sizes = panZoomInstance.getSizes();
            const pan = panZoomInstance.getPan();
            const zoom = panZoomInstance.getZoom();
            const viewCenterX = (sizes.width / 2 - pan.x) / (sizes.viewBox.width * zoom);
            const viewCenterY = (sizes.height / 2 - pan.y) / (sizes.viewBox.height * zoom);

            // 使用 setTimeout 確保 DOM 更新完成
            setTimeout(() => {
              // 更新 SVG 尺寸
              panZoomInstance.resize();
              panZoomInstance.updateBBox();

              // 使用相對座標計算新的 pan 值
              requestAnimationFrame(() => {
                const newSizes = panZoomInstance.getSizes();
                const newPanX = newSizes.width / 2 - viewCenterX * newSizes.viewBox.width * zoom;
                const newPanY = newSizes.height / 2 - viewCenterY * newSizes.viewBox.height * zoom;
                panZoomInstance.zoom(zoom);
                panZoomInstance.pan({ x: newPanX, y: newPanY });

                console.log("  zoom:", zoom);
                console.log("  viewCenter:", { x: viewCenterX, y: viewCenterY });
                console.log("=== toggleFullscreen 完成（保持位置）===");
              });
            }, 150);
          } else {
            console.warn("⚠️ panZoomInstance 不存在！");
          }
        }
      }

      function handleFullscreenStoryChange() {
        const fullscreenSelector = document.getElementById("fullscreen-story-selector");
        const mainSelector = document.getElementById("storySelector");

        // 同步到主選擇器
        mainSelector.value = fullscreenSelector.value;

        // 觸發主選擇器的變更事件
        handleStoryChange();
      }

      function previousFloor() {
        const selector = document.getElementById("storySelector");
        const currentIndex = selector.selectedIndex;

        if (currentIndex > 0) {
          selector.selectedIndex = currentIndex - 1;
          handleStoryChange();
        }
      }

      function nextFloor() {
        const selector = document.getElementById("storySelector");
        const currentIndex = selector.selectedIndex;

        if (currentIndex < selector.options.length - 1) {
          selector.selectedIndex = currentIndex + 1;
          handleStoryChange();
        }
      }

      // ============ 鍵盤快捷鍵 ============

      // 使用捕獲階段和 stopImmediatePropagation，確保最優先處理
      document.addEventListener("keydown", function (event) {
        const drawingDiv = document.getElementById("drawing");
        const isFullscreen = drawingDiv && drawingDiv.classList.contains("fullscreen");

        // Ctrl+F - 最高優先級，立即攔截
        if ((event.ctrlKey || event.metaKey) && (event.key === 'f' || event.key === 'F' || event.keyCode === 70)) {
          event.preventDefault();
          event.stopImmediatePropagation();
          openSearchMemberDialog();
          return false;
        }

        // 上下鍵 - 在非輸入框時攔截
        const activeElement = document.activeElement;
        const isInputFocused = activeElement && (
          activeElement.tagName === "INPUT" ||
          activeElement.tagName === "TEXTAREA" ||
          activeElement.tagName === "SELECT"
        );

        if (!isInputFocused && (event.key === "ArrowUp" || event.key === "ArrowDown" || event.keyCode === 38 || event.keyCode === 40)) {
          event.preventDefault();
          event.stopImmediatePropagation();

          if (event.key === "ArrowUp" || event.keyCode === 38) {
            previousFloor();
          } else if (event.key === "ArrowDown" || event.keyCode === 40) {
            nextFloor();
          }
          return false;
        }

        // ESC 鍵處理 - 先取消選取，再退出全螢幕
        if (event.key === "Escape" || event.keyCode === 27) {
          event.preventDefault();
          event.stopImmediatePropagation();

          // 優先取消選取
          if (selectedBeams && selectedBeams.size > 0) {
            clearAllSelections();
            updateBatchEditPanel(); // 更新批量編輯面板
            return false;
          }

          // 沒有選取時，退出全螢幕
          if (isFullscreen) {
            toggleFullscreen();
            return false;
          }
        }

      }, true); // 使用捕獲階段

      // ============================================

      function summarizeFloors(floors, storyOrder) {
        if (!floors || floors.length === 0) return "";
        if (floors.length === 1) return floors[0];

        const sortedFloors = [...floors].sort(
          (a, b) => storyOrder[a] - storyOrder[b],
        );
        const ranges = [];
        let rangeStart = sortedFloors[0];

        for (let i = 1; i < sortedFloors.length; i++) {
          const currentStoryOrder = storyOrder[sortedFloors[i]];
          const prevStoryOrder = storyOrder[sortedFloors[i - 1]];

          if (currentStoryOrder !== prevStoryOrder + 1) {
            if (rangeStart === sortedFloors[i - 1]) {
              ranges.push(rangeStart);
            } else {
              ranges.push(`${rangeStart}~${sortedFloors[i - 1]}`);
            }
            rangeStart = sortedFloors[i];
          }
        }

        if (rangeStart === sortedFloors[sortedFloors.length - 1]) {
          ranges.push(rangeStart);
        } else {
          ranges.push(`${rangeStart}~${sortedFloors[sortedFloors.length - 1]}`);
        }
        return ranges.join(", ");
      }

      function summarizeProperties(floorProps, storyOrder) {
        if (!floorProps || floorProps.length === 0) return "";

        const propsToFloorsMap = new Map();
        for (const { story, prop } of floorProps) {
          if (!propsToFloorsMap.has(prop)) {
            propsToFloorsMap.set(prop, []);
          }
          propsToFloorsMap.get(prop).push(story);
        }

        const summaryParts = [];
        propsToFloorsMap.forEach((floors, prop) => {
          const floorRange = summarizeFloors(floors, storyOrder);
          summaryParts.push(`${floorRange}: ${prop}`);
        });

        summaryParts.sort((a, b) => {
          const firstStoryA = a.split(":")[0].trim().split("~")[0];
          const firstStoryB = b.split(":")[0].trim().split("~")[0];
          return storyOrder[firstStoryA] - storyOrder[firstStoryB];
        });

        return summaryParts.join("; ");
      }

      function displayResults(
        labeledBeams,
        allBeams,
        svg,
        grids,
        isPreviewMode = false,
      ) {
        const beamCoords = allBeams
          .flatMap((b) => [b.j1, b.j2])
          .filter(Boolean);
        if (beamCoords.length === 0 && (!grids || grids.x.length === 0)) {
          svg.innerHTML =
            '<text x="50%" y="50%" text-anchor="middle" fill="var(--theme-text-secondary)">No data to display</text>';
          return;
        }

        // [修改] 使用全局座標系統（基於所有樓層的梁），確保切換樓層時座標系統不變
        // 這樣切換樓層後，畫面位置（zoom 和 pan）可以保持一致
        const globalBeamCoords = fullDrawableBeams
          .flatMap((b) => [b.j1, b.j2])
          .filter(Boolean);
        const gridCoordsX = grids.x ? grids.x.map((g) => g.ordinate) : [];
        const gridCoordsY = grids.y ? grids.y.map((g) => g.ordinate) : [];

        // 使用全局梁座標來計算邊界（如果沒有全局數據，fallback 到當前樓層）
        const coordsForBounds = globalBeamCoords.length > 0 ? globalBeamCoords : beamCoords;
        const globalX = coordsForBounds.map((p) => p.x).concat(gridCoordsX);
        const globalY = coordsForBounds.map((p) => p.y).concat(gridCoordsY);
        const minX = Math.min(...globalX);
        const maxX = Math.max(...globalX);
        const minY = Math.min(...globalY);
        const maxY = Math.max(...globalY);

        const padding = 60;
        const svgWidth = svg.clientWidth || 1000;
        const svgHeight = svg.clientHeight || 800;
        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;

        let scale =
          Math.min(
            (svgWidth - 2 * padding) / (contentWidth || 1),
            (svgHeight - 2 * padding) / (contentHeight || 1),
          ) * 0.9;
        if (!isFinite(scale) || scale === 0) scale = 1;

        // [修正] 計算偏移量，使結構自動置中於畫布
        const scaledContentWidth = contentWidth * scale;
        const scaledContentHeight = contentHeight * scale;
        const offsetX = (svgWidth - scaledContentWidth) / 2;
        const offsetY = (svgHeight - scaledContentHeight) / 2;

        const transformX = (x) => offsetX + (x - minX) * scale;
        const transformY = (y) => svgHeight - offsetY - (y - minY) * scale;

        // [新增] 儲存轉換參數供對稱軸點選功能使用
        savedTransformParams = { scale, offsetX, offsetY, minX, minY, svgHeight };

        // [優化] 使用 requestAnimationFrame 批量更新，減少重繪和閃爍
        // 先隱藏 SVG 內容，更新完成後再顯示
        svg.style.opacity = '0';

        // 清空內容
        svg.innerHTML = "";

        // 設定 viewBox 以支援 svg-pan-zoom 的 fit() 和 center() 功能
        // viewBox 定義 SVG 的座標系統，讓 svg-pan-zoom 能正確計算內容邊界
        svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);

        const allDrawableBeams = allBeams.filter((b) => b.j1 && b.j2);
        allDrawableBeams.forEach((beam) => {
          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line",
          );
          line.setAttribute("x1", transformX(beam.j1.x));
          line.setAttribute("y1", transformY(beam.j1.y));
          line.setAttribute("x2", transformX(beam.j2.x));
          line.setAttribute("y2", transformY(beam.j2.y));

          // 判斷是否為小梁（包含 SB 或 FSB 的斷面，支援 4sb、3.5sb 等格式）
          const isSecondaryBeam = beam.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(beam.prop);

          // 根據梁類型設定顏色類別
          if (isPreviewMode) {
            // 預覽模式：大梁用藍色，小梁用橘色
            line.setAttribute(
              "class",
              isSecondaryBeam ? "secondary-beam-line" : "labeled-beam-line",
            );
          } else {
            // 背景梁：統一灰色
            line.setAttribute("class", "beam-line");
          }
          svg.appendChild(line);
        });

        if (grids && grids.x && grids.y) {
          // [重構] 按 COORDSYSTEM 分組繪製 Grid Lines，並應用位置和旋轉變換
          const gridGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
          gridGroup.setAttribute("class", "grid-lines");

          // 輔助函數：將局部座標轉換為全局座標（應用旋轉和平移）
          const localToGlobal = (localX, localY, coordSystem) => {
            const angleRad = coordSystem.angle * Math.PI / 180;
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);

            // 旋轉 + 平移
            const globalX = coordSystem.ux + localX * cosA - localY * sinA;
            const globalY = coordSystem.uy + localX * sinA + localY * cosA;

            return { globalX, globalY };
          };

          // 繪製 X 軸 Grid Lines (垂直線)
          grids.x.forEach((gridLine) => {
            const coordSystemName = gridLine.coordsystem || 'GLOBAL';
            const coordSystem = grids.coordSystems[coordSystemName] || { ux: 0, uy: 0, angle: 0 };

            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");

            // ordinate 是在局部座標系中 X 軸的值
            // 垂直線的兩個端點在局部座標系中是 (ordinate, minY) 和 (ordinate, maxY)
            const p1 = localToGlobal(gridLine.ordinate, minY, coordSystem);
            const p2 = localToGlobal(gridLine.ordinate, maxY, coordSystem);

            line.setAttribute("x1", transformX(p1.globalX));
            line.setAttribute("y1", transformY(p1.globalY));
            line.setAttribute("x2", transformX(p2.globalX));
            line.setAttribute("y2", transformY(p2.globalY));
            line.setAttribute("data-coordsystem", coordSystemName);
            line.classList.add("grid-line-element");

            gridGroup.appendChild(line);
          });

          // 繪製 Y 軸 Grid Lines (水平線)
          grids.y.forEach((gridLine) => {
            const coordSystemName = gridLine.coordsystem || 'GLOBAL';
            const coordSystem = grids.coordSystems[coordSystemName] || { ux: 0, uy: 0, angle: 0 };

            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");

            // ordinate 是在局部座標系中 Y 軸的值
            // 水平線的兩個端點在局部座標系中是 (minX, ordinate) 和 (maxX, ordinate)
            const p1 = localToGlobal(minX, gridLine.ordinate, coordSystem);
            const p2 = localToGlobal(maxX, gridLine.ordinate, coordSystem);

            line.setAttribute("x1", transformX(p1.globalX));
            line.setAttribute("y1", transformY(p1.globalY));
            line.setAttribute("x2", transformX(p2.globalX));
            line.setAttribute("y2", transformY(p2.globalY));
            line.setAttribute("data-coordsystem", coordSystemName);
            line.classList.add("grid-line-element");

            gridGroup.appendChild(line);
          });

          svg.appendChild(gridGroup);

          // [新增] Grid Line 系統顏色配置和偏移設定
          const COORDSYSTEM_COLORS = {
            'GLOBAL': '#4A90E2',  // 藍色 - GLOBAL 系統
            'O2': '#E24A4A',      // 紅色
            'A2': '#50C878',      // 綠色
            'A3': '#F39C12',      // 橙色
            'DEFAULT': '#9B59B6'  // 紫色 - 其他系統
          };

          // [新增] 計算 COORDSYSTEM 的偏移距離（GLOBAL 最近，其他系統依序遞增）
          const getCoordSystemOffset = (coordsystem) => {
            const basePadding = padding / 2;
            const systemOrder = ['GLOBAL', 'O2', 'A2', 'A3'];
            const index = systemOrder.indexOf(coordsystem);

            if (index === -1) {
              // 未知系統，使用最大偏移
              return basePadding + (systemOrder.length * 30);
            }

            // GLOBAL: basePadding
            // O2: basePadding + 30
            // A2: basePadding + 60
            // A3: basePadding + 90
            return basePadding + (index * 30);
          };

          // [新增] 獲取 COORDSYSTEM 的顏色
          const getCoordSystemColor = (coordsystem) => {
            return COORDSYSTEM_COLORS[coordsystem] || COORDSYSTEM_COLORS['DEFAULT'];
          };

          // ... 之後繪製網格氣泡 (grid bubble) 的程式碼維持不變 ...
          const gridLabelsGroup = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g",
          );

          grids.x.forEach((gridLine) => {
            const loc = gridLine.bubbleLoc;
            const coordsystem = gridLine.coordsystem || 'GLOBAL';
            const coordSystem = grids.coordSystems[coordsystem] || { ux: 0, uy: 0, angle: 0 };
            const offset = getCoordSystemOffset(coordsystem);
            const color = getCoordSystemColor(coordsystem);

            // [重構] 計算旋轉後的 grid line 端點位置
            const p1 = localToGlobal(gridLine.ordinate, minY, coordSystem); // bottom
            const p2 = localToGlobal(gridLine.ordinate, maxY, coordSystem); // top

            // 計算垂直於 grid line 的偏移方向（在旋轉座標系中，X軸格線是垂直的，偏移應該沿局部Y方向）
            const angleRad = coordSystem.angle * Math.PI / 180;
            const offsetDx = -offset * Math.sin(angleRad); // 沿局部Y軸正方向的X分量
            const offsetDy = offset * Math.cos(angleRad);  // 沿局部Y軸正方向的Y分量

            const cx_top = transformX(p2.globalX) + offsetDx;
            const cy_top = transformY(p2.globalY) - offsetDy;
            const cx_bottom = transformX(p1.globalX) - offsetDx;
            const cy_bottom = transformY(p1.globalY) + offsetDy;

            // [修改] 根據 BUBBLELOC 決定顯示位置
            // X軸(垂直線): DEFAULT=上側(top), SWITCHED=下側(bottom)
            const showTop = !loc || loc.toUpperCase() === "DEFAULT";
            const showBottom = loc && (loc.toUpperCase() === "SWITCHED" || loc.toUpperCase() === "BOTH");

            if (showTop) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const topConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line",
              );
              topConnector.setAttribute("x1", cx_top);
              topConnector.setAttribute("y1", cy_top);
              topConnector.setAttribute("x2", transformX(p2.globalX));
              topConnector.setAttribute("y2", transformY(p2.globalY));
              topConnector.setAttribute("class", "grid-bubble-connector");
              topConnector.setAttribute("stroke", color);
              topConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(topConnector);

              // [新增] 創建不可見的擴大點擊區域
              const topHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              topHitArea.setAttribute("cx", cx_top);
              topHitArea.setAttribute("cy", cy_top);
              topHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 5);  // [修改] 輕微擴大半徑提供更好的點擊體驗
              topHitArea.setAttribute("class", "grid-bubble-hitarea draggable");
              topHitArea.setAttribute("data-coordsystem", coordsystem);
              topHitArea.setAttribute("fill", "rgba(255,255,255,0.01)");  // [修改] 使用實際透明色讓 fill 區域接收點擊
              topHitArea.setAttribute("stroke", "none");  // [修改] 不需要 stroke

              const topBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              topBubble.setAttribute("cx", cx_top);
              topBubble.setAttribute("cy", cy_top);
              topBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              topBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              topBubble.setAttribute("stroke", color);
              topBubble.setAttribute("data-coordsystem", coordsystem);
              topBubble.setAttribute("pointer-events", "none");  // [新增] 讓實際的 bubble 不接收點擊事件，由 hitarea 處理

              const topText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text",
              );
              topText.setAttribute("x", cx_top);
              topText.setAttribute("y", cy_top);
              topText.setAttribute("class", "grid-bubble-text");
              topText.setAttribute("data-coordsystem", coordsystem); // [新增]
              topText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(topBubble);
              gridLabelsGroup.appendChild(topText);
              gridLabelsGroup.appendChild(topHitArea);  // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }

            if (showBottom) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const bottomConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line",
              );
              bottomConnector.setAttribute("x1", cx_bottom);
              bottomConnector.setAttribute("y1", cy_bottom);
              bottomConnector.setAttribute("x2", transformX(p1.globalX));
              bottomConnector.setAttribute("y2", transformY(p1.globalY));
              bottomConnector.setAttribute("class", "grid-bubble-connector");
              bottomConnector.setAttribute("stroke", color);
              bottomConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(bottomConnector);

              // [新增] 創建不可見的擴大點擊區域
              const bottomHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              bottomHitArea.setAttribute("cx", cx_bottom);
              bottomHitArea.setAttribute("cy", cy_bottom);
              bottomHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 5);  // [修改] 輕微擴大半徑提供更好的點擊體驗
              bottomHitArea.setAttribute("class", "grid-bubble-hitarea draggable");
              bottomHitArea.setAttribute("data-coordsystem", coordsystem);
              bottomHitArea.setAttribute("fill", "rgba(255,255,255,0.01)");  // [修改] 使用實際透明色讓 fill 區域接收點擊
              bottomHitArea.setAttribute("stroke", "none");  // [修改] 不需要 stroke

              const bottomBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              bottomBubble.setAttribute("cx", cx_bottom);
              bottomBubble.setAttribute("cy", cy_bottom);
              bottomBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              bottomBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              bottomBubble.setAttribute("stroke", color);
              bottomBubble.setAttribute("data-coordsystem", coordsystem);
              bottomBubble.setAttribute("pointer-events", "none");

              const bottomText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text",
              );
              bottomText.setAttribute("x", cx_bottom);
              bottomText.setAttribute("y", cy_bottom);
              bottomText.setAttribute("class", "grid-bubble-text");
              bottomText.setAttribute("data-coordsystem", coordsystem); // [新增]
              bottomText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(bottomBubble);
              gridLabelsGroup.appendChild(bottomText);
              gridLabelsGroup.appendChild(bottomHitArea);  // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }
          });

          grids.y.forEach((gridLine) => {
            const loc = gridLine.bubbleLoc;
            const coordsystem = gridLine.coordsystem || 'GLOBAL';
            const coordSystem = grids.coordSystems[coordsystem] || { ux: 0, uy: 0, angle: 0 };
            const offset = getCoordSystemOffset(coordsystem);
            const color = getCoordSystemColor(coordsystem);

            // [重構] 計算旋轉後的 grid line 端點位置
            const p1 = localToGlobal(minX, gridLine.ordinate, coordSystem); // left
            const p2 = localToGlobal(maxX, gridLine.ordinate, coordSystem); // right

            // 計算垂直於 grid line 的偏移方向（在旋轉座標系中，Y軸格線是水平的，偏移應該沿局部X方向）
            const angleRad = coordSystem.angle * Math.PI / 180;
            const offsetDx = -offset * Math.cos(angleRad); // 沿局部X軸負方向的X分量
            const offsetDy = -offset * Math.sin(angleRad); // 沿局部X軸負方向的Y分量

            const cx_left = transformX(p1.globalX) + offsetDx;
            const cy_left = transformY(p1.globalY) - offsetDy;
            const cx_right = transformX(p2.globalX) - offsetDx;
            const cy_right = transformY(p2.globalY) + offsetDy;

            // [修改] 根據 BUBBLELOC 決定顯示位置
            // Y軸(水平線): DEFAULT=左側(left), SWITCHED=右側(right)
            const showLeft = !loc || loc.toUpperCase() === "DEFAULT";
            const showRight = loc && (loc.toUpperCase() === "SWITCHED" || loc.toUpperCase() === "BOTH");

            if (showLeft) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const leftConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line",
              );
              leftConnector.setAttribute("x1", cx_left);
              leftConnector.setAttribute("y1", cy_left);
              leftConnector.setAttribute("x2", transformX(p1.globalX));
              leftConnector.setAttribute("y2", transformY(p1.globalY));
              leftConnector.setAttribute("class", "grid-bubble-connector");
              leftConnector.setAttribute("stroke", color);
              leftConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(leftConnector);

              // [新增] 創建不可見的擴大點擊區域
              const leftHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              leftHitArea.setAttribute("cx", cx_left);
              leftHitArea.setAttribute("cy", cy_left);
              leftHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 5);  // [修改] 輕微擴大半徑提供更好的點擊體驗
              leftHitArea.setAttribute("class", "grid-bubble-hitarea draggable");
              leftHitArea.setAttribute("data-coordsystem", coordsystem);
              leftHitArea.setAttribute("fill", "rgba(255,255,255,0.01)");  // [修改] 使用實際透明色讓 fill 區域接收點擊
              leftHitArea.setAttribute("stroke", "none");  // [修改] 不需要 stroke

              const leftBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              leftBubble.setAttribute("cx", cx_left);
              leftBubble.setAttribute("cy", cy_left);
              leftBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              leftBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              leftBubble.setAttribute("stroke", color);
              leftBubble.setAttribute("data-coordsystem", coordsystem);
              leftBubble.setAttribute("pointer-events", "none");

              const leftText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text",
              );
              leftText.setAttribute("x", cx_left);
              leftText.setAttribute("y", cy_left);
              leftText.setAttribute("class", "grid-bubble-text");
              leftText.setAttribute("data-coordsystem", coordsystem); // [新增]
              leftText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(leftBubble);
              gridLabelsGroup.appendChild(leftText);
              gridLabelsGroup.appendChild(leftHitArea);  // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }

            if (showRight) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const rightConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line",
              );
              rightConnector.setAttribute("x1", cx_right);
              rightConnector.setAttribute("y1", cy_right);
              rightConnector.setAttribute("x2", transformX(p2.globalX));
              rightConnector.setAttribute("y2", transformY(p2.globalY));
              rightConnector.setAttribute("class", "grid-bubble-connector");
              rightConnector.setAttribute("stroke", color);
              rightConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(rightConnector);

              // [新增] 創建不可見的擴大點擊區域
              const rightHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              rightHitArea.setAttribute("cx", cx_right);
              rightHitArea.setAttribute("cy", cy_right);
              rightHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 5);  // [修改] 輕微擴大半徑提供更好的點擊體驗
              rightHitArea.setAttribute("class", "grid-bubble-hitarea draggable");
              rightHitArea.setAttribute("data-coordsystem", coordsystem);
              rightHitArea.setAttribute("fill", "rgba(255,255,255,0.01)");  // [修改] 使用實際透明色讓 fill 區域接收點擊
              rightHitArea.setAttribute("stroke", "none");  // [修改] 不需要 stroke

              const rightBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              rightBubble.setAttribute("cx", cx_right);
              rightBubble.setAttribute("cy", cy_right);
              rightBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              rightBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              rightBubble.setAttribute("stroke", color);
              rightBubble.setAttribute("data-coordsystem", coordsystem);
              rightBubble.setAttribute("pointer-events", "none");

              const rightText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text",
              );
              rightText.setAttribute("x", cx_right);
              rightText.setAttribute("y", cy_right);
              rightText.setAttribute("class", "grid-bubble-text");
              rightText.setAttribute("data-coordsystem", coordsystem); // [新增]
              rightText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(rightBubble);
              gridLabelsGroup.appendChild(rightText);
              gridLabelsGroup.appendChild(rightHitArea);  // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }
          });
          svg.appendChild(gridLabelsGroup);

          // [新增] 初始化 Grid Bubble 拖曳功能
          initializeBubbleDragging();

          // [新增] 初始化梁標籤拖曳功能
          initializeBeamLabelDragging();

          // [新增] 初始化滾輪中鍵拖動畫布功能
          initializeMiddleMousePan();
        }
        // ... 之後繪製梁 (beam) 和標籤 (label) 的程式碼維持不變 ...
        const labeledDrawableBeams = labeledBeams.filter((b) => b.j1 && b.j2);
        labeledDrawableBeams.forEach((beam) => {
          // [新增] 建立唯一的梁識別 key（用於跨樓層選取）
          const beamKey = `${beam.story}|${beam.name}|${beam.joint1}|${beam.joint2}`;

          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line",
          );
          line.setAttribute("x1", transformX(beam.j1.x));
          line.setAttribute("y1", transformY(beam.j1.y));
          line.setAttribute("x2", transformX(beam.j2.x));
          line.setAttribute("y2", transformY(beam.j2.y));

          // [修改] 判斷梁的類別，WB/FWB 使用黑色
          let className = "labeled-beam-line";  // 預設：大梁藍色
          const isWallBeam = beam.isSpecialBeam ||
            beam.prop.toUpperCase().startsWith("WB") ||
            beam.prop.toUpperCase().startsWith("FWB");

          // [修復] 使用 frame section (beam.prop) 判斷是否為小梁，而不是 newLabel
          // 小梁：包含 SB 或 FSB 的斷面（支援 SB35X65、4sb、3.5sb 等格式）
          const isSecondaryBeam = beam.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(beam.prop);

          if (isWallBeam) {
            className = "wall-beam-line"; // WB/FWB 梁用黑色
          } else if (isSecondaryBeam) {
            className = "secondary-beam-line"; // 小梁用橘色
          }

          line.setAttribute("class", className);
          // [新增] 儲存梁資料到 data 屬性，用於點擊編輯和圈选
          line.dataset.beamName = beam.name;
          line.dataset.beamStory = beam.story;
          line.dataset.beamJoint1 = beam.joint1;
          line.dataset.beamJoint2 = beam.joint2;
          line.dataset.beamLabel = beam.newLabel || "";

          // [新增] 恢復選取狀態（支援跨樓層選取）
          if (selectedBeams.has(beamKey)) {
            line.classList.add('beam-selected');
          }

          // [修改] WB/FWB 梁不可點擊，不可編輯
          if (!isWallBeam) {
            line.style.cursor = "pointer";
          }

          // [新增] 右鍵顯示編號功能（保留給 WB/FWB 梁）
          line.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            e.stopPropagation();
            showBeamInfo(e, beam);
          });

          svg.appendChild(line);

          // [修改] WB/FWB 梁不顯示編號標籤
          if (isWallBeam) {
            return; // 跳過標籤繪製
          }

          const text = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text",
          );

          const textX = (transformX(beam.j1.x) + transformX(beam.j2.x)) / 2;
          const textY = (transformY(beam.j1.y) + transformY(beam.j2.y)) / 2;

          text.dataset.baseX = textX;
          text.dataset.baseY = textY;

          // [新增] 根據當前字體大小動態計算偏移距離
          const dynamicOffset = calculateOffset(currentFontSize);

          const isHorizontal = Math.abs(beam.j1.y - beam.j2.y) < TOLERANCE;
          const isVertical = Math.abs(beam.j1.x - beam.j2.x) < TOLERANCE;

          if (isHorizontal) {
            text.dataset.orientation = "horizontal";
            text.setAttribute("x", textX);
            text.setAttribute("y", textY + dynamicOffset);
            text.setAttribute("text-anchor", "middle"); // 水平置中
            text.setAttribute("dominant-baseline", "hanging"); // 文字頂部對齊，編號中線的頂點固定
          } else if (isVertical) {
            text.dataset.orientation = "vertical";
            const rotatedX = textX + dynamicOffset;
            text.setAttribute("x", rotatedX);
            text.setAttribute("y", textY);
            text.setAttribute("text-anchor", "middle"); // 保持中線對齊
            text.setAttribute("dominant-baseline", "hanging"); // 旋轉後從梁向外延伸
            text.setAttribute(
              "transform",
              `rotate(-90, ${rotatedX}, ${textY})`,
            );
          } else {
            text.dataset.orientation = "angled";
            const x1_svg = transformX(beam.j1.x);
            const y1_svg = transformY(beam.j1.y);
            const x2_svg = transformX(beam.j2.x);
            const y2_svg = transformY(beam.j2.y);
            let angle =
              (Math.atan2(y2_svg - y1_svg, x2_svg - x1_svg) * 180) / Math.PI;

            if (angle > 90 || angle < -90) {
              angle += 180;
            }

            text.setAttribute("x", textX);
            text.setAttribute("y", textY - dynamicOffset); // 使用動態偏移
            text.setAttribute("text-anchor", "middle"); // 水平置中
            text.setAttribute("dominant-baseline", "alphabetic"); // 基線對齊
            text.setAttribute(
              "transform",
              `rotate(${angle}, ${textX}, ${textY - dynamicOffset})`, // 旋轉中心調整
            );
          }

          text.setAttribute("class", "beam-label");
          text.setAttribute("font-size", currentFontSize); // [新增] 使用當前字體大小
          text.textContent = beam.newLabel;
          // [新增] 为标签添加 dataset 以支持圈选
          text.dataset.beamName = beam.name;
          text.dataset.beamLabel = beam.newLabel; // 保存編號用於右鍵顯示
          text.dataset.beamProp = beam.prop || ""; // 保存 section
          text.dataset.beamStory = beam.story || ""; // 保存樓層
          text.dataset.beamJoint1 = beam.joint1; // [新增] 保存節點資訊用於精確匹配
          text.dataset.beamJoint2 = beam.joint2; // [新增] 保存節點資訊用於精確匹配

          // [新增] 恢復選取狀態（支援跨樓層選取）
          if (selectedBeams.has(beamKey)) {
            text.classList.add('beam-selected');
          }

          // [新增] 標籤也可點擊（现在由圈选功能处理）
          text.style.cursor = "move"; // [修改] 改為 move 游標表示可拖動

          // 不再應用儲存的偏移量，標籤總是回到原始位置
          // 注释掉原有的点击编辑功能，改由圈选功能处理
          // text.addEventListener("click", () => openBeamEditDialog(beam));

          // [新增] 右鍵顯示編號功能
          text.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            e.stopPropagation();
            showBeamInfo(e, beam);
          });

          svg.appendChild(text);
        });

        // [優化] 繪製完成後恢復顯示，使用 requestAnimationFrame 確保平滑過渡
        requestAnimationFrame(() => {
          svg.style.opacity = '1';
          svg.style.transition = 'opacity 0.15s ease-out';
        });
      }

      // [新增] 計算點到線段的距離
      function pointToLineDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) {
          param = dot / lenSq;
        }

        let xx, yy;

        if (param < 0) {
          xx = x1;
          yy = y1;
        } else if (param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // [新增] 查找最近的梁
      function findNearestBeam(event, maxDistance = 20) {
        const svgElement = document.getElementById("svg-container");
        if (!svgElement) return null;

        // 獲取點擊位置的 SVG 座標
        const pt = svgElement.createSVGPoint();
        pt.x = event.clientX;
        pt.y = event.clientY;

        const viewport = getViewportElement();
        const ctm = viewport.getScreenCTM ? viewport.getScreenCTM() : svgElement.getScreenCTM();
        const svgPt = pt.matrixTransform(ctm.inverse());

        // 搜索所有梁線（包括 WB/FWB 梁和小梁）
        const beamLines = svgElement.querySelectorAll('.labeled-beam-line, .secondary-beam-line, .special-beam-line, .wall-beam-line');
        let nearestBeam = null;
        let minDistance = maxDistance;

        beamLines.forEach((line) => {
          const x1 = parseFloat(line.getAttribute('x1'));
          const y1 = parseFloat(line.getAttribute('y1'));
          const x2 = parseFloat(line.getAttribute('x2'));
          const y2 = parseFloat(line.getAttribute('y2'));

          const distance = pointToLineDistance(svgPt.x, svgPt.y, x1, y1, x2, y2);

          if (distance < minDistance) {
            minDistance = distance;
            nearestBeam = {
              name: line.dataset.beamName,
              newLabel: line.dataset.beamLabel,
              prop: line.dataset.beamProp,
              story: line.dataset.beamStory
            };
          }
        });

        return nearestBeam;
      }

      // [新增] 右鍵顯示梁資訊
      function showBeamInfo(event, beam) {
        // [修改] 從 fullProcessedBeams 中查找最新的梁數據
        const latestBeam = fullProcessedBeams.find(
          (b) =>
            b.name === beam.name &&
            b.story === beam.story &&
            b.joint1 === beam.joint1 &&
            b.joint2 === beam.joint2
        );

        // 使用最新的梁數據，如果找不到則使用傳入的 beam
        const beamData = latestBeam || beam;

        // 移除舊的提示框（如果有）
        const oldTooltip = document.getElementById('beam-info-tooltip');
        if (oldTooltip) {
          oldTooltip.remove();
        }

        // 創建新的提示框
        const tooltip = document.createElement('div');
        tooltip.id = 'beam-info-tooltip';
        tooltip.style.position = 'fixed';
        tooltip.style.left = event.clientX + 10 + 'px';
        tooltip.style.top = event.clientY + 10 + 'px';
        tooltip.style.background = 'var(--theme-surface)';
        tooltip.style.border = '2px solid var(--theme-accent)';
        tooltip.style.borderRadius = '8px';
        tooltip.style.padding = '12px 16px';
        tooltip.style.zIndex = '10000';
        tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
        tooltip.style.fontSize = '14px';
        tooltip.style.lineHeight = '1.6';
        tooltip.style.minWidth = '200px';
        tooltip.style.color = 'var(--theme-text-primary)';

        // 判斷是否為小梁
        const isSecondary = beamData.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(beamData.prop);
        const beamType = isSecondary ? '小梁' : '大梁';
        const beamTypeColor = isSecondary ? '#f97316' : '#3b82f6';

        tooltip.innerHTML = `
          <div style="margin-bottom: 4px;">
            <strong>編號：</strong><span style="color: var(--theme-accent); font-weight: bold;">${beamData.newLabel || beamData.name}</span>
          </div>
          <div style="margin-bottom: 4px;">
            <strong>ETABS編號：</strong>${beamData.name}
          </div>
          <div style="margin-bottom: 4px;">
            <strong>斷面：</strong>${beamData.prop || "N/A"}
          </div>
          <div style="margin-bottom: 4px;">
            <strong>樓層：</strong>${beamData.story || "N/A"}
          </div>
          <div>
            <strong>類型：</strong><span style="color: ${beamTypeColor}; font-weight: bold;">${beamType}</span>
          </div>
        `;

        document.body.appendChild(tooltip);

        // 點擊任意處關閉
        const closeTooltip = () => {
          tooltip.remove();
          document.removeEventListener('click', closeTooltip);
          document.removeEventListener('contextmenu', closeTooltip);
        };

        setTimeout(() => {
          document.addEventListener('click', closeTooltip);
          document.addEventListener('contextmenu', closeTooltip);
        }, 100);
      }

      // [新增] 開啟梁編輯對話框
      // [修改] 開啟梁編輯對話框
      function openBeamEditDialog(beam) {
        currentEditingBeam = beam;
        document.getElementById("edit-etabs-name").value = beam.name;
        document.getElementById("edit-story").value = beam.story;

        const newLabelInput = document.getElementById("edit-new-label");
        newLabelInput.value = beam.newLabel || "";

        // [新增] 檢查是否屬於標準層群組，顯示/隱藏連動選項
        const standardFloorGroup = getStandardFloorGroupForStory(beam.story);
        const linkGroup = document.getElementById("link-standard-floor-group");
        const linkCheckbox = document.getElementById("link-standard-floor");

        if (standardFloorGroup && standardFloorGroup.length > 1) {
          linkGroup.style.display = "block";
          linkCheckbox.checked = true; // 預設勾選
        } else {
          linkGroup.style.display = "none";
        }

        document.getElementById("beam-edit-dialog").style.display = "block";
        document.getElementById("dialog-overlay").style.display = "block";
        // 防止背景滾動
        document.body.style.overflow = 'hidden';

        // 自動對焦並選取文字
        newLabelInput.focus();
        newLabelInput.select();
      }
      // [新增] 關閉梁編輯對話框
      function closeBeamEditDialog() {
        currentEditingBeam = null;
        document.getElementById("beam-edit-dialog").style.display = "none";
        document.getElementById("dialog-overlay").style.display = "none";
        // 恢復背景滾動
        document.body.style.overflow = '';
      }

      // [新增] 儲存梁編號編輯
      function saveBeamEdit() {
        if (!currentEditingBeam) return;

        const newLabel = document.getElementById("edit-new-label").value.trim();
        if (!newLabel) {
          alert("請輸入新的編號");
          return;
        }

        // [新增] 檢查是否勾選連動標準層
        const linkCheckbox = document.getElementById("link-standard-floor");
        const linkGroup = document.getElementById("link-standard-floor-group");
        const shouldLinkStandardFloors = linkGroup.style.display !== "none" && linkCheckbox.checked;

        // 更新 fullProcessedBeams 中的資料
        const beamIndex = fullProcessedBeams.findIndex(
          (b) =>
            b.name === currentEditingBeam.name &&
            b.story === currentEditingBeam.story &&
            b.joint1 === currentEditingBeam.joint1 &&
            b.joint2 === currentEditingBeam.joint2,
        );

        if (beamIndex !== -1) {
          const oldLabel = fullProcessedBeams[beamIndex].newLabel;
          fullProcessedBeams[beamIndex].newLabel = newLabel;

          // [新增] 連動標準層更新
          if (shouldLinkStandardFloors) {
            const standardFloorGroup = getStandardFloorGroupForStory(currentEditingBeam.story);
            if (standardFloorGroup && standardFloorGroup.length > 1) {
              const linkedBeams = findBeamsAtSamePosition(fullProcessedBeams[beamIndex], standardFloorGroup);
              console.log(`[連動標準層] 更新 ${linkedBeams.length} 個其他樓層的梁`);
              linkedBeams.forEach(linkedBeam => {
                linkedBeam.newLabel = newLabel;
              });
            }
          }

          // [新增] 自動更新連續小梁編號
          updateSequentialBeamLabels(oldLabel, newLabel, currentEditingBeam.story);

          // 重新繪製
          handleStoryChange();
          closeBeamEditDialog();
          // [移除] 不再顯示 alert 提示
        }
      }

      // [新增] 自動更新連續小梁編號的函數
      function updateSequentialBeamLabels(oldLabel, newLabel, story) {
        console.log(`\n[連續小梁更新] 開始執行`);
        console.log(`  舊編號: ${oldLabel}`);
        console.log(`  新編號: ${newLabel}`);
        console.log(`  樓層: ${story}`);

        // 檢查舊編號是否為連續編號格式 (例如: b24-1, b25-2)
        const oldMatch = oldLabel.match(/^(.+?)(\d+)-(\d+)$/);
        const newMatch = newLabel.match(/^(.+?)(\d+)-(\d+)$/);

        console.log(`  舊編號匹配結果:`, oldMatch);
        console.log(`  新編號匹配結果:`, newMatch);

        // 只有當舊編號是連續格式且新編號也是連續格式時才處理
        if (!oldMatch || !newMatch) {
          console.log(`  ❌ 編號格式不符合連續格式，跳過更新`);
          return;
        }

        const [, oldPrefix, oldNumber, oldSerial] = oldMatch;
        const [, newPrefix, newNumber, newSerial] = newMatch;

        console.log(`  解析結果:`);
        console.log(`    舊: 前綴="${oldPrefix}", 數字="${oldNumber}", 序號="${oldSerial}"`);
        console.log(`    新: 前綴="${newPrefix}", 數字="${newNumber}", 序號="${newSerial}"`);

        const oldBaseLabel = `${oldPrefix}${oldNumber}`;
        const newBaseLabel = `${newPrefix}${newNumber}`;

        console.log(`  基礎標籤: ${oldBaseLabel} → ${newBaseLabel}`);

        // 如果前綴+數字都沒變，不需要更新
        if (oldBaseLabel === newBaseLabel) {
          console.log(`  ❌ 基礎標籤相同，無需更新`);
          return;
        }

        console.log(`\n  🔍 開始搜尋同組的連續小梁（序號 > ${oldSerial}）...`);

        // [新增] 智能更新：找到序號大於當前梁的所有連續小梁並更新
        const currentSerial = parseInt(oldSerial);
        const newStartSerial = parseInt(newSerial);
        let updatedCount = 0;

        fullProcessedBeams.forEach((beam, index) => {
          if (beam.story !== story) return;

          // 檢查是否為同一組的連續編號
          const beamMatch = beam.newLabel.match(/^(.+?)(\d+)-(\d+)$/);
          if (!beamMatch) return;

          const [, beamPrefix, beamNumber, beamSerial] = beamMatch;
          const beamBaseLabel = `${beamPrefix}${beamNumber}`;
          const beamSerialNum = parseInt(beamSerial);

          // 只更新同組且序號大於當前編輯梁的小梁
          if (beamBaseLabel === oldBaseLabel && beamSerialNum > currentSerial) {
            const oldBeamLabel = beam.newLabel;
            // 計算新的序號：當前序號 - 舊編輯梁序號 + 新起始序號
            const newSerialNum = beamSerialNum - currentSerial + newStartSerial;
            beam.newLabel = `${newBaseLabel}-${newSerialNum}`;
            updatedCount++;
            console.log(`    ✅ 更新梁 [${index}]: ${oldBeamLabel} → ${beam.newLabel}`);
            console.log(`       計算: ${beamSerialNum} - ${currentSerial} + ${newStartSerial} = ${newSerialNum}`);
          }
        });

        if (updatedCount > 0) {
          console.log(`\n  ✅ [連續小梁更新] 共更新了 ${updatedCount} 根小梁\n`);
          console.log(`  ℹ️  SVG 和 EXCEL 將由 handleStoryChange() 自動更新\n`);
        } else {
          console.log(`\n  ⚠️ [連續小梁更新] 沒有找到需要更新的小梁\n`);
        }
      }
      // --- Core Parsing & Labeling Functions (No changes below this line) ---
      function parseGrids(content) {
        const grids = {
          x: [],
          y: [],
          coordSystems: {}, // [新增] 儲存所有 COORDSYSTEM 信息
        };

        // [新增] 解析 COORDSYSTEM 定義（支持 UX, UY 位置和 ANGLE/RZ 旋轉角度）
        const coordSystemRegex = /COORDSYSTEM\s+"([^"]+)"\s+TYPE\s+"([^"]+)"([^\n]*)/gi;
        let csMatch;
        while ((csMatch = coordSystemRegex.exec(content)) !== null) {
          const [fullMatch, name, type, params] = csMatch;

          // 解析 UX, UY 座標
          const uxMatch = params.match(/UX\s+([-\d\.E]+)/i);
          const uyMatch = params.match(/UY\s+([-\d\.E]+)/i);

          // 解析旋轉角度 (支持 ANGLE 或 RZ)
          const angleMatch = params.match(/(?:ANGLE|RZ)\s+([-\d\.E]+)/i);

          grids.coordSystems[name] = {
            name,
            type,
            ux: uxMatch ? parseFloat(uxMatch[1]) : 0,  // X 座標偏移
            uy: uyMatch ? parseFloat(uyMatch[1]) : 0,  // Y 座標偏移
            angle: angleMatch ? parseFloat(angleMatch[1]) : 0, // 旋轉角度（度）
          };
          console.log(`[COORDSYSTEM] ${name}: type=${type}, ux=${grids.coordSystems[name].ux}, uy=${grids.coordSystems[name].uy}, angle=${grids.coordSystems[name].angle}°`);
        }

        const gridTableSection = content.match(
          /TABLE:\s+"GRID DEFINITIONS - LINES"([\s\S]*?)(?=TABLE:|$)/,
        );
        if (gridTableSection) {
          let currentGrid = {};
          const lines = gridTableSection[1].trim().split("\n");
          lines.forEach((line) => {
            const trimmedLine = line.trim();
            if (trimmedLine === "") {
              if (
                currentGrid.name &&
                currentGrid.type &&
                currentGrid.ordinate !== undefined
              ) {
                if (currentGrid.type.toUpperCase() === "X")
                  grids.x.push(currentGrid);
                else if (currentGrid.type.toUpperCase() === "Y")
                  grids.y.push(currentGrid);
              }
              currentGrid = {};
            } else {
              const match = trimmedLine.match(/(\S+)\s*=\s*"?([^"]*)"?/);
              if (match) {
                const [, key, value] = match;
                if (key === "GridID") currentGrid.name = value;
                if (key === "GridType") currentGrid.type = value;
                if (key === "Ordinate")
                  currentGrid.ordinate = parseFloat(value);
                if (key === "BubbleLoc") currentGrid.bubbleLoc = value;
                // [新增] 解析格線類型 (Primary/Secondary)
                if (key === "LineType") currentGrid.lineType = value;
              }
            }
          });
          if (currentGrid.name) {
            if (currentGrid.type.toUpperCase() === "X")
              grids.x.push(currentGrid);
            else if (currentGrid.type.toUpperCase() === "Y")
              grids.y.push(currentGrid);
          }
        }
        if (grids.x.length === 0 && grids.y.length === 0) {
          const gridDollarSection = content.match(/\$ GRIDS([\s\S]*?)(?=\$|$)/);
          if (gridDollarSection) {
            const lines = gridDollarSection[1].trim().split("\n");
            lines.forEach((line) => {
              // [修改] 解析格式: GRID "COORDSYSTEM"  LABEL "name"  DIR "X/Y"  COORD value  [BUBBLELOC "DEFAULT/SWITCHED"]
              const match = line.match(
                /GRID\s+"([^"]+)"\s+LABEL\s+"([^"]+)"\s+DIR\s+"(X|Y)"\s+COORD\s+([-\d\.E]+)/i,
              );
              if (match) {
                const [, coordsystem, name, type, ordinate] = match;

                // [新增] 解析 BUBBLELOC
                const bubbleLocMatch = line.match(/BUBBLELOC\s+"([^"]+)"/i);
                const bubbleLoc = bubbleLocMatch ? bubbleLocMatch[1] : "DEFAULT";

                const gridInfo = {
                  name,
                  type,
                  ordinate: parseFloat(ordinate),
                  coordsystem, // 保存 COORDSYSTEM 信息
                  bubbleLoc,   // [新增] 保存 BUBBLELOC 信息
                };
                if (type.toUpperCase() === "X") grids.x.push(gridInfo);
                else if (type.toUpperCase() === "Y") grids.y.push(gridInfo);
              }
            });
          }
        }
        if (grids.x.length === 0 && grids.y.length === 0) {
          throw new Error("Could not find grid definitions.");
        }

        // 去重並排序：先按 COORDSYSTEM 分組，再按 ordinate 排序
        const sortByCoordSystemAndOrdinate = (gridArray) => {
          // 去重
          const uniqueGrids = [...new Map(gridArray.map((item) => [item.name, item])).values()];

          // 先按 coordsystem 分組排序，再按 ordinate 排序
          return uniqueGrids.sort((a, b) => {
            const sysA = a.coordsystem || 'GLOBAL';
            const sysB = b.coordsystem || 'GLOBAL';

            // GLOBAL 系統優先
            if (sysA === 'GLOBAL' && sysB !== 'GLOBAL') return -1;
            if (sysA !== 'GLOBAL' && sysB === 'GLOBAL') return 1;

            // 同系統內按字母排序
            if (sysA !== sysB) {
              return sysA.localeCompare(sysB);
            }

            // 同系統內按坐標排序
            return a.ordinate - b.ordinate;
          });
        };

        grids.x = sortByCoordSystemAndOrdinate(grids.x);
        grids.y = sortByCoordSystemAndOrdinate(grids.y);
        return grids;
      }

      function parseJoints(content) {
        const joints = {};
        const sciNotationRegex = /"([^"]+)"\s+([-\d\.E]+)\s+([-\d\.E]+)/;
        const pointRegex = /^POINT\s+"([^"]+)"\s+([-\d\.E]+)\s+([-\d\.E]+)/;
        const nameRegex =
          /NAME\s*=\s*(\S+)\s*X\s*=\s*([-\d\.E]+)\s*Y\s*=\s*([-\d\.E]+)/;

        const jointTableSection = content.match(
          /TABLE:\s+"JOINT COORDINATES"([\s\S]*?)(?=TABLE:|$)/,
        );
        if (jointTableSection) {
          const lines = jointTableSection[1].trim().split("\n");
          lines.forEach((line) => {
            if (line.trim().startsWith("JOINT")) return;
            const match = line.trim().match(sciNotationRegex);
            if (match) {
              joints[match[1]] = {
                x: parseFloat(match[2]),
                y: parseFloat(match[3]),
              };
            }
          });
        }
        if (Object.keys(joints).length === 0) {
          const lines = content.split("\n");
          lines.forEach((line) => {
            const match = line.trim().match(pointRegex);
            if (match) {
              joints[match[1]] = {
                x: parseFloat(match[2]),
                y: parseFloat(match[3]),
              };
            }
          });
        }
        if (Object.keys(joints).length === 0) {
          const jointDollarSection = content.match(
            /\$ JOINTS([\s\S]*?)(?=\$|$)/s,
          );
          if (jointDollarSection) {
            const lines = jointDollarSection[1].trim().split("\n");
            lines.forEach((line) => {
              const match = line.match(nameRegex);
              if (match) {
                joints[match[1]] = {
                  x: parseFloat(match[2]),
                  y: parseFloat(match[3]),
                };
              }
            });
          }
        }
        if (Object.keys(joints).length === 0) {
          throw new Error("Could not find joint coordinate definitions.");
        }
        return joints;
      }

      function parseFrames(content, story) {
        const frames = [];
        const isBeamProp = (propName) => {
          if (!propName) return false;
          const p = propName.toUpperCase();
          const isNumericBeam = /^\d+(\.\d+)?B/.test(p);
          return (
            isNumericBeam ||
            p.startsWith("B") ||
            p.startsWith("G") ||
            p.startsWith("SB") ||
            p.startsWith("WB") ||
            p.startsWith("FB") ||
            p.startsWith("FGB") ||
            p.startsWith("FSB") ||
            p.startsWith("FWB")
          );
        };

        const frameTableSection = content.match(
          /TABLE:\s+"CONNECTIVITY - FRAME"([\s\S]*?)(?=TABLE:|$)/,
        );
        const frameAssignSection = content.match(
          /TABLE:\s+"FRAME ASSIGNS - SECTION"([\s\S]*?)(?=TABLE:|$)/,
        );
        if (frameTableSection && frameAssignSection) {
          const connectivityLines = frameTableSection[1].trim().split("\n");
          const assignLines = frameAssignSection[1].trim().split("\n");
          const frameProperties = new Map();
          assignLines.forEach((line) => {
            const match = line
              .trim()
              .match(/^"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"/);
            if (match && match[2] === story) {
              frameProperties.set(match[1], match[3]);
            }
          });
          connectivityLines.forEach((line) => {
            const match = line
              .trim()
              .match(/^"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"/);
            if (match) {
              const [, name, joint1, joint2] = match;
              const propName = frameProperties.get(name);
              if (isBeamProp(propName)) {
                frames.push({
                  name,
                  prop: propName,
                  joint1,
                  joint2,
                  story,
                });
              }
            }
          });
        }
        if (frames.length === 0) {
          const lineConnectivitySection = content.match(
            /\$ LINE CONNECTIVITIES([\s\S]*?)(?=\$|$)/i,
          );
          const lineAssignsSection = content.match(
            /\$ LINE ASSIGNS([\s\S]*?)(?=\$|$)/i,
          );
          if (lineConnectivitySection && lineAssignsSection) {
            const connectLines = lineConnectivitySection[1].trim().split("\n");
            const assignLines = lineAssignsSection[1].trim().split("\n");
            const beamAssigns = new Map();
            assignLines.forEach((line) => {
              const assignMatch = line.match(
                new RegExp(
                  `LINEASSIGN\\s+"([^"]+)"\\s+"${story}"\\s+SECTION\\s+"([^"]+)"`,
                  "i",
                ),
              );
              if (assignMatch) {
                const [, name, propName] = assignMatch;
                if (isBeamProp(propName)) {
                  beamAssigns.set(name, propName);
                }
              }
            });
            connectLines.forEach((line) => {
              const connMatch = line.match(
                /LINE\s+"([^"]+)"\s+BEAM\s+"([^"]+)"\s+"([^"]+)"/i,
              );
              if (connMatch) {
                const [, name, joint1, joint2] = connMatch;
                if (beamAssigns.has(name)) {
                  frames.push({
                    name,
                    prop: beamAssigns.get(name),
                    joint1,
                    joint2,
                    story,
                  });
                }
              }
            });
          }
        }
        return frames;
      }

      function findClosestGrid(coordinate, grids) {
        if (!grids || grids.length === 0) return null;
        return grids.reduce((closest, current) => {
          const closestDiff = Math.abs(coordinate - closest.ordinate);
          const currentDiff = Math.abs(coordinate - current.ordinate);
          return currentDiff < closestDiff ? current : closest;
        });
      }

      // [新增] 輔助函數：計算梁的角度（度數）
      function calculateBeamAngle(j1, j2) {
        const dx = j2.x - j1.x;
        const dy = j2.y - j1.y;
        // 返回角度（0-360度，從 X 軸正向逆時針計算）
        let angle = Math.atan2(dy, dx) * (180 / Math.PI);
        if (angle < 0) angle += 360;
        return angle;
      }

      // [新增] 輔助函數：全局座標轉換為局部座標（反向轉換）
      function globalToLocal(globalX, globalY, coordSystem) {
        const angleRad = (coordSystem.angle || 0) * Math.PI / 180;
        const cosA = Math.cos(angleRad);
        const sinA = Math.sin(angleRad);

        // 先平移（減去原點偏移）
        const translatedX = globalX - (coordSystem.ux || 0);
        const translatedY = globalY - (coordSystem.uy || 0);

        // 再旋轉（逆向旋轉，使用逆矩陣）
        const localX = translatedX * cosA + translatedY * sinA;
        const localY = -translatedX * sinA + translatedY * cosA;

        return { localX, localY };
      }

      // [重構] 輔助函數：基於梁端點座標判斷所屬的 Grid Line 系統
      // 容差值 0.01m，檢查端點是否落在某座標系統的格線上
      function findBestCoordSystemForBeam(beam, grids) {
        if (!grids.coordSystems || Object.keys(grids.coordSystems).length === 0) {
          return 'GLOBAL';
        }

        const POSITION_TOLERANCE = 0.01; // 位置容差（米）
        const beamEndpoints = [beam.j1, beam.j2];
        const coordSystemScores = {};

        // 初始化所有座標系統的分數
        Object.keys(grids.coordSystems).forEach(csName => {
          coordSystemScores[csName] = 0;
        });

        // 對每個端點，檢查它在各座標系統中的對齊情況
        beamEndpoints.forEach(endpoint => {
          if (!endpoint) return;

          for (const [csName, csInfo] of Object.entries(grids.coordSystems)) {
            // 轉換端點到該座標系統的局部座標
            const localCoord = globalToLocal(endpoint.x, endpoint.y, csInfo);

            // 檢查該端點是否對齊該座標系統的 X 軸格線（垂直線）
            const alignedWithGridX = grids.x
              .filter(g => (g.coordsystem || 'GLOBAL') === csName)
              .some(g => Math.abs(localCoord.localX - g.ordinate) < POSITION_TOLERANCE);

            // 檢查該端點是否對齊該座標系統的 Y 軸格線（水平線）
            const alignedWithGridY = grids.y
              .filter(g => (g.coordsystem || 'GLOBAL') === csName)
              .some(g => Math.abs(localCoord.localY - g.ordinate) < POSITION_TOLERANCE);

            // 如果端點在此座標系統的格線上，增加該系統的分數
            if (alignedWithGridX) coordSystemScores[csName]++;
            if (alignedWithGridY) coordSystemScores[csName]++;
          }
        });

        // 返回分數最高的座標系統（優先選擇非 GLOBAL）
        let bestCoordSystem = 'GLOBAL';
        let maxScore = 0;

        for (const [csName, score] of Object.entries(coordSystemScores)) {
          // 分數更高，或分數相同但非 GLOBAL（優先非 GLOBAL）
          if (score > maxScore || (score === maxScore && score > 0 && csName !== 'GLOBAL')) {
            maxScore = score;
            bestCoordSystem = csName;
          }
        }

        // 如果沒有找到匹配的座標系統，回退到 GLOBAL
        if (maxScore === 0) {
          bestCoordSystem = 'GLOBAL';
        }

        // [調試] 輸出座標系統判斷結果
        if (maxScore > 0 && bestCoordSystem !== 'GLOBAL') {
          console.log(`[座標系統判斷] 梁端點: (${beam.j1?.x?.toFixed(2)}, ${beam.j1?.y?.toFixed(2)}) - (${beam.j2?.x?.toFixed(2)}, ${beam.j2?.y?.toFixed(2)})`);
          console.log(`  分數: ${JSON.stringify(coordSystemScores)}, 選擇: ${bestCoordSystem}`);
        }

        return bestCoordSystem;
      }

      // [新增] 輔助函數：獲取指定 COORDSYSTEM 的 Grid Lines
      function getGridsForCoordSystem(grids, coordsystem) {
        return {
          x: grids.x.filter(g => (g.coordsystem || 'GLOBAL') === coordsystem),
          y: grids.y.filter(g => (g.coordsystem || 'GLOBAL') === coordsystem),
        };
      }

      // [新增] 輔助函數：取得梁中心點在特定座標系統中的局部座標
      function getBeamLocalCenter(beam, coordSystemName, grids) {
        const csInfo = grids.coordSystems ? grids.coordSystems[coordSystemName] : null;
        if (!csInfo || coordSystemName === 'GLOBAL') {
          // GLOBAL 系統不需轉換
          return { localX: beam.centerX, localY: beam.centerY };
        }
        return globalToLocal(beam.centerX, beam.centerY, csInfo);
      }

      // [新增] 輔助函數：取得梁端點在特定座標系統中的局部座標
      function getBeamLocalBounds(beam, coordSystemName, grids) {
        const csInfo = grids.coordSystems ? grids.coordSystems[coordSystemName] : null;
        if (!csInfo || coordSystemName === 'GLOBAL') {
          // GLOBAL 系統不需轉換
          return {
            minX: beam.minX, maxX: beam.maxX,
            minY: beam.minY, maxY: beam.maxY
          };
        }
        const local1 = globalToLocal(beam.j1.x, beam.j1.y, csInfo);
        const local2 = globalToLocal(beam.j2.x, beam.j2.y, csInfo);
        return {
          minX: Math.min(local1.localX, local2.localX),
          maxX: Math.max(local1.localX, local2.localX),
          minY: Math.min(local1.localY, local2.localY),
          maxY: Math.max(local1.localY, local2.localY)
        };
      }

      // [新增] 輔助函數：檢查梁是否對齊某個座標系統的軸向（水平或垂直）
      function getBeamOrientationInCoordSystem(beam, coordSystemName, grids) {
        const ANGLE_TOLERANCE = 2; // 角度容差（度）
        const beamAngle = calculateBeamAngle(beam.j1, beam.j2);

        // 獲取座標系統的旋轉角度
        let csAngle = 0;
        if (coordSystemName !== 'GLOBAL' && grids.coordSystems[coordSystemName]) {
          csAngle = grids.coordSystems[coordSystemName].angle || 0;
        }

        // 計算梁與座標系統 X 軸（水平）和 Y 軸（垂直）的角度差
        const angleFromXAxis = Math.min(
          Math.abs(beamAngle - csAngle),
          Math.abs(beamAngle - (csAngle + 360)),
          360 - Math.abs(beamAngle - csAngle),
          Math.abs(beamAngle - (csAngle + 180)) // 考慮反向
        );

        const angleFromYAxis = Math.min(
          Math.abs(beamAngle - (csAngle + 90)),
          Math.abs(beamAngle - (csAngle + 270)),
          360 - Math.abs(beamAngle - (csAngle + 90))
        );

        // 判斷是水平、垂直還是斜向
        if (angleFromXAxis <= ANGLE_TOLERANCE) {
          return { isHorizontal: true, isVertical: false, isDiagonal: false, coordSystem: coordSystemName };
        } else if (angleFromYAxis <= ANGLE_TOLERANCE) {
          return { isHorizontal: false, isVertical: true, isDiagonal: false, coordSystem: coordSystemName };
        } else {
          return { isHorizontal: false, isVertical: false, isDiagonal: true, coordSystem: coordSystemName };
        }
      }

      function generateLabelsForStory(beamsInStory, joints, grids, reservedSerials = new Set()) {
        const labelComponentMap = new Map();

        // --- 開始：這是【最終修正版】的 getBeamSerial 函式 ---
        // [修正] 新增 coordSystemName 和 fullGrids 參數以支援座標轉換
        function getBeamSerial(segment, grids, isHorizontal, coordSystemName = 'GLOBAL', fullGrids = null) {
          const ON_GRID_TOLERANCE = 0.1;

          // [修正] 將梁的座標轉換到局部座標系統
          let localBounds;
          if (coordSystemName && coordSystemName !== 'GLOBAL' && fullGrids && segment.j1 && segment.j2) {
            localBounds = getBeamLocalBounds(segment, coordSystemName, fullGrids);
          } else {
            localBounds = {
              minX: segment.minX, maxX: segment.maxX,
              minY: segment.minY, maxY: segment.maxY
            };
          }

          // [修改] 優先使用使用者配置，只對 Primary 格線轉換為數字
          const getSerialValue = (gridNameToFind, gridArray) => {
            // 找到對應的格線物件
            const gridObj = gridArray.find((g) => g.name === gridNameToFind);
            if (!gridObj) return NaN;

            // [新增] 優先使用使用者自訂配置
            if (userGridConfig) {
              const axisKey = gridArray === grids.x ? "x" : "y";
              const userConfig = userGridConfig[axisKey]?.find(
                (c) => c.name === gridNameToFind,
              );
              if (userConfig && userConfig.serialValue !== undefined) {
                // [修改] 如果 serialValue 是 null，表示要跳過這個格線
                if (userConfig.serialValue === null) {
                  return NaN; // 回傳 NaN 讓該梁不被編號
                }
                return userConfig.serialValue;
              }
            }

            // 如果是 Secondary 格線，直接返回格線名稱
            if (
              gridObj.lineType &&
              gridObj.lineType.toUpperCase() === "SECONDARY"
            ) {
              return gridNameToFind; // 返回原始名稱
            }

            // Primary 格線：使用原有邏輯
            const parsedNum = parseInt(gridNameToFind, 10);
            if (!isNaN(parsedNum) && String(parsedNum) === gridNameToFind) {
              // 如果格線名稱本身就是純數字，直接回傳該數字
              return parsedNum;
            } else {
              // 否則，回傳它在陣列中的 1-based 順序
              const index = gridArray.findIndex(
                (g) => g.name === gridNameToFind,
              );
              return index !== -1 ? index + 1 : NaN;
            }
          };

          if (isHorizontal) {
            // [修正] 使用局部座標
            const endGrid = findClosestGrid(localBounds.maxX, grids.x);
            // [修复] 检查 endGrid 是否为 null
            if (!endGrid) return NaN;

            if (Math.abs(localBounds.maxX - endGrid.ordinate) < ON_GRID_TOLERANCE) {
              // **【水平梁規則1】** 終點格線編號 - 1
              const serial = getSerialValue(endGrid.name, grids.x);
              return typeof serial === "number" ? serial - 1 : serial;
            }
            const startGrid = findClosestGrid(localBounds.minX, grids.x);
            // [修复] 检查 startGrid 是否为 null
            if (!startGrid) return NaN;

            // **【水平梁規則2】** 起點格線編號（不減 1）
            return getSerialValue(startGrid.name, grids.x);
          } else {
            // 垂直梁的規則：與水平梁相同
            // [修正] 使用局部座標
            const endGrid = findClosestGrid(localBounds.maxY, grids.y);
            // [修复] 检查 endGrid 是否为 null
            if (!endGrid) return NaN;

            if (Math.abs(localBounds.maxY - endGrid.ordinate) < ON_GRID_TOLERANCE) {
              // **【垂直梁規則1】** 終點格線編號 - 1
              const serial = getSerialValue(endGrid.name, grids.y);
              return typeof serial === "number" ? serial - 1 : serial;
            }
            const startGrid = findClosestGrid(localBounds.minY, grids.y);
            // [修复] 检查 startGrid 是否为 null
            if (!startGrid) return NaN;

            // **【垂直梁規則2】** 起點格線編號（不減 1）
            return getSerialValue(startGrid.name, grids.y);
          }
          return NaN;
        }
        // --- 結束：getBeamSerial 函式修改完畢 ---

        function parseGridName(gridName) {
          if (!gridName) return "";
          const upperGridName = gridName.toUpperCase();
          if (upperGridName.startsWith("X") || upperGridName.startsWith("Y")) {
            const match = gridName.match(/^[XY](.*)/i);
            return match ? match[1] : gridName;
          }
          return gridName;
        }

        const beamsWithCoords = beamsInStory
          .map((b) => {
            const j1 = joints[b.joint1],
              j2 = joints[b.joint2];
            if (!j1 || !j2) return null;

            // [重構] 首先基於端點座標判斷梁所屬的座標系統
            const beamData = { j1, j2, name: b.name, joint1: b.joint1, joint2: b.joint2 };

            // [修正] 對所有梁都檢查它們屬於哪個座標系統（基於端點位置）
            const bestCoordSystem = findBestCoordSystemForBeam(beamData, grids);

            // 在該座標系統中判斷梁的方向
            const orientation = getBeamOrientationInCoordSystem(beamData, bestCoordSystem, grids);

            return {
              ...b,
              j1,
              j2,
              minX: Math.min(j1.x, j2.x),
              maxX: Math.max(j1.x, j2.x),
              minY: Math.min(j1.y, j2.y),
              maxY: Math.max(j1.y, j2.y),
              centerX: (j1.x + j2.x) / 2,
              centerY: (j1.y + j2.y) / 2,
              isHorizontal: orientation.isHorizontal,
              isVertical: orientation.isVertical,
              isDiagonal: orientation.isDiagonal,
              coordSystem: bestCoordSystem, // 記錄所屬座標系統
            };
          })
          .filter(Boolean);

        const processedBeams = new Set();
        beamsWithCoords.forEach((beam) => {
          const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
          if (processedBeams.has(beamKey)) return;

          processedBeams.add(beamKey);

          let serial;
          let primaryGridName;
          let subGridMarker = "";

          if (beam.isVertical) {
            // [修改] 使用座標系統特定的格線
            const coordSystemGrids = getGridsForCoordSystem(grids, beam.coordSystem);
            const relevantGrids = coordSystemGrids.x.length > 0 ? coordSystemGrids.x : grids.x;

            // [修正] 將梁座標轉換到該座標系統的局部座標進行比對
            const localCenter = getBeamLocalCenter(beam, beam.coordSystem, grids);

            let onGridLine = relevantGrids.find(
              (g) => Math.abs(localCenter.localX - g.ordinate) < TOLERANCE,
            );

            if (onGridLine) {
              primaryGridName = parseGridName(onGridLine.name);
              subGridMarker = "";
            } else {
              // 使用 findClosestGrid 找到最接近的格線作為主格線
              const closestGrid = findClosestGrid(localCenter.localX, relevantGrids);
              if (closestGrid) {
                primaryGridName = parseGridName(closestGrid.name);

                // [修改] 在同一座標系統內尋找同類型的梁來決定 subGridMarker
                const sameSystemBeams = beamsWithCoords.filter(
                  (b) => b.isVertical && b.coordSystem === beam.coordSystem
                );

                // 找到相鄰的兩條格線
                const sortedGrids = relevantGrids.slice().sort((a, b) => a.ordinate - b.ordinate);
                const closestIndex = sortedGrids.findIndex(g => g.name === closestGrid.name);

                // [修复] 處理邊界情況：找到相鄰的格線（前一條或後一條）
                let gridBelow = null;
                let gridAbove = null;

                if (closestIndex > 0) {
                  gridBelow = sortedGrids[closestIndex - 1];
                }
                if (closestIndex >= 0 && closestIndex + 1 < sortedGrids.length) {
                  gridAbove = sortedGrids[closestIndex + 1];
                }

                // [修复] 使用找到的格線，即使只有一側
                if (!gridBelow && !gridAbove) {
                  // closestGrid 自己就是參考格線
                  gridBelow = closestGrid;
                } else if (!gridBelow) {
                  gridBelow = closestGrid;
                } else if (!gridAbove) {
                  gridAbove = closestGrid;
                }

                // 只有在兩側都有格線時才計算子格線標記
                if (gridBelow && gridAbove && gridBelow.name !== gridAbove.name) {
                  // [修正] 使用局部座標進行比對
                  const uniqueXCoords = [
                    ...new Set(
                      sameSystemBeams
                        .filter((b) => {
                          const bLocal = getBeamLocalCenter(b, b.coordSystem, grids);
                          return bLocal.localX > gridBelow.ordinate &&
                                 bLocal.localX < gridAbove.ordinate;
                        })
                        .map((b) => {
                          const bLocal = getBeamLocalCenter(b, b.coordSystem, grids);
                          return bLocal.localX.toFixed(2);
                        }),
                    ),
                  ].sort((a, b) => parseFloat(a) - parseFloat(b));

                  const rank = uniqueXCoords.indexOf(localCenter.localX.toFixed(2));
                  if (rank !== -1) {
                    subGridMarker = String.fromCharCode(97 + rank);
                  }
                }
              } else {
                // 如果完全沒有格線，才跳過
                return;
              }
            }
            serial = getBeamSerial(beam, coordSystemGrids, false, beam.coordSystem, grids);
          } else if (beam.isHorizontal) {
            // [修改] 使用座標系統特定的格線
            const coordSystemGrids = getGridsForCoordSystem(grids, beam.coordSystem);
            const relevantGrids = coordSystemGrids.y.length > 0 ? coordSystemGrids.y : grids.y;

            // [修正] 將梁座標轉換到該座標系統的局部座標進行比對
            const localCenter = getBeamLocalCenter(beam, beam.coordSystem, grids);

            let onGridLine = relevantGrids.find(
              (g) => Math.abs(localCenter.localY - g.ordinate) < TOLERANCE,
            );

            if (onGridLine) {
              primaryGridName = parseGridName(onGridLine.name);
              subGridMarker = "";
            } else {
              // 使用 findClosestGrid 找到最接近的格線作為主格線
              const closestGrid = findClosestGrid(localCenter.localY, relevantGrids);
              if (closestGrid) {
                primaryGridName = parseGridName(closestGrid.name);

                // [修改] 在同一座標系統內尋找同類型的梁來決定 subGridMarker
                const sameSystemBeams = beamsWithCoords.filter(
                  (b) => b.isHorizontal && b.coordSystem === beam.coordSystem
                );

                // 找到相鄰的兩條格線
                const sortedGrids = relevantGrids.slice().sort((a, b) => a.ordinate - b.ordinate);
                const closestIndex = sortedGrids.findIndex(g => g.name === closestGrid.name);

                // [修复] 處理邊界情況：找到相鄰的格線（前一條或後一條）
                let gridBelow = null;
                let gridAbove = null;

                if (closestIndex > 0) {
                  gridBelow = sortedGrids[closestIndex - 1];
                }
                if (closestIndex >= 0 && closestIndex + 1 < sortedGrids.length) {
                  gridAbove = sortedGrids[closestIndex + 1];
                }

                // [修复] 使用找到的格線，即使只有一側
                if (!gridBelow && !gridAbove) {
                  // closestGrid 自己就是參考格線
                  gridBelow = closestGrid;
                } else if (!gridBelow) {
                  gridBelow = closestGrid;
                } else if (!gridAbove) {
                  gridAbove = closestGrid;
                }

                // 只有在兩側都有格線時才計算子格線標記
                if (gridBelow && gridAbove && gridBelow.name !== gridAbove.name) {
                  // [修正] 使用局部座標進行比對
                  const uniqueYCoords = [
                    ...new Set(
                      sameSystemBeams
                        .filter((b) => {
                          const bLocal = getBeamLocalCenter(b, b.coordSystem, grids);
                          return bLocal.localY > gridBelow.ordinate &&
                                 bLocal.localY < gridAbove.ordinate;
                        })
                        .map((b) => {
                          const bLocal = getBeamLocalCenter(b, b.coordSystem, grids);
                          return bLocal.localY.toFixed(2);
                        }),
                    ),
                  ].sort((a, b) => parseFloat(a) - parseFloat(b));

                  const rank = uniqueYCoords.indexOf(localCenter.localY.toFixed(2));
                  if (rank !== -1) {
                    subGridMarker = String.fromCharCode(97 + rank);
                  }
                }
              } else {
                // 如果完全沒有格線，才跳過
                return;
              }
            }
            serial = getBeamSerial(beam, coordSystemGrids, true, beam.coordSystem, grids);
          } else if (beam.isDiagonal) {
            // [重構] 斜向大梁的編號邏輯：根據所屬 COORDSYSTEM 的格線進行編號
            // [修复] 使用已经计算好的 coordSystem，避免重复计算
            const bestCoordSystem = beam.coordSystem || 'GLOBAL';

            // 2. 只處理非 GLOBAL 系統的斜向梁
            if (bestCoordSystem !== 'GLOBAL') {
              // 3. 獲取該 COORDSYSTEM 的 Grid Lines
              const coordSystemGrids = getGridsForCoordSystem(grids, bestCoordSystem);

              if (coordSystemGrids.x.length > 0 || coordSystemGrids.y.length > 0) {
                // 4. 判斷梁相對於 COORDSYSTEM 的方向
                const csAngle = grids.coordSystems[bestCoordSystem].angle || 0;
                const beamAngle = calculateBeamAngle(beam.j1, beam.j2);

                // 標準化角度
                const normalizeAngle = (angle) => {
                  let normalized = angle % 360;
                  if (normalized < 0) normalized += 360;
                  return normalized;
                };

                const normalizedBeamAngle = normalizeAngle(beamAngle);
                const normalizedCsAngle = normalizeAngle(csAngle);

                // 判斷是沿著 X 軸方向（rz 或 rz+180）還是 Y 軸方向（rz+90 或 rz+270）
                const getAngleDiff = (angle1, angle2) => {
                  const diff = Math.abs(normalizeAngle(angle1) - normalizeAngle(angle2));
                  return Math.min(diff, 360 - diff);
                };

                const angleDiffX = Math.min(
                  getAngleDiff(beamAngle, csAngle),
                  getAngleDiff(beamAngle, csAngle + 180)
                );
                const angleDiffY = Math.min(
                  getAngleDiff(beamAngle, csAngle + 90),
                  getAngleDiff(beamAngle, csAngle + 270)
                );

                const isAlongX = angleDiffX < angleDiffY;

                // 5. 找到梁中心點最接近的格線
                // [修正] 將梁座標轉換到該座標系統的局部座標進行比對
                const localCenter = getBeamLocalCenter(beam, bestCoordSystem, grids);
                let onGridLine = null;
                let gridBelow = null;
                let gridAbove = null;

                if (isAlongX) {
                  // 沿著 X 軸方向的梁：使用 Y 軸格線編號
                  onGridLine = coordSystemGrids.y.find(
                    (g) => Math.abs(localCenter.localY - g.ordinate) < TOLERANCE
                  );

                  if (!onGridLine) {
                    gridBelow = coordSystemGrids.y
                      .slice()
                      .reverse()
                      .find((g) => g.ordinate < localCenter.localY);
                    gridAbove = coordSystemGrids.y.find((g) => g.ordinate > localCenter.localY);
                  }
                } else {
                  // 沿著 Y 軸方向的梁：使用 X 軸格線編號
                  onGridLine = coordSystemGrids.x.find(
                    (g) => Math.abs(localCenter.localX - g.ordinate) < TOLERANCE
                  );

                  if (!onGridLine) {
                    gridBelow = coordSystemGrids.x
                      .slice()
                      .reverse()
                      .find((g) => g.ordinate < localCenter.localX);
                    gridAbove = coordSystemGrids.x.find((g) => g.ordinate > localCenter.localX);
                  }
                }

                // 6. 確定主格線名稱和子格線標記
                if (onGridLine) {
                  primaryGridName = parseGridName(onGridLine.name);
                  subGridMarker = "";
                } else if (gridBelow || gridAbove) {
                  const referenceGrid = gridBelow || gridAbove;
                  primaryGridName = parseGridName(referenceGrid.name);

                  // 計算子格線標記（如果兩側都有格線）
                  // [修正] 使用局部座標進行比對
                  if (gridBelow && gridAbove) {
                    const relevantBeams = beamsWithCoords.filter((b) => {
                      if (!b.isDiagonal) return false;

                      const bCs = b.coordSystem || 'GLOBAL';
                      if (bCs !== bestCoordSystem) return false;

                      const bLocal = getBeamLocalCenter(b, bCs, grids);
                      if (isAlongX) {
                        return bLocal.localY > gridBelow.ordinate && bLocal.localY < gridAbove.ordinate;
                      } else {
                        return bLocal.localX > gridBelow.ordinate && bLocal.localX < gridAbove.ordinate;
                      }
                    });

                    const uniqueCoords = [
                      ...new Set(
                        relevantBeams.map((b) => {
                          const bLocal = getBeamLocalCenter(b, b.coordSystem || 'GLOBAL', grids);
                          return isAlongX ? bLocal.localY.toFixed(2) : bLocal.localX.toFixed(2);
                        })
                      ),
                    ].sort((a, b) => parseFloat(a) - parseFloat(b));

                    const targetCoord = isAlongX
                      ? localCenter.localY.toFixed(2)
                      : localCenter.localX.toFixed(2);
                    const rank = uniqueCoords.indexOf(targetCoord);

                    if (rank !== -1) {
                      subGridMarker = String.fromCharCode(97 + rank);
                    }
                  }
                }

                // 7. 計算序號（使用與水平/垂直梁相同的邏輯）
                if (primaryGridName) {
                  serial = getBeamSerial(
                    beam,
                    coordSystemGrids,
                    isAlongX,
                    bestCoordSystem,
                    grids
                  );

                  console.log(
                    `[斜向梁編號] ${beam.name} 使用 ${bestCoordSystem} 系統 (rz=${csAngle}°)，方向=${isAlongX ? 'X軸' : 'Y軸'}，格線=${primaryGridName}${subGridMarker}，序號=${serial}`
                  );

                  // 8. 保存到 labelComponentMap
                  labelComponentMap.set(beamKey, {
                    isDiagonal: true,
                    isAlongX,
                    primaryGridName,
                    subGridMarker,
                    serial,
                    coordSystem: bestCoordSystem,
                  });

                  // 處理完畢，繼續下一個梁
                  return;
                }
              }
            }

            // 如果沒有找到合適的 COORDSYSTEM 或編號失敗，跳過
            return;
          }

          // [修改] 支援字串型序號 (Secondary 格線)
          // 注意：不再跳過預留序號，因為 FIXED 設定的梁（如 g1）已經在前面被處理，
          // 其他梁使用相同序號不會衝突（完整編號會不同，如 GA1-1 vs g1）
          if (
            serial !== undefined &&
            serial !== -1 &&
            (typeof serial === "string" || !isNaN(serial))
          ) {
            labelComponentMap.set(beamKey, {
              isVertical: beam.isVertical,
              primaryGridName,
              subGridMarker,
              serial: serial,
            });
          }
        });
        return labelComponentMap;
      }

      function distance(p1, p2) {
        if (!p1 || !p2) return Infinity;
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      }

      function isPointOnSegment(point, segP1, segP2, tolerance) {
        if (!point || !segP1 || !segP2) return false;
        const segLength = distance(segP1, segP2);
        if (segLength < tolerance) {
          return distance(point, segP1) < tolerance;
        }
        const distSum = distance(point, segP1) + distance(point, segP2);
        return Math.abs(distSum - segLength) < tolerance;
      }
      // =================================================================
      // ### 全新鏡像演算法 v4 (最終版，依使用者思路)：開始 ###
      // =================================================================

      // 注意: SYMMETRY_PASS_SCORE, SYMMETRY_TOLERANCE, MATCHING_TOLERANCE 已在全域變數區定義
      const DIRECTION_TOLERANCE = 0.01; // 用於判斷梁的方向（水平/垂直）

      /**
       * [新增] 智能偵測對稱軸 - 基於 Opus 4.1 算法
       * 通過計算每個候選軸的對稱匹配分數來自動偵測對稱軸
       */
      function detectSymmetryAxis(beams, joints, gridData) {
        if (!beams || beams.length < 10) return null;

        // 收集所有梁的 X 座標
        const xCoords = [];
        beams.forEach(beam => {
          const j1 = joints[beam.joint1];
          const j2 = joints[beam.joint2];
          if (j1 && j2) {
            xCoords.push(j1.x, j2.x);
          }
        });

        if (xCoords.length === 0) return null;

        // 計算 X 軸範圍和中心
        const minX = Math.min(...xCoords);
        const maxX = Math.max(...xCoords);
        const centerX = (minX + maxX) / 2;

        // 測試候選對稱軸（幾何中心 + 格線位置）
        const candidates = [centerX];

        if (gridData && gridData.x) {
          gridData.x.forEach(grid => {
            if (grid.ordinate > minX && grid.ordinate < maxX) {
              candidates.push(grid.ordinate);
            }
          });
        }

        // 評估每個候選軸的對稱性
        let bestAxis = null;
        let bestScore = 0;

        candidates.forEach(axisX => {
          let matchCount = 0;
          let totalCount = 0;

          beams.forEach(beam => {
            const j1 = joints[beam.joint1];
            const j2 = joints[beam.joint2];
            if (!j1 || !j2) return;

            const midX = (j1.x + j2.x) / 2;
            const midY = (j1.y + j2.y) / 2;
            const length = distance(j1, j2);

            // 跳過在軸上的梁
            if (Math.abs(midX - axisX) < SYMMETRY_TOLERANCE) return;

            totalCount++;

            // 尋找鏡像梁
            const mirroredX = 2 * axisX - midX;
            const hasMatch = beams.some(otherBeam => {
              if (otherBeam === beam) return false;
              const oj1 = joints[otherBeam.joint1];
              const oj2 = joints[otherBeam.joint2];
              if (!oj1 || !oj2) return false;

              const otherMidX = (oj1.x + oj2.x) / 2;
              const otherMidY = (oj1.y + oj2.y) / 2;
              const otherLength = distance(oj1, oj2);

              return Math.abs(otherMidX - mirroredX) < MATCHING_TOLERANCE &&
                     Math.abs(otherMidY - midY) < MATCHING_TOLERANCE &&
                     Math.abs(otherLength - length) < 1.0;
            });

            if (hasMatch) matchCount++;
          });

          const score = totalCount > 0 ? matchCount / totalCount : 0;
          if (score > bestScore) {
            bestScore = score;
            bestAxis = axisX;
          }
        });

        // 如果對稱分數 > 及格門檻，返回對稱軸
        if (bestScore > SYMMETRY_PASS_SCORE) {
          console.log(`[智能偵測] 找到對稱軸 X=${bestAxis.toFixed(3)}, 對稱分數: ${(bestScore * 100).toFixed(1)}% (及格門檻: ${(SYMMETRY_PASS_SCORE * 100).toFixed(0)}%)`);
          return bestAxis;
        }

        console.log(`[智能偵測] 未找到明顯對稱結構 (最高分數: ${(bestScore * 100).toFixed(1)}%, 及格門檻: ${(SYMMETRY_PASS_SCORE * 100).toFixed(0)}%)`);
        return null;
      }

      /**
       * 計算一組梁的精確邊界和形心
       */
      function getComponentBounds(component, joints) {
        if (!component || component.length === 0) return null;
        let minX = Infinity,
          maxX = -Infinity,
          minY = Infinity,
          maxY = -Infinity;
        const uniquePoints = new Set();
        component.forEach((beam) => {
          const p1 = joints[beam.joint1];
          const p2 = joints[beam.joint2];
          if (p1) uniquePoints.add(p1);
          if (p2) uniquePoints.add(p2);
        });
        if (uniquePoints.size === 0) return null;
        uniquePoints.forEach((p) => {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        });
        return { minX, maxX, minY, maxY };
      }

      /**
       * 鏡像反射一個點
       */
      function mirrorPoint(point, axisX) {
        return { x: 2 * axisX - point.x, y: point.y };
      }

      /**
       * 判斷梁是否在對稱軸上或跨越對稱軸
       * @param {Object} beam - 梁對象
       * @param {Object} joints - 節點座標對象
       * @param {number} axisX - 對稱軸 X 座標
       * @param {number} tolerance - 容許誤差
       * @returns {boolean}
       */
      function isBeamOnSymmetryAxis(beam, joints, axisX, tolerance) {
        const p1 = joints[beam.joint1];
        const p2 = joints[beam.joint2];
        if (!p1 || !p2) return false;

        // 計算梁的中點 X 座標
        const midX = (p1.x + p2.x) / 2;

        // 方法 1: 梁的中點在對稱軸上（容許誤差範圍內）
        if (Math.abs(midX - axisX) < tolerance) {
          return true;
        }

        // 方法 2: 梁的兩個端點分別在對稱軸兩側（跨越對稱軸）
        const p1DistFromAxis = p1.x - axisX;
        const p2DistFromAxis = p2.x - axisX;

        // 如果兩個端點在軸的不同側（一個正一個負），且都不在容許範圍內
        if (
          Math.abs(p1DistFromAxis) > tolerance &&
          Math.abs(p2DistFromAxis) > tolerance &&
          p1DistFromAxis * p2DistFromAxis < 0
        ) {
          return true;
        }

        // 方法 3: 任一端點恰好在對稱軸上
        if (
          Math.abs(p1DistFromAxis) < tolerance ||
          Math.abs(p2DistFromAxis) < tolerance
        ) {
          return true;
        }

        return false;
      }

      /**
       * 小梁編號核心函式 (優化版 - 正確處理對稱軸上的梁)
       */
      function generateSecondaryBeamLabels(
        secondaryBeamsToNumber,
        mainBeamsInStory,
        joints,
        prefix,
        globalSymmetryAxisX = null,
        reservedSerials = new Set(), // [新增] 預留的序號
        grids = { x: [], y: [], coordSystems: {} }, // [新增] 格線資料以支援座標系統判斷
      ) {
        const allLabels = new Map();
        const useMirrorMode =
          document.getElementById("mirrorModeToggle").checked;

        const coreNumberingEngine = (beamsToNumber, startCounter = 1) => {
          // ... (這段循序編號函式維持不變) ...
          const labels = new Map();
          let counter = startCounter;
          const beamsWithData = beamsToNumber
            .map((b) => {
              const j1_coords = joints[b.joint1],
                j2_coords = joints[b.joint2];
              if (!j1_coords || !j2_coords) return null;

              // [修改] 使用座標系統來判斷梁的方向
              const beamData = { j1: j1_coords, j2: j2_coords, name: b.name, joint1: b.joint1, joint2: b.joint2 };
              const bestCoordSystem = findBestCoordSystemForBeam(beamData, grids);
              const orientation = getBeamOrientationInCoordSystem(beamData, bestCoordSystem, grids);

              let startJointName = b.joint1,
                endJointName = b.joint2;
              if (orientation.isHorizontal && j1_coords.x > j2_coords.x) {
                [startJointName, endJointName] = [b.joint2, b.joint1];
              }
              if (orientation.isVertical && j1_coords.y > j2_coords.y) {
                [startJointName, endJointName] = [b.joint2, b.joint1];
              }
              return {
                ...b,
                startJointName,
                endJointName,
                isHorizontal: orientation.isHorizontal,
                isVertical: orientation.isVertical,
                isDiagonal: orientation.isDiagonal,
                coordSystem: bestCoordSystem, // 記錄所屬座標系統
              };
            })
            .filter(Boolean);
          const processed = new Set();
          const beamGroups = [
            beamsWithData
              .filter((b) => b.isHorizontal)
              .sort(
                (a, b) =>
                  joints[a.startJointName].y - joints[b.startJointName].y ||
                  joints[a.startJointName].x - joints[b.startJointName].x,
              ),
            beamsWithData
              .filter((b) => b.isVertical)
              .sort(
                (a, b) =>
                  joints[a.startJointName].x - joints[b.startJointName].x ||
                  joints[a.startJointName].y - joints[b.startJointName].y,
              ),
          ];

          // [修改] 真正的斜向小梁（不對齊任何座標系統）- 標記為未編號
          const diagonalBeams = beamsWithData.filter((b) => b.isDiagonal);
          diagonalBeams.forEach((beam) => {
            const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
            console.log(`[跳過小梁] ${beam.name} 無法對齊任何座標系統的軸向`);
            labels.set(beamKey, {
              newLabel: `${prefix.toUpperCase()}未編號`, // 顯示為「未編號」
              isDiagonal: true, // 標記為斜向梁
            });
          });
          let isVerticalRun = false;
          beamGroups.forEach((group) => {
            if (isVerticalRun && counter > 1) {
              const lastNum = counter - 1;
              counter =
                lastNum % 10 === 0
                  ? lastNum + 1
                  : Math.ceil(lastNum / 10) * 10 + 1;
            }
            for (const startBeam of group) {
              const startKey = `${startBeam.name}|${startBeam.joint1}|${startBeam.joint2}`;
              if (processed.has(startKey)) continue;
              let chain = [startBeam];
              processed.add(startKey);
              let currentLink = startBeam;
              while (true) {
                const nextLink = group.find((b) => {
                  const nextKey = `${b.name}|${b.joint1}|${b.joint2}`;
                  return (
                    !processed.has(nextKey) &&
                    b.startJointName === currentLink.endJointName
                  );
                });
                if (nextLink) {
                  chain.push(nextLink);
                  processed.add(
                    `${nextLink.name}|${nextLink.joint1}|${nextLink.joint2}`,
                  );
                  currentLink = nextLink;
                } else {
                  break;
                }
              }
              // [新增] 跳過預留的序號（使用 "前綴:序號" 格式，如 "b:1"）
              while (reservedSerials.has(`${prefix.toLowerCase()}:${counter}`)) {
                counter++;
              }

              if (chain.length > 1) {
                chain.forEach((beam, index) => {
                  labels.set(`${beam.name}|${beam.joint1}|${beam.joint2}`, {
                    newLabel: `${prefix}${counter}-${index + 1}`,
                  });
                });
              } else {
                labels.set(
                  `${chain[0].name}|${chain[0].joint1}|${chain[0].joint2}`,
                  { newLabel: `${prefix}${counter}` },
                );
              }
              counter++;
            }
            isVerticalRun = true;
          });
          return { labels, nextCounter: counter };
        };

        const allBeamsOnStory = [
          ...secondaryBeamsToNumber,
          ...mainBeamsInStory,
        ];
        const componentsRaw = findBuildingComponents(allBeamsOnStory, joints, useMirrorMode, globalSymmetryAxisX)
          .map((comp) =>
            comp.filter((b) =>
              secondaryBeamsToNumber.some((sb) => sb.name === b.name),
            ),
          )
          .filter((comp) => comp.length > 0);

        if (componentsRaw.length === 0) return allLabels;

        const components = componentsRaw
          .map((comp) => ({
            component: comp,
            bounds: getComponentBounds(comp, joints),
          }))
          .sort((a, b) => a.bounds.minX - b.bounds.minX);

        if (!useMirrorMode || components.length < 2) {
          let globalCounter = 1;
          for (const comp of components) {
            const { labels, nextCounter } = coreNumberingEngine(
              comp.component,
              globalCounter,
            );
            labels.forEach((value, key) => allLabels.set(key, value));
            globalCounter = nextCounter;
          }
        } else {
          // ========== 鏡像對稱模式（優化版） ==========
          const master = components[0];
          const slave = components[1];

          // 步驟 1: 使用全域對稱軸，如果沒有則回退到當前樓層計算
          let axisX = globalSymmetryAxisX;
          if (axisX === null) {
            axisX = (master.bounds.maxX + slave.bounds.minX) / 2;
            console.log(`=============================================`);
            console.log(`[鏡像模式 - ${secondaryBeamsToNumber[0]?.story || '未知樓層'}] 使用當前樓層計算對稱軸 X = ${axisX.toFixed(3)}`);
          } else {
            console.log(`=============================================`);
            console.log(`[鏡像模式 - ${secondaryBeamsToNumber[0]?.story || '未知樓層'}] 使用全域對稱軸 X = ${axisX.toFixed(3)} ✓`);
          }
          console.log(`=============================================`);

          // [新增] 取得當前樓層名稱（用於 console log）
          const currentFloor = secondaryBeamsToNumber[0]?.story || '未知樓層';

          // 步驟 2: 識別對稱軸上的梁 - [修復] 同時檢查 master 和 slave 兩邊
          const beamsOnAxis = [];
          const masterBeamsNotOnAxis = [];
          const slaveBeamsToMirror = [];

          // 檢查 master 的梁
          master.component.forEach((beam) => {
            if (isBeamOnSymmetryAxis(beam, joints, axisX, SYMMETRY_TOLERANCE)) {
              beamsOnAxis.push(beam);
              console.log(
                `[對稱軸梁 - ${currentFloor}] ${beam.name} (from master) 位於對稱軸上`,
              );
            } else {
              masterBeamsNotOnAxis.push(beam);
            }
          });

          // 檢查 slave 的梁
          slave.component.forEach((beam) => {
            if (isBeamOnSymmetryAxis(beam, joints, axisX, SYMMETRY_TOLERANCE)) {
              beamsOnAxis.push(beam);
              console.log(
                `[對稱軸梁 - ${currentFloor}] ${beam.name} (from slave) 位於對稱軸上`,
              );
            } else {
              slaveBeamsToMirror.push(beam);
            }
          });

          // 步驟 3: 對稱軸梁 + master 非對稱軸梁 = master 編號範圍
          const masterWithAxisBeams = [...masterBeamsNotOnAxis, ...beamsOnAxis];
          console.log(
            `\n[Master 範圍 - ${currentFloor}] 原始梁數: ${master.component.length}, 對稱軸梁: ${beamsOnAxis.length}, 總計: ${masterWithAxisBeams.length}`,
          );

          // 步驟 4: 對 master（含對稱軸梁）統一編號
          const { labels: masterLabels, nextCounter } = coreNumberingEngine(
            masterWithAxisBeams,
            1,
          );
          masterLabels.forEach((value, key) => allLabels.set(key, value));

          console.log(`\n[Master 編號完成 - ${currentFloor}] 共編 ${masterLabels.size} 根小梁`);

          // 步驟 5: 識別哪些 master 梁需要進行鏡像配對（排除對稱軸上的梁）
          const masterBeamsToMirror = master.component.filter(
            (beam) =>
              !isBeamOnSymmetryAxis(beam, joints, axisX, SYMMETRY_TOLERANCE),
          );

          console.log(
            `\n[鏡像配對 - ${currentFloor}] 需配對的 master 梁: ${masterBeamsToMirror.length}, slave 梁: ${slaveBeamsToMirror.length}`,
          );

          // 步驟 6: 進行鏡像配對（使用匈牙利算法思想，確保一對一配對）
          const matchedSlaves = new Set(); // 追蹤已配對的 slave 梁

          masterBeamsToMirror.forEach((masterBeam) => {
            const masterKey = `${masterBeam.name}|${masterBeam.joint1}|${masterBeam.joint2}`;
            const labelInfo = masterLabels.get(masterKey);
            if (!labelInfo) return;

            const master_p1 = joints[masterBeam.joint1];
            const master_p2 = joints[masterBeam.joint2];
            const masterMidpoint = {
              x: (master_p1.x + master_p2.x) / 2,
              y: (master_p1.y + master_p2.y) / 2,
            };
            const masterLength = distance(master_p1, master_p2);

            // [新增] 判斷 master 梁的方向
            const masterIsHorizontal = Math.abs(master_p1.y - master_p2.y) < DIRECTION_TOLERANCE;
            const masterIsVertical = Math.abs(master_p1.x - master_p2.x) < DIRECTION_TOLERANCE;

            const mirroredMidpoint = mirrorPoint(masterMidpoint, axisX);

            // 在 slave 中尋找最佳匹配（排除已配對的）
            let bestMatch = null;
            let bestScore = Infinity;

            slaveBeamsToMirror.forEach((slaveBeam) => {
              const slaveKey = `${slaveBeam.name}|${slaveBeam.joint1}|${slaveBeam.joint2}`;

              // 跳過已配對的 slave 梁
              if (matchedSlaves.has(slaveKey)) return;

              const slave_p1 = joints[slaveBeam.joint1];
              const slave_p2 = joints[slaveBeam.joint2];
              if (!slave_p1 || !slave_p2) return;

              // [新增] 判斷 slave 梁的方向
              const slaveIsHorizontal = Math.abs(slave_p1.y - slave_p2.y) < DIRECTION_TOLERANCE;
              const slaveIsVertical = Math.abs(slave_p1.x - slave_p2.x) < DIRECTION_TOLERANCE;

              // [新增] 只有同方向的梁才能配對
              if (masterIsHorizontal !== slaveIsHorizontal || masterIsVertical !== slaveIsVertical) {
                return;
              }

              const slaveMidpoint = {
                x: (slave_p1.x + slave_p2.x) / 2,
                y: (slave_p1.y + slave_p2.y) / 2,
              };
              const slaveLength = distance(slave_p1, slave_p2);

              const midDist = distance(slaveMidpoint, mirroredMidpoint);
              const lenDiff = Math.abs(slaveLength - masterLength);
              const yDiff = Math.abs(slaveMidpoint.y - masterMidpoint.y); // Y 座標應該相同

              // 計算配對分數（距離越小越好，長度差異也要考慮）
              const score = midDist + lenDiff * 0.5;

              // [修改] 更嚴格的配對條件
              // 1. Y 座標差異必須小於容許誤差（對稱梁 Y 應該相同）
              // 2. 中點距離必須小於 MATCHING_TOLERANCE
              // 3. 長度相近（容許 ±15% 或 ±0.5m）
              const lenTolerance = Math.max(masterLength * 0.15, 0.5);
              if (yDiff < MATCHING_TOLERANCE &&
                  midDist < MATCHING_TOLERANCE * 2 &&
                  lenDiff < lenTolerance &&
                  score < bestScore) {
                bestMatch = slaveBeam;
                bestScore = score;
              }
            });

            // 如果找到配對，賦予相同編號
            if (bestMatch) {
              const slaveKey = `${bestMatch.name}|${bestMatch.joint1}|${bestMatch.joint2}`;
              console.log(
                `[配對成功] ${labelInfo.newLabel}: ${masterBeam.name} ↔ ${bestMatch.name}`,
              );
              allLabels.set(slaveKey, { newLabel: labelInfo.newLabel });
              matchedSlaves.add(slaveKey); // 標記為已配對
            } else {
              // [增強] 顯示為什麼配對失敗
              console.log(
                `[配對失敗 - ${currentFloor}] ${labelInfo.newLabel}: ${masterBeam.name} (中點: ${masterMidpoint.x.toFixed(2)}, ${masterMidpoint.y.toFixed(2)})`,
              );
              console.log(
                `  → 鏡像目標位置: (${mirroredMidpoint.x.toFixed(2)}, ${mirroredMidpoint.y.toFixed(2)})`,
              );

              // 顯示最接近的 slave 梁資訊
              let closestBeam = null;
              let closestDist = Infinity;
              slaveBeamsToMirror.forEach((slaveBeam) => {
                const slave_p1 = joints[slaveBeam.joint1];
                const slave_p2 = joints[slaveBeam.joint2];
                if (!slave_p1 || !slave_p2) return;
                const slaveMidpoint = {
                  x: (slave_p1.x + slave_p2.x) / 2,
                  y: (slave_p1.y + slave_p2.y) / 2,
                };
                const midDist = distance(slaveMidpoint, mirroredMidpoint);
                if (midDist < closestDist) {
                  closestDist = midDist;
                  closestBeam = { beam: slaveBeam, midpoint: slaveMidpoint };
                }
              });

              if (closestBeam) {
                console.log(
                  `  → 最近的 slave: ${closestBeam.beam.name} (中點: ${closestBeam.midpoint.x.toFixed(2)}, ${closestBeam.midpoint.y.toFixed(2)}, 距離: ${closestDist.toFixed(3)}m)`,
                );
              } else {
                console.log(`  → 沒有任何 slave 梁可配對`);
              }
            }
          });

          // 步驟 7: 處理未配對的 slave 梁（如果有）
          const unmatchedSlaveBeams = slaveBeamsToMirror.filter((beam) => {
            const key = `${beam.name}|${beam.joint1}|${beam.joint2}`;
            return !allLabels.has(key);
          });

          let orphanCounter = nextCounter;

          if (unmatchedSlaveBeams.length > 0) {
            console.log(
              `\n[未配對 Slave 梁] 共 ${unmatchedSlaveBeams.length} 根，從 ${prefix}${orphanCounter} 開始編號`,
            );
            const { labels: unmatchedLabels, nextCounter: updatedCounter } =
              coreNumberingEngine(unmatchedSlaveBeams, orphanCounter);
            unmatchedLabels.forEach((value, key) => allLabels.set(key, value));
            orphanCounter = updatedCounter;
          }

          // 步驟 8: 處理第三個及以後的 component（如果有）
          if (components.length > 2) {
            console.log(
              `\n[其他 Component] 處理額外的 ${
                components.length - 2
              } 個建築群組`,
            );
            for (let i = 2; i < components.length; i++) {
              const { labels, nextCounter: updatedCounter } =
                coreNumberingEngine(components[i].component, orphanCounter);
              labels.forEach((value, key) => allLabels.set(key, value));
              orphanCounter = updatedCounter;
            }
          }

          console.log(`\n[鏡像模式完成 - ${currentFloor}] 總共編號 ${allLabels.size} 根小梁`);
          console.log(`=============================================\n`);
        }

        return allLabels;
      }
      function findBuildingComponents(allBeamsOnStory, joints, useMirrorMode = false, globalSymmetryAxisX = null) {
        if (!allBeamsOnStory || allBeamsOnStory.length === 0) return [];

        const GEOMETRIC_TOLERANCE = 0.01;
        const components = [];
        const processedBeams = new Set();

        const beamsWithCoords = allBeamsOnStory
          .map((b) => ({
            ...b,
            p1: joints[b.joint1],
            p2: joints[b.joint2],
          }))
          .filter((b) => b.p1 && b.p2);

        function areBeamsConnected(beamA, beamB) {
          if (distance(beamA.p1, beamB.p1) < GEOMETRIC_TOLERANCE) return true;
          if (distance(beamA.p1, beamB.p2) < GEOMETRIC_TOLERANCE) return true;
          if (distance(beamA.p2, beamB.p1) < GEOMETRIC_TOLERANCE) return true;
          if (distance(beamA.p2, beamB.p2) < GEOMETRIC_TOLERANCE) return true;
          if (
            isPointOnSegment(beamA.p1, beamB.p1, beamB.p2, GEOMETRIC_TOLERANCE)
          )
            return true;
          if (
            isPointOnSegment(beamA.p2, beamB.p1, beamB.p2, GEOMETRIC_TOLERANCE)
          )
            return true;
          if (
            isPointOnSegment(beamB.p1, beamA.p1, beamA.p2, GEOMETRIC_TOLERANCE)
          )
            return true;
          if (
            isPointOnSegment(beamB.p2, beamA.p1, beamA.p2, GEOMETRIC_TOLERANCE)
          )
            return true;
          return false;
        }

        for (const startBeam of beamsWithCoords) {
          if (processedBeams.has(startBeam.name)) {
            continue;
          }

          const currentComponent = [];
          const q = [startBeam];
          processedBeams.add(startBeam.name);

          while (q.length > 0) {
            const currentBeam = q.shift();
            currentComponent.push(currentBeam);

            for (const otherBeam of beamsWithCoords) {
              if (processedBeams.has(otherBeam.name)) {
                continue;
              }
              if (areBeamsConnected(currentBeam, otherBeam)) {
                processedBeams.add(otherBeam.name);
                q.push(otherBeam);
              }
            }
          }

          if (currentComponent.length > 0) {
            components.push(currentComponent);
          }
        }

        // [修復] 鏡像模式下，無論有幾個 component，都要按對稱軸重新分組
        // 原本只在 components.length === 1 時才分割，導致多區域建築無法正確配對
        if (useMirrorMode && beamsWithCoords.length > 0) {
          console.log(`\n[分群模式] 鏡像模式啟用，按對稱軸重新分組 (原始 components: ${components.length})`);

          // 合併所有 components 的梁
          const allBeamsFlattened = components.flat();

          // 使用全域對稱軸，如果沒有則回退到當前樓層計算
          let symmetryAxisX = globalSymmetryAxisX;
          if (symmetryAxisX === null) {
            const allXCoords = [];
            allBeamsFlattened.forEach((b) => {
              allXCoords.push(b.p1.x, b.p2.x);
            });
            const minX = Math.min(...allXCoords);
            const maxX = Math.max(...allXCoords);
            symmetryAxisX = (minX + maxX) / 2;
            console.log(`[分群模式] 使用當前樓層計算對稱軸 X ≈ ${symmetryAxisX.toFixed(3)}`);
          } else {
            console.log(`[分群模式] 使用全域對稱軸 X = ${symmetryAxisX.toFixed(3)} ✓`);
          }

          // 根據梁的中點 X 座標分成左、中、右
          const leftBeams = [];
          const centerBeams = [];
          const rightBeams = [];

          allBeamsFlattened.forEach((beam) => {
            const midX = (beam.p1.x + beam.p2.x) / 2;
            const distFromAxis = Math.abs(midX - symmetryAxisX);

            if (distFromAxis < SYMMETRY_TOLERANCE) {
              centerBeams.push(beam);
            } else if (midX < symmetryAxisX) {
              leftBeams.push(beam);
            } else {
              rightBeams.push(beam);
            }
          });

          console.log(`[分群結果] 左側: ${leftBeams.length}, 中央: ${centerBeams.length}, 右側: ${rightBeams.length}`);

          // 重新組裝 components（對稱軸梁暫時歸入左側，後續由鏡像邏輯處理）
          const newComponents = [];
          if (leftBeams.length > 0 || centerBeams.length > 0) {
            newComponents.push([...leftBeams, ...centerBeams]);
          }
          if (rightBeams.length > 0) {
            newComponents.push(rightBeams);
          }

          console.log(`[分群模式] 重新分組完成，產生 ${newComponents.length} 個 component`);
          return newComponents;
        }

        console.log(`[分群結果] 找到 ${components.length} 個建築 component`);
        return components;
      }
      // =================================================================
      // ### 全新鏡像演算法 v4 (最終版，依使用者思路)：結束 ###
      // =================================================================

      function applySpecialPrefixRules(allBeams) {
        const processPrefix = (prefix) => {
          const targetBeams = allBeams.filter(
            (b) => b.prop && b.prop.toUpperCase().startsWith(prefix),
          );
          if (targetBeams.length === 0) return null;
          const uniqueProps = [...new Set(targetBeams.map((b) => b.prop))];
          const propRanks = uniqueProps
            .map((prop) => {
              const match = prop.match(/(\d+)[xX](\d+)/);
              if (match) {
                return {
                  propName: prop,
                  area: parseInt(match[1], 10) * parseInt(match[2], 10),
                };
              }
              return {
                propName: prop,
                area: Infinity,
              };
            })
            .sort((a, b) => a.area - b.area);
          const propToLabelMap = new Map();
          propRanks.forEach((propInfo, index) => {
            propToLabelMap.set(propInfo.propName, `${prefix}${index + 1}`);
          });
          return propToLabelMap;
        };
        const wbLabelMap = processPrefix("WB");
        const fwbLabelMap = processPrefix("FWB");
        return allBeams.map((beam) => {
          if (wbLabelMap && wbLabelMap.has(beam.prop)) {
            return { ...beam, newLabel: wbLabelMap.get(beam.prop) };
          }
          if (fwbLabelMap && fwbLabelMap.has(beam.prop)) {
            return { ...beam, newLabel: fwbLabelMap.get(beam.prop) };
          }
          return beam;
        });
      }

      function generateFloorFingerprint(story, allBeams, precision = 2) {
        const beamsOnStory = allBeams.filter((b) => b.story === story);
        if (beamsOnStory.length === 0) {
          return "";
        }

        const beamSignatures = beamsOnStory
          .map((beam) => {
            if (!beam.j1 || !beam.j2) return "";

            const x1 = beam.j1.x.toFixed(precision);
            const y1 = beam.j1.y.toFixed(precision);
            const x2 = beam.j2.x.toFixed(precision);
            const y2 = beam.j2.y.toFixed(precision);

            const point1Str = `${x1},${y1}`;
            const point2Str = `${x2},${y2}`;

            return point1Str < point2Str
              ? `${point1Str}|${point2Str}`
              : `${point2Str}|${point1Str}`;
          })
          .filter(Boolean);

        return beamSignatures.sort().join(";");
      }

      function createStandardFloorGroups() {
        if (availableStories.length === 0) return [];

        const sortedStories = [...availableStories].sort(
          (a, b) => storyOrderInfo[a] - storyOrderInfo[b],
        );

        const fingerprints = sortedStories.map((story) => ({
          story,
          fingerprint: generateFloorFingerprint(story, fullDrawableBeams, 2),
        }));

        if (fingerprints.length === 0) return [];

        const groups = [];
        let currentGroup = [fingerprints[0].story];

        for (let i = 1; i < fingerprints.length; i++) {
          if (
            fingerprints[i].fingerprint === fingerprints[i - 1].fingerprint &&
            fingerprints[i].fingerprint !== ""
          ) {
            currentGroup.push(fingerprints[i].story);
          } else {
            groups.push(currentGroup);
            currentGroup = [fingerprints[i].story];
          }
        }
        groups.push(currentGroup);

        return groups;
      }

      // [新增] 取得某樓層所屬的標準層群組
      function getStandardFloorGroupForStory(story) {
        if (!standardFloorGroupsCache) {
          standardFloorGroupsCache = createStandardFloorGroups();
        }
        return standardFloorGroupsCache.find(group => group.includes(story)) || null;
      }

      // [新增] 找出所有標準層中相同位置的梁
      function findBeamsAtSamePosition(beam, floors) {
        const results = [];

        // 從 fullDrawableBeams 找到當前梁的座標資訊
        const currentDrawableBeam = fullDrawableBeams.find(b =>
          b.story === beam.story && b.name === beam.name
        );

        if (!currentDrawableBeam || !currentDrawableBeam.j1 || !currentDrawableBeam.j2) {
          console.log('[連動標準層] 找不到當前梁的座標資訊', beam.story, beam.name);
          return results;
        }

        const j1 = currentDrawableBeam.j1;
        const j2 = currentDrawableBeam.j2;
        console.log(`[連動標準層] 當前梁座標: j1=(${j1.x}, ${j1.y}), j2=(${j2.x}, ${j2.y})`);

        floors.forEach(floorName => {
          if (floorName === beam.story) return; // 跳過當前樓層

          // 在 fullDrawableBeams 中找到同位置的梁
          const matchingDrawableBeam = fullDrawableBeams.find(b =>
            b.story === floorName &&
            b.j1 && b.j2 &&
            b.j1.x === j1.x && b.j1.y === j1.y &&
            b.j2.x === j2.x && b.j2.y === j2.y
          );

          if (matchingDrawableBeam) {
            // 在 fullProcessedBeams 中找到對應的梁物件
            const matchingProcessedBeam = fullProcessedBeams.find(b =>
              b.story === floorName && b.name === matchingDrawableBeam.name
            );

            if (matchingProcessedBeam) {
              console.log(`[連動標準層] 找到匹配: ${floorName} ${matchingProcessedBeam.name} -> ${matchingProcessedBeam.newLabel}`);
              results.push(matchingProcessedBeam);
            }
          }
        });

        return results;
      }

      // [新增] 清除標準層群組快取
      function invalidateStandardFloorGroupsCache() {
        standardFloorGroupsCache = null;
      }

      function exportToJSON() {
        if (fullProcessedBeams.length === 0) {
          alert("沒有可匯出的資料。");
          return;
        }
        if (!previewJoints) {
          alert("無法取得座標資訊，請確認已載入 E2K 檔案。");
          return;
        }

        const outputData = {
          project: "ETABS梁編號專案",
          exportDate: new Date().toISOString(),
          floors: [],
        };

        // 依樓層分組
        const floorGroups = new Map();
        fullProcessedBeams.forEach((beam) => {
          if (!floorGroups.has(beam.story)) {
            floorGroups.set(beam.story, []);
          }
          floorGroups.get(beam.story).push(beam);
        });

        // 為每個樓層生成資料
        floorGroups.forEach((beams, floorName) => {
          const floorData = {
            floorName: floorName,
            beams: [],
          };

          beams.forEach((beam) => {
            const j1 = previewJoints[beam.joint1];
            const j2 = previewJoints[beam.joint2];

            if (!j1 || !j2) return;

            floorData.beams.push({
              etabsId: beam.name,
              newLabel: beam.newLabel,
              startPoint: {
                id: beam.joint1,
                x: j1.x,
                y: j1.y,
              },
              endPoint: {
                id: beam.joint2,
                x: j2.x,
                y: j2.y,
              },
              midPoint: {
                x: (j1.x + j2.x) / 2,
                y: (j1.y + j2.y) / 2,
              },
              length: Math.sqrt(
                Math.pow(j2.x - j1.x, 2) + Math.pow(j2.y - j1.y, 2),
              ),
              section: beam.prop || "",
              isMainBeam:
                !beam.newLabel.toLowerCase().startsWith("b") &&
                !beam.newLabel.toLowerCase().startsWith("fb"),
            });
          });

          outputData.floors.push(floorData);
        });

        // 下載 JSON 檔案
        const jsonStr = JSON.stringify(outputData, null, 2);
        const blob = new Blob([jsonStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "ETABS_梁座標資料_AutoCAD.json";
        link.click();
        URL.revokeObjectURL(url);
      }

      // 計算梁與軸線的相對位置關係
      function calculateGridRelation(beam, joints, grids) {
        const j1 = joints[beam.joint1];
        const j2 = joints[beam.joint2];
        if (!j1 || !j2) return null;

        const tolerance = 0.1; // 容許誤差 0.1 公尺

        // 判斷梁的方向
        const deltaX = Math.abs(j2.x - j1.x);
        const deltaY = Math.abs(j2.y - j1.y);
        const isHorizontal = deltaX > deltaY;

        if (isHorizontal) {
          // 水平梁：沿著某條 Y 軸線，在兩條 X 軸線之間
          // 找到最接近的 Y 軸線
          const avgY = (j1.y + j2.y) / 2;
          const closestYGrid = grids.y.reduce((prev, curr) => {
            return Math.abs(curr.ordinate - avgY) <
              Math.abs(prev.ordinate - avgY)
              ? curr
              : prev;
          });

          // 找到梁跨越的 X 軸線
          const minX = Math.min(j1.x, j2.x);
          const maxX = Math.max(j1.x, j2.x);
          const betweenX = grids.x
            .filter(
              (g) =>
                g.ordinate >= minX - tolerance &&
                g.ordinate <= maxX + tolerance,
            )
            .sort((a, b) => a.ordinate - b.ordinate);

          if (betweenX.length >= 2) {
            return {
              alongGrid: closestYGrid.name,
              between: [betweenX[0].name, betweenX[betweenX.length - 1].name],
              direction: "horizontal",
              offsetFromStart: Math.abs(avgY - closestYGrid.ordinate),
              length: deltaX,
            };
          }
        } else {
          // 垂直梁：沿著某條 X 軸線，在兩條 Y 軸線之間
          const avgX = (j1.x + j2.x) / 2;
          const closestXGrid = grids.x.reduce((prev, curr) => {
            return Math.abs(curr.ordinate - avgX) <
              Math.abs(prev.ordinate - avgX)
              ? curr
              : prev;
          });

          const minY = Math.min(j1.y, j2.y);
          const maxY = Math.max(j1.y, j2.y);
          const betweenY = grids.y
            .filter(
              (g) =>
                g.ordinate >= minY - tolerance &&
                g.ordinate <= maxY + tolerance,
            )
            .sort((a, b) => a.ordinate - b.ordinate);

          if (betweenY.length >= 2) {
            return {
              alongGrid: closestXGrid.name,
              between: [betweenY[0].name, betweenY[betweenY.length - 1].name],
              direction: "vertical",
              offsetFromStart: Math.abs(avgX - closestXGrid.ordinate),
              length: deltaY,
            };
          }
        }

        return null;
      }

      // V2 版本：基於軸線相對位置的 CSV 匯出
      function exportToJSONV2() {
        if (fullProcessedBeams.length === 0) {
          alert("沒有可匯出的資料。");
          return;
        }
        if (!previewJoints || !gridData) {
          alert("無法取得座標或軸線資訊，請確認已載入 E2K 檔案。");
          return;
        }

        // 準備 CSV 資料
        const csvRows = [];

        // CSV 標題行
        csvRows.push([
          "樓層",
          "ETABS編號",
          "新編號",
          "沿軸線",
          "起始軸線",
          "結束軸線",
          "方向",
          "偏移量",
          "長度",
          "斷面",
          "是否為大梁"
        ].join(","));

        // 依樓層分組
        const floorGroups = new Map();
        fullProcessedBeams.forEach((beam) => {
          if (!floorGroups.has(beam.story)) {
            floorGroups.set(beam.story, []);
          }
          floorGroups.get(beam.story).push(beam);
        });

        // 為每個樓層生成資料
        floorGroups.forEach((beams, floorName) => {
          beams.forEach((beam) => {
            const gridRelation = calculateGridRelation(
              beam,
              previewJoints,
              gridData,
            );

            if (gridRelation) {
              // [修改] 判斷是否為大梁
              let isMainBeam = true;
              if (beam.isFixedLabel) {
                // 如果是固定編號梁，使用 isSecondaryBeam 標記
                isMainBeam = !beam.isSecondaryBeam;
              } else {
                // 大梁：G, B, FB, FG, FWB, WB 開頭（大寫）
                // 小梁：b 開頭（小寫）
                // 只要第一個字母是小寫 b，就是小梁；其他都是大梁
                isMainBeam = beam.newLabel.charAt(0) !== 'b';
              }

              // 將資料加入 CSV 行
              csvRows.push([
                floorName,
                beam.name,
                beam.newLabel,
                gridRelation.alongGrid,
                gridRelation.between[0],
                gridRelation.between[1],
                gridRelation.direction === "horizontal" ? "水平" : "垂直",
                gridRelation.offsetFromStart.toFixed(3),
                gridRelation.length.toFixed(3),
                beam.prop || "",
                isMainBeam ? "是" : "否"
              ].join(","));
            }
          });
        });

        // 下載 CSV 檔案
        const csvContent = csvRows.join("\n");
        const blob = new Blob(["\uFEFF" + csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "ETABS_梁編號_AutoCAD.csv";
        link.click();
        URL.revokeObjectURL(url);
      }

      function exportToExcel() {
        if (fullProcessedBeams.length === 0) {
          alert("沒有可匯出的資料。");
          return;
        }

        const standardFloorGroups = createStandardFloorGroups();
        const preppedData = [];

        for (const group of standardFloorGroups) {
          const beamsInGroup = fullProcessedBeams.filter((b) =>
            group.includes(b.story),
          );

          if (group.length === 1) {
            beamsInGroup.forEach((beam) => {
              preppedData.push({
                floor: beam.story,
                etabsLabel: beam.name,
                newLabel: beam.newLabel,
                isFixedLabel: beam.isFixedLabel, // [新增] 保留固定編號標記
                isSecondaryBeam: beam.isSecondaryBeam, // [新增] 保留小梁標記
              });
            });
          } else {
            // [修復] 不要用 newLabel 合併，因為不同的 ETABS 梁可能有相同編號
            // 改為：收集同一組樓層中每個梁的資料，樓層欄位顯示樓層範圍
            const floorString = summarizeFloors(group, storyOrderInfo);

            // 用 ETABS 編號 + 新編號 作為唯一識別
            const uniqueBeamsInGroup = new Map();
            beamsInGroup.forEach((beam) => {
              const key = `${beam.name}|${beam.newLabel}`;
              if (!uniqueBeamsInGroup.has(key)) {
                uniqueBeamsInGroup.set(key, {
                  name: beam.name,
                  newLabel: beam.newLabel,
                  isFixedLabel: beam.isFixedLabel,
                  isSecondaryBeam: beam.isSecondaryBeam,
                });
              }
            });

            uniqueBeamsInGroup.forEach((uniqueBeam) => {
              preppedData.push({
                floor: floorString,
                etabsLabel: uniqueBeam.name,
                newLabel: uniqueBeam.newLabel,
                isFixedLabel: uniqueBeam.isFixedLabel,
                isSecondaryBeam: uniqueBeam.isSecondaryBeam,
              });
            });
          }
        }

        const mainBeamsData = [];
        const secondaryBeamsData = [];

        preppedData.forEach((item) => {
          // [修復] 判斷大小梁：優先使用已設置的 isSecondaryBeam 標記
          let isSecondaryBeam = false;

          if (item.isSecondaryBeam !== undefined) {
            // 如果已經有 isSecondaryBeam 標記（從 beam 對象繼承），直接使用
            isSecondaryBeam = item.isSecondaryBeam;
          } else {
            // 如果沒有標記，從 fullProcessedBeams 中找到對應的梁，使用其 prop 判斷
            const correspondingBeam = fullProcessedBeams.find(
              b => b.name === item.etabsLabel && b.newLabel === item.newLabel
            );

            if (correspondingBeam && correspondingBeam.prop) {
              // 使用 frame section 判斷：包含 SB 或 FSB 的是小梁（支援 4sb、3.5sb 等格式）
              isSecondaryBeam = /(\d+\.?\d*\s*)?(SB|FSB)/i.test(correspondingBeam.prop);
            } else {
              // 如果找不到對應梁或沒有 prop，使用編號作為最後的備選判斷
              // 小梁：b 開頭（小寫）
              isSecondaryBeam = item.newLabel && item.newLabel.charAt(0) === 'b';
            }
          }

          if (isSecondaryBeam) {
            secondaryBeamsData.push({
              ETABS編號: item.etabsLabel,
              編號: item.newLabel,
              樓層: item.floor,
            });
          } else {
            mainBeamsData.push({
              ETABS編號: item.etabsLabel,
              編號: item.newLabel,
              樓層: item.floor,
            });
          }
        });

        const workbook = XLSX.utils.book_new();

        const mainWs = XLSX.utils.json_to_sheet(mainBeamsData);
        XLSX.utils.book_append_sheet(workbook, mainWs, "大梁");

        const secondaryWs = XLSX.utils.json_to_sheet(secondaryBeamsData);
        XLSX.utils.book_append_sheet(workbook, secondaryWs, "小梁");

        XLSX.writeFile(workbook, "ETABS_梁編號_分頁.xlsx");
      }

      function setupSelectWheelListeners() {
        const selectors = document.querySelectorAll(
          "#storySelector, #beamTypeSelector",
        );

        selectors.forEach((select) => {
          select.addEventListener("wheel", (event) => {
            if (select.options.length === 0 || select.disabled) {
              return;
            }
            event.preventDefault();
            const currentIndex = select.selectedIndex;
            let newIndex = currentIndex;
            if (event.deltaY < 0) {
              newIndex = Math.max(0, currentIndex - 1);
            } else {
              newIndex = Math.min(select.options.length - 1, currentIndex + 1);
            }
            if (newIndex !== currentIndex) {
              select.selectedIndex = newIndex;
              select.dispatchEvent(new Event("change"));
            }
          });
        });
      }

      setupSelectWheelListeners();
      // 為 "新編號" 輸入框新增 'keydown' 事件監聽
      document
        .getElementById("edit-new-label")
        .addEventListener("keydown", function (event) {
          // 檢查按下的鍵是否為 Enter (event.key 或 event.keyCode)
          if (event.key === "Enter" || event.keyCode === 13) {
            // 防止預設行為 (例如表單提交)
            event.preventDefault();
            // 呼叫儲存函式
            saveBeamEdit();
          }
        });

      // 檔案選擇時更新檔名顯示並自動預覽
      document
        .getElementById("e2kFile")
        .addEventListener("change", function (event) {
          const fileNameDisplay = document.getElementById("fileName");
          if (event.target.files.length > 0) {
            fileNameDisplay.textContent = event.target.files[0].name;
            // 自動預覽結構
            previewFile();
          } else {
            fileNameDisplay.textContent = "尚未選擇檔案";
          }
        });

        // [新增] 頁面載入時載入固定編號規則
        loadFixedLabelRules();
        // 初始化固定編號摘要顯示
        updateFixedLabelSummary();
        updateFixedLabelButtonState();

      // ============================================
      // 圈选功能實現 (SVG 內部座標系統)
      // ============================================

      // 初始化圈选功能
      function initializeSelectionFeature() {
        svgElement = document.getElementById("drawing-svg");

        if (!svgElement) {
          console.error('SVG 元素未找到');
          return;
        }

        // 移除舊的事件監聽器（如果有）
        svgElement.removeEventListener("mousedown", onSelectionStart);
        svgElement.removeEventListener("mousemove", onSelectionMove);
        svgElement.removeEventListener("mouseup", onSelectionEnd);

        // 添加鼠标事件监听
        svgElement.addEventListener("mousedown", onSelectionStart);
        svgElement.addEventListener("mousemove", onSelectionMove);
        svgElement.addEventListener("mouseup", onSelectionEnd);

        // [新增] 阻止 SVG 區域的預設右鍵菜單（確保自定義右鍵功能正常運作）
        svgElement.addEventListener("contextmenu", (e) => {
          // 如果點擊的不是梁或標籤，搜索最近的梁
          if (e.target.tagName !== 'line' && e.target.tagName !== 'text') {
            e.preventDefault();

            // 搜索點擊位置附近的最近梁（容差範圍：20 像素）
            const nearestBeam = findNearestBeam(e, 20);
            if (nearestBeam) {
              e.stopPropagation();
              showBeamInfo(e, nearestBeam);
            }
          }
          // 如果是梁或標籤，由各自的事件處理器處理
        });

        // 添加键盘事件监听（批量编辑）
        document.removeEventListener("keydown", onKeyDown);
        document.addEventListener("keydown", onKeyDown);

        console.log('✓ 圈選功能已初始化 (SVG 內部座標系統)');
      }

      // 获取 svg-pan-zoom 的 viewport 元素（包含所有內容的 <g> 元素）
      function getViewportElement() {
        // svg-pan-zoom 會將所有內容包裝在一個 <g> 元素中
        // 通常是第一個 <g> 元素
        const viewport = svgElement.querySelector('g');
        return viewport || svgElement; // 如果找不到，fallback 到 SVG 根元素
      }

      // 获取 SVG 內部座標（相對於 viewport，與梁在同一座標系統）
      function getSVGCoords(evt) {
        const svg = svgElement;
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX;
        pt.y = evt.clientY;

        // 獲取 viewport 元素
        const viewport = getViewportElement();

        // 如果有 viewport（svg-pan-zoom 創建的 <g>），使用其 CTM
        // 否則使用 SVG 的 CTM
        const ctm = viewport.getScreenCTM ? viewport.getScreenCTM() : svg.getScreenCTM();

        // 轉換到 viewport 座標系統
        const svgPt = pt.matrixTransform(ctm.inverse());
        return {
          x: svgPt.x,
          y: svgPt.y
        };
      }

      // 开始圈选
      function onSelectionStart(evt) {
        // [新增] 如果正在設定對稱軸，不要啟動選取功能
        if (isAxisClickModeActive) {
          return;  // 讓對稱軸點選功能處理
        }

        // [新增] 如果點擊的是 BUBBLE 相關元素，不要啟動選取功能
        const target = evt.target;
        const targetClass = target.getAttribute('class') || '';
        if (targetClass.includes('grid-bubble') ||
            targetClass.includes('grid-bubble-hitarea') ||
            targetClass.includes('grid-bubble-text') ||
            targetClass.includes('grid-bubble-connector')) {
          console.log("[DEBUG] Clicked on grid bubble element, skip selection");
          return;  // 讓 BUBBLE 的拖曳功能處理
        }

        // 如果点击的是梁或标签，处理单选
        if (evt.target.tagName === 'line' || evt.target.tagName === 'text') {
          // [新增] 如果點擊的是標籤且正在拖動，不要選取
          if (evt.target.tagName === 'text' && evt.target.classList.contains('beam-label')) {
            // 標籤可以被拖動，讓拖動功能處理
            // 選取功能會在 mouseup 時由 handleBeamLabelMouseUp 決定是否選取
            return;
          }

          const beamName = evt.target.dataset.beamName;
          const beamStory = evt.target.dataset.beamStory;
          const beamJoint1 = evt.target.dataset.beamJoint1;
          const beamJoint2 = evt.target.dataset.beamJoint2;
          if (!beamName || !beamStory) return;

          // [修改] 使用唯一的 beamKey
          const beamKey = `${beamStory}|${beamName}|${beamJoint1}|${beamJoint2}`;

          // Shift+Click：取消選擇該梁（從選擇集合中移除）
          if (evt.shiftKey) {
            if (selectedBeams.has(beamKey)) {
              selectedBeams.delete(beamKey);
              updateBeamVisualState(beamKey, false);
            }
            // 如果梁沒有被選中，Shift+點擊不做任何事
            evt.preventDefault();
            evt.stopPropagation();
            return;
          }

          // 普通點擊：累加選擇（不清除現有選擇）
          // 如果梁已經被選中，再次點擊不做任何事（保持選中狀態）
          if (!selectedBeams.has(beamKey)) {
            selectedBeams.add(beamKey);
            updateBeamVisualState(beamKey, true);
          }
          evt.preventDefault();
          evt.stopPropagation();
          return;
        }

        // 點擊空白處：準備開始框選（不需要 Ctrl）
        // 但如果正在拖動 pan-zoom，不要啟動框選
        if (evt.button !== 0) return; // 只處理左鍵

        // 开始框选
        if (panZoomInstance) {
          panZoomInstance.disablePan();
        }

        isSelecting = true;
        selectionStart = getSVGCoords(evt);

        // [新增] 設置 AutoCAD 風格十字線游標
        svgElement.classList.add('autocad-crosshair');

        // 框選時不清除現有選擇，持續累加
        // 使用者可以用 Esc 或 Shift+點擊來取消選擇

        // 清理任何舊的選擇框（防止殘影）
        const oldRects = svgElement.querySelectorAll('.selection-rect, .selection-rect-crossing');
        oldRects.forEach(rect => rect.remove());

        // 创建 SVG 选择框矩形
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("x", selectionStart.x);
        selectionRect.setAttribute("y", selectionStart.y);
        selectionRect.setAttribute("width", 0);
        selectionRect.setAttribute("height", 0);
        selectionRect.setAttribute("class", "selection-rect");
        selectionRect.setAttribute("pointer-events", "none");

        // 將選擇框添加到 viewport（與梁在同一座標系統）
        const viewport = getViewportElement();
        viewport.appendChild(selectionRect);

        console.log('開始框選 at viewport coords:', selectionStart);

        evt.preventDefault();
        evt.stopPropagation();
      }

      // [優化] 用於 requestAnimationFrame 節流
      let selectionAnimationFrameId = null;
      let pendingSelectionEvent = null;

      // 拖动圈选
      function onSelectionMove(evt) {
        if (!isSelecting || !selectionRect) return;

        // [優化] 使用 requestAnimationFrame 節流，提高拖拽流暢度
        pendingSelectionEvent = evt;
        if (!selectionAnimationFrameId) {
          selectionAnimationFrameId = requestAnimationFrame(updateSelectionRect);
        }
      }

      // [優化] 獨立的選擇框更新函數
      function updateSelectionRect() {
        selectionAnimationFrameId = null;
        if (!isSelecting || !selectionRect || !pendingSelectionEvent) return;

        const currentPoint = getSVGCoords(pendingSelectionEvent);
        const width = currentPoint.x - selectionStart.x;
        const height = currentPoint.y - selectionStart.y;

        // 判斷選擇模式
        const isCrossingMode = width < 0;

        // 更新選擇框樣式
        selectionRect.setAttribute("class", isCrossingMode ? "selection-rect-crossing" : "selection-rect");

        // 更新選擇框位置和大小
        const x = Math.min(selectionStart.x, currentPoint.x);
        const y = Math.min(selectionStart.y, currentPoint.y);
        const w = Math.abs(width);
        const h = Math.abs(height);

        selectionRect.setAttribute("x", x);
        selectionRect.setAttribute("y", y);
        selectionRect.setAttribute("width", w);
        selectionRect.setAttribute("height", h);

        pendingSelectionEvent = null;
      }

      // 结束圈选
      function onSelectionEnd(evt) {
        if (!isSelecting) return;

        isSelecting = false;

        // [新增] 移除 AutoCAD 風格十字線游標
        if (svgElement) {
          svgElement.classList.remove('autocad-crosshair');
        }

        if (panZoomInstance) {
          panZoomInstance.enablePan();
        }

        const endPoint = getSVGCoords(evt);
        const width = endPoint.x - selectionStart.x;
        const height = endPoint.y - selectionStart.y;

        // 判断圈选模式
        const isCrossingMode = width < 0; // 右到左：碰到即选

        // 获取选择框的边界（SVG 內部座標）
        const minX = Math.min(selectionStart.x, endPoint.x);
        const maxX = Math.max(selectionStart.x, endPoint.x);
        const minY = Math.min(selectionStart.y, endPoint.y);
        const maxY = Math.max(selectionStart.y, endPoint.y);

        // 選擇框足夠大才執行選擇（避免單擊誤觸）
        const MIN_SELECTION_SIZE = 10; // SVG 單位
        if (Math.abs(width) > MIN_SELECTION_SIZE || Math.abs(height) > MIN_SELECTION_SIZE) {
          console.log('=== 選擇框範圍 (SVG 內部座標) ===');
          console.log(`範圍: (${minX.toFixed(1)}, ${minY.toFixed(1)}) 到 (${maxX.toFixed(1)}, ${maxY.toFixed(1)})`);
          console.log(`模式: ${isCrossingMode ? 'Crossing (右→左)' : 'Window (左→右)'}`);

          selectBeamsInRect(minX, minY, maxX, maxY, isCrossingMode);
        } else {
          // 選擇框太小，不做任何事（不再自動清除選擇）
          // 使用者需要按 Esc 來清除選擇
          console.log('選擇框太小，忽略（按 Esc 清除選擇）');
        }

        // 移除選擇框
        if (selectionRect) {
          selectionRect.remove();
          selectionRect = null;
        }
      }

      // 在矩形内选择梁（選擇框和梁在同一座標系統中）
      function selectBeamsInRect(minX, minY, maxX, maxY, isCrossingMode) {
        const beamLines = svgElement.querySelectorAll('.labeled-beam-line, .secondary-beam-line, .special-beam-line, .wall-beam-line');

        let selectedCount = 0;
        let checkedCount = 0;
        const selectedList = [];
        const rejectedList = [];

        beamLines.forEach((line) => {
          // 直接讀取梁的座標（與選擇框在同一 viewport 座標系統中）
          const x1 = parseFloat(line.getAttribute('x1'));
          const y1 = parseFloat(line.getAttribute('y1'));
          const x2 = parseFloat(line.getAttribute('x2'));
          const y2 = parseFloat(line.getAttribute('y2'));
          const beamName = line.dataset.beamName;
          const beamStory = line.dataset.beamStory;
          const beamJoint1 = line.dataset.beamJoint1;
          const beamJoint2 = line.dataset.beamJoint2;

          if (!beamName || !beamStory) return;

          // [修改] 使用唯一的 beamKey
          const beamKey = `${beamStory}|${beamName}|${beamJoint1}|${beamJoint2}`;

          // [新增] 跳過 WB/FWB 梁，不允許被圈選或編輯
          const isWallBeam = line.classList.contains('wall-beam-line');
          if (isWallBeam) return;

          checkedCount++;
          let isInside = false;

          if (isCrossingMode) {
            // 碰到即选：检查线段是否与矩形相交
            isInside = lineIntersectsRect(x1, y1, x2, y2, minX, minY, maxX, maxY);
          } else {
            // 完全框选：检查线段是否完全在矩形内
            isInside = (x1 >= minX && x1 <= maxX && y1 >= minY && y1 <= maxY &&
                       x2 >= minX && x2 <= maxX && y2 >= minY && y2 <= maxY);
          }

          if (isInside) {
            selectedBeams.add(beamKey);
            updateBeamVisualState(beamKey, true);
            selectedCount++;
            selectedList.push(`${beamName}@${beamStory}[(${x1.toFixed(0)},${y1.toFixed(0)})→(${x2.toFixed(0)},${y2.toFixed(0)})]`);
          } else if (checkedCount <= 10) {
            rejectedList.push(`${beamName}@${beamStory}[(${x1.toFixed(0)},${y1.toFixed(0)})→(${x2.toFixed(0)},${y2.toFixed(0)})]`);
          }
        });

        console.log(`%c=== 選擇結果 ===`, 'color: #22c55e; font-weight: bold');
        console.log(`選擇框: (${minX.toFixed(0)}, ${minY.toFixed(0)}) → (${maxX.toFixed(0)}, ${maxY.toFixed(0)})`);
        console.log(`模式: ${isCrossingMode ? 'Crossing (碰到即選)' : 'Window (完全包含)'}`);
        console.log(`%c✓ 選中 ${selectedCount} 個:`, 'color: #22c55e', selectedList.join(', '));
        console.log(`%c✗ 未選中（前10個）:`, 'color: #ef4444', rejectedList.join(', '));
      }

      // 检查线段是否与矩形相交（Crossing 模式）
      function lineIntersectsRect(x1, y1, x2, y2, minX, minY, maxX, maxY) {
        // 1. 检查任一端点是否在矩形内
        const pt1Inside = (x1 >= minX && x1 <= maxX && y1 >= minY && y1 <= maxY);
        const pt2Inside = (x2 >= minX && x2 <= maxX && y2 >= minY && y2 <= maxY);

        if (pt1Inside || pt2Inside) {
          return true;
        }

        // 2. 检查线段是否与矩形的四條邊相交
        // 上边
        if (lineIntersectsLine(x1, y1, x2, y2, minX, minY, maxX, minY)) return true;
        // 右边
        if (lineIntersectsLine(x1, y1, x2, y2, maxX, minY, maxX, maxY)) return true;
        // 下边
        if (lineIntersectsLine(x1, y1, x2, y2, minX, maxY, maxX, maxY)) return true;
        // 左边
        if (lineIntersectsLine(x1, y1, x2, y2, minX, minY, minX, maxY)) return true;

        // 3. 检查矩形是否完全在线段內（特殊情況：很長的梁穿過小框）
        // 如果矩形的某個角點在線段上，也算相交
        // 但由於上面已經檢查了線段與邊界相交，這裡可以省略

        return false;
      }

      // 检查两条线段是否相交
      function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        if (denom === 0) return false;

        const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
        const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

        return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }

      // 更新梁的视觉状态
      function updateBeamVisualState(beamKey, isSelected) {
        // [修改] 從 beamKey 解析資訊
        const [story, name, joint1, joint2] = beamKey.split('|');

        // 更新梁线和標籤（使用完整條件匹配）
        const allElements = svgElement.querySelectorAll(`[data-beam-name="${name}"]`);
        allElements.forEach(element => {
          // 確認是同一根梁（樓層和接點都要匹配）
          if (element.dataset.beamStory === story &&
              element.dataset.beamJoint1 === joint1 &&
              element.dataset.beamJoint2 === joint2) {
            if (element.tagName === 'line') {
              if (isSelected) {
                element.classList.add('beam-selected');
              } else {
                element.classList.remove('beam-selected');
              }
            } else if (element.tagName === 'text') {
              if (isSelected) {
                element.classList.add('beam-selected');
              } else {
                element.classList.remove('beam-selected');
              }
            }
          }
        });
      }

      // 键盘事件处理
      function onKeyDown(evt) {
        // 按 Ctrl+F 或 Cmd+F 打開搜尋對話框
        if ((evt.ctrlKey || evt.metaKey) && evt.key === 'f') {
          evt.preventDefault(); // 防止瀏覽器預設的搜尋功能
          openSearchMemberDialog();
          return;
        }

        // 按 Enter 或空白鍵打开批量编辑对话框
        if ((evt.key === 'Enter' || evt.key === ' ') && selectedBeams.size > 0) {
          // 如果批量編輯對話框已經打開，不要重複觸發
          if (document.getElementById('batch-edit-dialog').style.display === 'block') {
            return;
          }
          evt.preventDefault(); // 防止空白鍵滾動頁面
          openBatchEditDialog();
        }
        // 按 Escape 清除所有选择或關閉對話框
        // [修改] ESC 行為優先順序：1.關閉各種彈窗 2.關閉資訊欄 3.取消選取
        else if (evt.key === 'Escape') {
          // 1. 如果 MIRROR 設定對話框打開，先關閉它
          if (document.getElementById('mirror-settings-dialog').style.display === 'block') {
            closeMirrorSettingsModal();
          }
          // 2. 如果梁編輯對話框打開，關閉它
          else if (document.getElementById('beam-edit-dialog').style.display === 'block') {
            closeBeamEditDialog();
          }
          // 3. 如果批量編輯對話框打開，關閉它
          else if (document.getElementById('batch-edit-dialog').style.display === 'block') {
            closeBatchEditDialog();
          }
          // 4. 如果搜尋對話框打開，關閉它
          else if (document.getElementById('search-member-dialog').style.display === 'block') {
            closeSearchMemberDialog();
          }
          // 5. 如果固定編號對話框打開，關閉它
          else if (document.getElementById('fixed-label-dialog').style.display === 'block') {
            closeFixedLabelModal();
          }
          // 6. 如果格線編號對話框打開，關閉它
          else if (document.getElementById('grid-bubble-modal') && document.getElementById('grid-bubble-modal').style.display === 'block') {
            closeGridBubbleModal();
          }
          // 7. 如果資訊欄（tooltip）打開，關閉它
          else if (document.getElementById('beam-info-tooltip')) {
            document.getElementById('beam-info-tooltip').remove();
          }
          // 8. 如果有選取的梁，取消選取
          else if (selectedBeams.size > 0) {
            clearAllSelections();
          }
        }
        // 按 Delete 删除选中梁的编号（恢复为原始编号）
        else if (evt.key === 'Delete' && selectedBeams.size > 0) {
          if (confirm(`確定要清除 ${selectedBeams.size} 個梁的自訂編號嗎？`)) {
            clearSelectedBeamLabels();
          }
        }
      }

      // 打开批量编辑对话框
      function openBatchEditDialog() {
        if (selectedBeams.size === 0) {
          alert('請先選擇要編輯的梁');
          return;
        }

        document.getElementById('batch-count').textContent = selectedBeams.size;
        document.getElementById('batch-new-label').value = '';

        // [新增] 檢查選中的梁是否有任一屬於標準層群組
        let hasStandardFloorBeam = false;
        selectedBeams.forEach((beamKey) => {
          const [story] = beamKey.split('|');
          const group = getStandardFloorGroupForStory(story);
          if (group && group.length > 1) {
            hasStandardFloorBeam = true;
          }
        });

        const linkGroup = document.getElementById('batch-link-standard-floor-group');
        const linkCheckbox = document.getElementById('batch-link-standard-floor');

        if (hasStandardFloorBeam) {
          linkGroup.style.display = 'block';
          linkCheckbox.checked = true; // 預設勾選
        } else {
          linkGroup.style.display = 'none';
        }

        document.getElementById('batch-edit-dialog').style.display = 'block';
        document.getElementById('batch-edit-overlay').style.display = 'block';
        // 防止背景滾動
        document.body.style.overflow = 'hidden';

        // 聚焦到输入框
        setTimeout(() => {
          const input = document.getElementById('batch-new-label');
          input.focus();

          // 添加鍵盤事件監聯：Enter 或空白鍵確認
          input.onkeydown = (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault(); // 防止空白鍵在輸入框中輸入空格
              saveBatchEdit();
            } else if (e.key === 'Escape') {
              closeBatchEditDialog();
            }
          };
        }, 100);
      }

      // 关闭批量编辑对话框
      function closeBatchEditDialog() {
        document.getElementById('batch-edit-dialog').style.display = 'none';
        document.getElementById('batch-edit-overlay').style.display = 'none';
        // 恢復背景滾動
        document.body.style.overflow = '';
      }

      // 保存批量编辑
      function saveBatchEdit() {
        const newLabel = document.getElementById('batch-new-label').value.trim();

        if (!newLabel) {
          alert('請輸入新的編號');
          return;
        }

        // [新增] 檢查是否勾選連動標準層
        const linkCheckbox = document.getElementById('batch-link-standard-floor');
        const linkGroup = document.getElementById('batch-link-standard-floor-group');
        const shouldLinkStandardFloors = linkGroup.style.display !== 'none' && linkCheckbox.checked;

        // [修復] 獲取當前選擇的樓層，避免修改到其他樓層的同名梁
        const selectedStory = document.getElementById("storySelector").value;

        console.log(`\n[批量編輯] 開始處理 ${selectedBeams.size} 個選中的梁`);
        console.log(`  新編號: ${newLabel}`);
        console.log(`  當前樓層: ${selectedStory}`);
        console.log(`  連動標準層: ${shouldLinkStandardFloors}`);

        // [新增] 記錄第一個被編輯的梁，用於觸發連續小梁更新
        let firstBeam = null;
        let firstOldLabel = null;
        let isFirstBeam = true;
        let totalLinkedUpdates = 0;

        // [新增] 檢查是否為選取範圍內順號模式 (新編號以 -1 結尾且選取多個梁)
        const sequentialMatch = newLabel.match(/^(.+)-1$/);
        const isSequentialMode = sequentialMatch && selectedBeams.size > 1;

        if (isSequentialMode) {
          // ============ 選取範圍內順號模式 ============
          const baseLabel = sequentialMatch[1];  // 取得 -1 前的基礎標籤
          console.log(`\n  🔢 [順號模式] 偵測到 -1 結尾，啟用選取範圍順號`);
          console.log(`    基礎標籤: ${baseLabel}`);
          console.log(`    選取梁數: ${selectedBeams.size}`);

          // 收集所有選中的梁及其座標
          const beamsWithCoords = [];
          selectedBeams.forEach((beamKey) => {
            const [story, name, joint1, joint2] = beamKey.split('|');
            const beam = fullProcessedBeams.find(b =>
              b.name === name &&
              b.story === story &&
              b.joint1 === joint1 &&
              b.joint2 === joint2
            );
            if (beam && previewJoints) {
              const j1 = previewJoints[beam.joint1];
              const j2 = previewJoints[beam.joint2];
              if (j1 && j2) {
                // 計算梁的中點座標
                const midX = (j1.x + j2.x) / 2;
                const midY = (j1.y + j2.y) / 2;
                beamsWithCoords.push({ beam, midX, midY });
              }
            }
          });

          // 按位置排序：先由左至右 (X 小到大)，再由下到上 (Y 小到大)
          beamsWithCoords.sort((a, b) => {
            // 先比較 Y 座標 (由下到上)
            const yDiff = a.midY - b.midY;
            if (Math.abs(yDiff) > 0.01) return yDiff;
            // Y 座標相同時，比較 X 座標 (由左至右)
            return a.midX - b.midX;
          });

          console.log(`    排序後順序 (由左至右, 由下至上):`);
          beamsWithCoords.forEach((item, idx) => {
            console.log(`      ${idx + 1}. ${item.beam.name} (X=${item.midX.toFixed(2)}, Y=${item.midY.toFixed(2)})`);
          });

          // 為每個梁指定順序編號
          beamsWithCoords.forEach((item, index) => {
            const sequentialNumber = index + 1;
            const oldLabel = item.beam.newLabel;
            item.beam.newLabel = `${baseLabel}-${sequentialNumber}`;
            console.log(`    ✅ ${item.beam.name}: ${oldLabel} → ${item.beam.newLabel}`);

            // [新增] 連動標準層更新
            if (shouldLinkStandardFloors) {
              const standardFloorGroup = getStandardFloorGroupForStory(item.beam.story);
              if (standardFloorGroup && standardFloorGroup.length > 1) {
                const linkedBeams = findBeamsAtSamePosition(item.beam, standardFloorGroup);
                linkedBeams.forEach(linkedBeam => {
                  linkedBeam.newLabel = item.beam.newLabel;
                  totalLinkedUpdates++;
                });
              }
            }
          });

          console.log(`  ✅ [順號模式] 已完成 ${beamsWithCoords.length} 個梁的順號編號`);

        } else {
          // ============ 原有的批量編輯邏輯 ============
          // 更新所有选中梁的编号
          selectedBeams.forEach((beamKey) => {
            // [修改] 從 beamKey 解析資訊
            const [story, name, joint1, joint2] = beamKey.split('|');

            // [修復] 在 fullProcessedBeams 中找到对应的梁並更新
            const beam = fullProcessedBeams.find(b =>
              b.name === name &&
              b.story === story &&
              b.joint1 === joint1 &&
              b.joint2 === joint2
            );
            if (beam) {
              // 記錄第一個梁的舊編號
              if (isFirstBeam) {
                firstBeam = beam;
                firstOldLabel = beam.newLabel;
                console.log(`  第一個梁: ${beam.name}, 樓層: ${beam.story}, 舊編號: ${firstOldLabel}`);
                isFirstBeam = false;
              }

              // [修復] 只更新數據，不直接修改 SVG（避免與 handleStoryChange 衝突）
              beam.newLabel = newLabel;
              console.log(`  更新梁 ${beam.name} (${beam.story}): ${firstOldLabel || '原編號'} → ${newLabel}`);

              // [新增] 連動標準層更新
              if (shouldLinkStandardFloors) {
                const standardFloorGroup = getStandardFloorGroupForStory(beam.story);
                if (standardFloorGroup && standardFloorGroup.length > 1) {
                  const linkedBeams = findBeamsAtSamePosition(beam, standardFloorGroup);
                  linkedBeams.forEach(linkedBeam => {
                    linkedBeam.newLabel = newLabel;
                    totalLinkedUpdates++;
                  });
                }
              }
            }
          });

          // [修復] 如果只選中了一個梁，且該梁是小梁（SB 類型），才檢查是否需要更新連續小梁
          if (selectedBeams.size === 1 && firstBeam && firstOldLabel) {
            // 判斷是否為小梁：frame section 為 SB, FSB, 或數字+SB/FSB
            const isSecondaryBeam = firstBeam.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(firstBeam.prop);

            if (isSecondaryBeam) {
              console.log(`  單個梁編輯，且為小梁（${firstBeam.prop}），檢查是否需要更新連續小梁...`);
              updateSequentialBeamLabels(firstOldLabel, newLabel, firstBeam.story);
            } else {
              console.log(`  單個梁編輯，但為大梁（${firstBeam.prop}），跳過連續小梁更新`);
            }
          }
        }

        if (shouldLinkStandardFloors && totalLinkedUpdates > 0) {
          console.log(`  [連動標準層] 額外更新了 ${totalLinkedUpdates} 個其他樓層的梁`);
        }

        // [修復] 無論如何都重新繪製 SVG，確保顯示最新數據
        console.log(`  重新繪製 SVG...`);
        handleStoryChange();

        closeBatchEditDialog();
        clearAllSelections();
      }

      // ============ 搜尋桿件功能 ============

      // 開啟搜尋對話框
      function openSearchMemberDialog() {
        const dialog = document.getElementById('search-member-dialog');
        const overlay = document.getElementById('search-member-overlay');
        const input = document.getElementById('search-member-input');
        const resultsDiv = document.getElementById('search-results');

        dialog.style.display = 'block';
        overlay.style.display = 'block';
        // 防止背景滾動
        document.body.style.overflow = 'hidden';

        // 清空之前的搜尋結果
        resultsDiv.innerHTML = '<div style="color: var(--theme-text-secondary); text-align: center;">輸入 ETABS 編號並點擊搜尋</div>';
        input.value = '';
        input.focus();
      }

      // 關閉搜尋對話框
      function closeSearchMemberDialog() {
        document.getElementById('search-member-dialog').style.display = 'none';
        document.getElementById('search-member-overlay').style.display = 'none';
        // 恢復背景滾動
        document.body.style.overflow = '';
      }

      // 搜尋桿件
      function searchMember() {
        const searchTerm = document.getElementById('search-member-input').value.trim().toUpperCase();
        const resultsDiv = document.getElementById('search-results');

        if (!searchTerm) {
          resultsDiv.innerHTML = '<div style="color: var(--theme-warning); text-align: center;">⚠️ 請輸入搜尋關鍵字</div>';
          return;
        }

        // 檢查是否有已處理的梁資料
        if (!fullProcessedBeams || fullProcessedBeams.length === 0) {
          resultsDiv.innerHTML = '<div style="color: var(--theme-warning); text-align: center;">⚠️ 請先上傳 E2K 檔案並執行編號</div>';
          return;
        }

        // 搜尋匹配的梁（支援部分匹配）
        const matchedBeams = fullProcessedBeams.filter(beam =>
          beam.name && beam.name.toUpperCase().includes(searchTerm)
        );

        if (matchedBeams.length === 0) {
          resultsDiv.innerHTML = `<div style="color: var(--theme-warning); text-align: center;">❌ 找不到符合 "${searchTerm}" 的桿件</div>`;
          return;
        }

        // 顯示搜尋結果
        let resultsHTML = `<div style="margin-bottom: 10px; color: var(--theme-accent); font-weight: bold;">✅ 找到 ${matchedBeams.length} 個符合的桿件：</div>`;

        matchedBeams.forEach(beam => {
          const beamInfo = `
            <div style="
              padding: 12px;
              margin-bottom: 8px;
              background: var(--theme-surface);
              border: 1px solid var(--theme-border);
              border-radius: 6px;
              cursor: pointer;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='var(--theme-hover)'; this.style.borderColor='var(--theme-accent)';"
            onmouseout="this.style.background='var(--theme-surface)'; this.style.borderColor='var(--theme-border)';"
            onclick="locateAndHighlightBeam('${beam.name}')">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <strong style="color: var(--theme-accent); font-size: 1.1em;">${beam.name}</strong>
                  <span style="color: var(--theme-text-secondary); margin-left: 10px;">→ ${beam.newLabel || '未編號'}</span>
                </div>
                <button class="btn-process" style="padding: 5px 15px; font-size: 0.85em;" onclick="event.stopPropagation(); locateAndHighlightBeam('${beam.name}')">
                  定位
                </button>
              </div>
              <div style="font-size: 0.85em; color: var(--theme-text-secondary); margin-top: 5px;">
                📍 樓層: ${beam.story || 'N/A'} | 斷面: ${beam.prop || 'N/A'}
              </div>
              ${beam.j1 && beam.j2 ? `
                <div style="font-size: 0.8em; color: var(--theme-text-secondary); margin-top: 3px;">
                  座標: (${beam.j1.x.toFixed(2)}, ${beam.j1.y.toFixed(2)}) → (${beam.j2.x.toFixed(2)}, ${beam.j2.y.toFixed(2)})
                </div>
              ` : ''}
            </div>
          `;
          resultsHTML += beamInfo;
        });

        resultsDiv.innerHTML = resultsHTML;
      }

      // 定位並高亮顯示梁
      function locateAndHighlightBeam(beamName) {
        const svgElement = document.getElementById('drawing-svg');
        if (!svgElement) {
          alert('❌ 找不到平面圖');
          return;
        }

        // 先從全部梁資料中找到該桿件
        const beam = fullProcessedBeams.find(b => b.name === beamName);
        if (!beam) {
          alert(`❌ 找不到桿件 ${beamName}`);
          return;
        }

        // 如果桿件有樓層資訊，自動切換到該樓層
        if (beam.story) {
          const storySelector = document.getElementById('storySelector');
          const currentStory = storySelector.value;

          // 如果當前不是該樓層，就切換到該樓層（包括從 'all' 切換）
          if (currentStory !== beam.story) {
            storySelector.value = beam.story;
            handleStoryChange(); // 重新繪製平面圖
          }
        }

        // 等待一小段時間讓 DOM 更新完成，然後找到該梁的所有元素（線和標籤）
        setTimeout(() => {
          const beamElements = svgElement.querySelectorAll(`[data-beam-name="${beamName}"]`);

          if (beamElements.length === 0) {
            alert(`❌ 找不到桿件 ${beamName} 的視覺元素`);
            return;
          }

          // 清除之前的選擇
          clearAllSelections();

          // [修改] 使用唯一的 beamKey
          const beamKey = `${beam.story}|${beam.name}|${beam.joint1}|${beam.joint2}`;
          selectedBeams.add(beamKey);
          updateBeamVisualState(beamKey, true);

          // 計算梁的中心點（用於平移和縮放）
          if (beam && beam.j1 && beam.j2 && panZoomInstance) {
            // 計算梁的中心點（ETABS 座標）
            const centerX = (beam.j1.x + beam.j2.x) / 2;
            const centerY = (beam.j1.y + beam.j2.y) / 2;

            // 轉換為 SVG 座標
            const svgCenterX = transformX(centerX);
            const svgCenterY = transformY(centerY);

            // 移動視圖到梁的位置並放大
            const viewportWidth = svgElement.clientWidth;
            const viewportHeight = svgElement.clientHeight;

            // 設定目標縮放等級（放大以便看清楚）
            const targetZoom = 2.5;

            // 計算平移量，使梁的中心點位於視窗中心
            const targetX = viewportWidth / 2 - svgCenterX * targetZoom;
            const targetY = viewportHeight / 2 - svgCenterY * targetZoom;

            // 執行平滑的平移和縮放
            panZoomInstance.smoothZoom(targetX, targetY, targetZoom);

            // 添加閃爍效果
            setTimeout(() => {
              let flashCount = 0;
              const flashInterval = setInterval(() => {
                beamElements.forEach(el => {
                  if (el.tagName === 'line') {
                    el.style.opacity = flashCount % 2 === 0 ? '0.3' : '1';
                  } else if (el.tagName === 'text') {
                    el.style.opacity = flashCount % 2 === 0 ? '0.3' : '1';
                  }
                });
                flashCount++;
                if (flashCount >= 6) {
                  clearInterval(flashInterval);
                  // 恢復正常透明度
                  beamElements.forEach(el => {
                    el.style.opacity = '1';
                  });
                }
              }, 200);
            }, 300);
          }

          // 關閉搜尋對話框
          closeSearchMemberDialog();
        }, 100); // 等待 100ms 讓 DOM 更新
      }

      // 清除所有选择
      function clearAllSelections() {
        selectedBeams.forEach(beamKey => {
          updateBeamVisualState(beamKey, false);
        });
        selectedBeams.clear();

        // [新增] 強制清除所有 SVG 元素的選取樣式（防止殘留）
        if (svgElement) {
          const allSelected = svgElement.querySelectorAll('.beam-selected');
          allSelected.forEach(el => el.classList.remove('beam-selected'));
          // [新增] 移除十字線游標（防止殘留）
          svgElement.classList.remove('autocad-crosshair');
        }
      }

      // 清除选中梁的编号
      function clearSelectedBeamLabels() {
        selectedBeams.forEach(beamKey => {
          // [修改] 從 beamKey 解析資訊
          const [story, name, joint1, joint2] = beamKey.split('|');

          const beam = fullProcessedBeams.find(b =>
            b.name === name &&
            b.story === story &&
            b.joint1 === joint1 &&
            b.joint2 === joint2
          );
          if (beam) {
            // 恢复为原始 ETABS 编号
            beam.newLabel = beam.name;

            // 更新SVG中的标签文本
            const labelElements = svgElement.querySelectorAll(`text[data-beam-name="${name}"]`);
            labelElements.forEach(label => {
              // 確認是同一根梁
              if (label.dataset.beamStory === story &&
                  label.dataset.beamJoint1 === joint1 &&
                  label.dataset.beamJoint2 === joint2) {
                label.textContent = beam.name;
              }
            });
          }
        });

        clearAllSelections();
        alert('已清除選中梁的自訂編號');
      }

      // 在绘图完成后初始化圈选功能
      // 需要在 displayResults 函数调用后执行
      const originalDisplayResults = displayResults;
      displayResults = function(...args) {
        originalDisplayResults.apply(this, args);
        // 延迟初始化以确保SVG元素已经渲染
        setTimeout(() => {
          initializeSelectionFeature();
          initializeMiddleMousePan();  // [新增] 初始化滾輪中鍵拖動
        }, 100);
      };

      // ============ 全局鍵盤快捷鍵（頁面載入時就生效）============
      // 添加全局鍵盤事件監聽器，攔截 Ctrl+F 快捷鍵
      document.addEventListener('keydown', function(evt) {
        // 攔截 Ctrl+F 或 Cmd+F
        if ((evt.ctrlKey || evt.metaKey) && evt.key === 'f') {
          evt.preventDefault(); // 防止瀏覽器預設的搜尋功能
          openSearchMemberDialog();
        }
        // 攔截 Escape 關閉搜尋對話框
        else if (evt.key === 'Escape') {
          if (document.getElementById('search-member-dialog').style.display === 'block') {
            evt.preventDefault();
            closeSearchMemberDialog();
          }
        }
      }, true); // 使用捕獲階段，確保優先攔截

      // [新增] 頁面載入時的初始化檢查
      document.addEventListener('DOMContentLoaded', function() {
        console.log("[DEBUG] DOM Content Loaded");

        // 檢查關鍵元素是否存在
        const fileInput = document.getElementById("e2kFile");
        const statusDiv = document.getElementById("status");
        const drawingSvg = document.getElementById("drawing-svg");

        console.log("[DEBUG] Element check:", {
          fileInput: !!fileInput,
          statusDiv: !!statusDiv,
          drawingSvg: !!drawingSvg
        });

        // 檢查 previewFile 函數是否存在
        if (typeof previewFile === 'function') {
          console.log("[DEBUG] previewFile function is defined");
        } else {
          console.error("[ERROR] previewFile function is not defined!");
        }
      });

    </script>

    <!-- [新增] 全螢幕模式樓層顯示 Bubble（浮動在最上層，不在畫布上） -->
    <div id="fullscreen-floor-bubble">
      <span id="fullscreen-floor-text">所有樓層合併</span>
    </div>
  </body>
</html>
