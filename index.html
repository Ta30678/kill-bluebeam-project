<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ç‰†é‡è¨ˆç®—å·¥å…· - Wall Quantity Calculator</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --primary: #d97706;
        --primary-light: #fbbf24;
        --primary-dark: #b45309;
        --bg-dark: #1a1a1a;
        --bg-sidebar: #f7f7f5;
        --bg-canvas: #ffffff;
        --text-primary: #292524;
        --text-secondary: #78716c;
        --text-muted: #a8a29e;
        --border-color: #e7e5e4;
        --hover-bg: #f5f5f4;
        --accent-wall: #ea580c;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        background: var(--bg-canvas);
        color: var(--text-primary);
        height: 100vh;
        overflow: hidden;
      }

      /* ==================== ä¸»ä½ˆå±€ ==================== */
      .app-container {
        display: flex;
        height: 100vh;
        width: 100%;
      }

      /* ==================== å·¦å´å´é‚Šæ¬„ ==================== */
      .sidebar {
        width: 320px;
        min-width: 320px;
        background: var(--bg-sidebar);
        border-right: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        z-index: 100;
      }

      .sidebar.collapsed {
        width: 0;
        min-width: 0;
        border-right: none;
      }

      .sidebar.collapsed .sidebar-content,
      .sidebar.collapsed .sidebar-header {
        opacity: 0;
        pointer-events: none;
      }

      .sidebar-toggle {
        position: absolute;
        right: -40px;
        top: 50%;
        transform: translateY(-50%);
        width: 40px;
        height: 80px;
        background: var(--bg-sidebar);
        border: 1px solid var(--border-color);
        border-left: none;
        border-radius: 0 12px 12px 0;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 101;
        transition: all 0.2s;
      }

      .sidebar-toggle:hover {
        background: var(--hover-bg);
      }

      .sidebar-toggle svg {
        width: 20px;
        height: 20px;
        color: var(--text-secondary);
        transition: transform 0.3s;
      }

      .sidebar.collapsed .sidebar-toggle svg {
        transform: rotate(180deg);
      }

      /* å´é‚Šæ¬„é ­éƒ¨ */
      .sidebar-header {
        padding: 20px;
        border-bottom: 1px solid var(--border-color);
      }

      .sidebar-logo {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
      }

      .sidebar-logo-icon {
        width: 36px;
        height: 36px;
        background: linear-gradient(
          135deg,
          var(--primary),
          var(--primary-dark)
        );
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 18px;
      }

      .sidebar-logo-text {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-primary);
      }

      /* é ç±¤åˆ‡æ› */
      .tab-switch {
        display: flex;
        background: #e7e5e4;
        border-radius: 10px;
        padding: 4px;
      }

      .tab-btn {
        flex: 1;
        padding: 10px 16px;
        border: none;
        background: transparent;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.2s;
      }

      .tab-btn.active {
        background: white;
        color: var(--text-primary);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .tab-btn:hover:not(.active) {
        color: var(--text-primary);
      }

      /* å´é‚Šæ¬„å…§å®¹ */
      .sidebar-content {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .tab-panel {
        display: none;
        flex-direction: column;
        height: 100%;
        overflow: hidden;
      }

      .tab-panel.active {
        display: flex;
      }

      /* æ“ä½œæŒ‰éˆ•å€ */
      .sidebar-actions {
        padding: 16px 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .btn {
        padding: 12px 20px;
        border: none;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--primary),
          var(--primary-dark)
        );
        color: white;
        box-shadow: 0 2px 8px rgba(217, 119, 6, 0.3);
      }

      .btn-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(217, 119, 6, 0.4);
      }

      .btn-secondary {
        background: white;
        color: var(--text-primary);
        border: 1px solid var(--border-color);
      }

      .btn-secondary:hover {
        background: var(--hover-bg);
      }

      .btn-ghost {
        background: transparent;
        color: var(--text-secondary);
        padding: 8px 12px;
      }

      .btn-ghost:hover {
        background: var(--hover-bg);
        color: var(--text-primary);
      }

      /* æª”æ¡ˆç‹€æ…‹ */
      .file-status {
        font-size: 12px;
        color: var(--text-muted);
        text-align: center;
        padding: 8px;
        background: var(--hover-bg);
        border-radius: 8px;
      }

      /* åœ–å±¤ç®¡ç†å€ */
      .layer-management {
        padding: 12px 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .layer-count {
        font-size: 13px;
        color: var(--text-secondary);
      }

      .layer-count strong {
        color: var(--text-primary);
      }

      /* åœ–å±¤åˆ—è¡¨ */
      .layer-list {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
      }

      .layer-item {
        display: flex;
        align-items: center;
        padding: 10px 12px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s;
        margin-bottom: 2px;
      }

      .layer-item:hover {
        background: var(--hover-bg);
      }

      .layer-item.hidden {
        opacity: 0.4;
        display: flex !important;
        /* è¦†è“‹ .hidden { display: none !important } */
      }

      .layer-color {
        width: 14px;
        height: 14px;
        border-radius: 4px;
        margin-right: 10px;
        flex-shrink: 0;
      }

      .layer-name {
        flex: 1;
        font-size: 13px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .layer-name.wall-type {
        font-weight: 600;
        color: var(--accent-wall);
      }

      .layer-badge {
        font-size: 10px;
        background: var(--accent-wall);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        margin-right: 8px;
      }

      .layer-toggle {
        width: 24px;
        height: 24px;
        border: none;
        background: transparent;
        cursor: pointer;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0.6;
        transition: all 0.2s;
      }

      .layer-toggle:hover {
        background: rgba(0, 0, 0, 0.05);
        opacity: 1;
      }

      /* çµ±è¨ˆé¢æ¿ */
      .stats-content {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
      }

      .stats-section {
        margin-bottom: 24px;
      }

      .stats-section-title {
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--text-muted);
        margin-bottom: 12px;
      }

      .stats-card {
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 12px;
      }

      .stats-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid var(--border-color);
      }

      .stats-row:last-child {
        border-bottom: none;
      }

      .stats-label {
        font-size: 13px;
        color: var(--text-secondary);
      }

      .stats-value {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
      }

      .stats-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      .stats-table th {
        text-align: left;
        padding: 10px 8px;
        font-weight: 500;
        color: var(--text-muted);
        border-bottom: 1px solid var(--border-color);
      }

      .stats-table td {
        padding: 10px 8px;
        border-bottom: 1px solid var(--border-color);
      }

      .stats-table tr:hover {
        background: var(--hover-bg);
      }

      /* ==================== åˆä½µé¢æ¿ ==================== */
      .merge-panel {
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 12px;
      }

      .merge-panel-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 12px;
      }

      .merge-panel-title {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
      }

      .merge-buttons {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .merge-result {
        padding: 12px;
        background: #f0fdf4;
        border: 1px solid #86efac;
        border-radius: 8px;
        margin-top: 12px;
        font-size: 13px;
      }

      .merge-result.warning {
        background: #fef3c7;
        border-color: #fcd34d;
      }

      .merge-stat-row {
        display: flex;
        justify-content: space-between;
        padding: 4px 0;
      }

      .merge-stat-label {
        color: var(--text-secondary);
      }

      .merge-stat-value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .thickness-input-group {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .thickness-input {
        width: 60px;
        padding: 4px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 12px;
        text-align: right;
      }

      .thickness-unit {
        font-size: 12px;
        color: var(--text-muted);
      }

      /* ==================== ä¸»å…§å®¹å€ ==================== */
      .main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        background: var(--bg-canvas);
      }

      /* é ‚éƒ¨å·¥å…·åˆ— */
      .toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 24px;
        background: white;
        border-bottom: 1px solid var(--border-color);
      }

      .toolbar-left {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .toolbar-title {
        font-size: 14px;
        font-weight: 500;
        color: var(--text-primary);
      }

      .toolbar-info {
        font-size: 12px;
        color: var(--text-muted);
      }

      .toolbar-tools {
        display: flex;
        gap: 4px;
        background: var(--bg-sidebar);
        padding: 4px;
        border-radius: 10px;
      }

      .tool-btn {
        width: 36px;
        height: 36px;
        border: none;
        background: transparent;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        color: var(--text-secondary);
        transition: all 0.2s;
      }

      .tool-btn:hover {
        background: white;
        color: var(--text-primary);
      }

      .tool-btn.active {
        background: white;
        color: var(--primary);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      /* ç•«å¸ƒå€åŸŸ */
      .canvas-wrapper {
        flex: 1;
        position: relative;
        overflow: hidden;
        background: #fafafa;
      }

      #mainCanvas {
        position: absolute;
        top: 0;
        left: 0;
        user-select: none;
      }

      #mainCanvas.panning {
        cursor: grabbing !important;
      }

      /* ç‹€æ…‹åˆ— */
      .statusbar {
        display: flex;
        justify-content: space-between;
        padding: 8px 24px;
        background: var(--bg-sidebar);
        border-top: 1px solid var(--border-color);
        font-size: 12px;
        color: var(--text-muted);
      }

      /* ==================== Modal å°è©±æ¡† ==================== */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
      }

      .modal-overlay.show {
        opacity: 1;
        visibility: visible;
      }

      .modal {
        background: white;
        border-radius: 16px;
        width: 560px;
        max-width: 90%;
        max-height: 85vh;
        overflow: hidden;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
        transform: scale(0.95);
        transition: transform 0.3s;
      }

      .modal-overlay.show .modal {
        transform: scale(1);
      }

      .modal-header {
        padding: 20px 24px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .modal-title {
        font-size: 18px;
        font-weight: 600;
      }

      .modal-close {
        width: 32px;
        height: 32px;
        border: none;
        background: var(--hover-bg);
        border-radius: 8px;
        cursor: pointer;
        font-size: 20px;
        color: var(--text-secondary);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }

      .modal-close:hover {
        background: #e7e5e4;
        color: var(--text-primary);
      }

      .modal-body {
        padding: 24px;
        overflow-y: auto;
        max-height: 60vh;
      }

      .modal-footer {
        padding: 16px 24px;
        border-top: 1px solid var(--border-color);
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }

      /* è¡¨å–®å…ƒç´  */
      .form-input {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid var(--border-color);
        border-radius: 10px;
        font-size: 14px;
        transition: all 0.2s;
      }

      .form-input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(217, 119, 6, 0.1);
      }

      /* åœ–å±¤é¸æ“‡åˆ—è¡¨ */
      .layer-select-item {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        transition: background 0.15s;
      }

      .layer-select-item:hover {
        background: var(--hover-bg);
      }

      .layer-select-item.selected {
        background: #fef3c7;
      }

      .layer-select-item input[type="checkbox"] {
        width: 18px;
        height: 18px;
        margin-right: 12px;
        cursor: pointer;
        accent-color: var(--primary);
      }

      /* è¼‰å…¥å‹•ç•« */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
      }

      .loading-overlay.show {
        opacity: 1;
        visibility: visible;
      }

      .spinner {
        width: 48px;
        height: 48px;
        border: 4px solid var(--border-color);
        border-top-color: var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      .loading-text {
        margin-top: 16px;
        font-size: 14px;
        color: var(--text-secondary);
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* é€šçŸ¥ */
      .notification {
        position: fixed;
        bottom: 24px;
        right: 24px;
        padding: 16px 20px;
        background: white;
        border-radius: 12px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
        transform: translateY(100px);
        opacity: 0;
        transition: all 0.3s;
        z-index: 1000;
      }

      .notification.show {
        transform: translateY(0);
        opacity: 1;
      }

      .notification.success {
        border-left: 4px solid #22c55e;
      }

      .notification.error {
        border-left: 4px solid #ef4444;
      }

      .notification.info {
        border-left: 4px solid #3b82f6;
      }

      /* éš±è—å…ƒç´  */
      #fileInput {
        display: none;
      }

      .hidden {
        display: none !important;
      }

      /* ç©ºç‹€æ…‹ */
      .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: var(--text-muted);
      }

      .empty-state-icon {
        font-size: 48px;
        margin-bottom: 16px;
        opacity: 0.5;
      }

      .empty-state-text {
        font-size: 14px;
      }

      /* å¿«é€Ÿæ“ä½œæŒ‰éˆ•çµ„ */
      .quick-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .quick-btn {
        padding: 6px 12px;
        font-size: 12px;
        border: 1px solid var(--border-color);
        background: white;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .quick-btn:hover {
        background: var(--hover-bg);
      }

      /* æœå°‹æ¡† */
      .search-box {
        position: relative;
        margin: 12px 20px;
      }

      .search-box input {
        width: 100%;
        padding: 10px 12px 10px 36px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-size: 13px;
        background: white;
      }

      .search-box input:focus {
        outline: none;
        border-color: var(--primary);
      }

      .search-box::before {
        content: "ğŸ”";
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 12px;
      }

      /* ==================== Canvas é¸å–èˆ‡ç·¨è¼¯åŠŸèƒ½ ==================== */

      /* é¸å–çŸ©å½¢ - çª—é¸æ¨¡å¼ (å·¦åˆ°å³ï¼Œè—è‰²å¯¦ç·š) - AutoCAD Window Selection */
      .selection-rect {
        fill: rgba(59, 130, 246, 0.15);
        stroke: #3b82f6;
        stroke-width: 2;
        /* Window selection ä½¿ç”¨å¯¦ç·šé‚Šæ¡† */
        pointer-events: none;
      }

      /* é¸å–çŸ©å½¢ - æ¡†é¸æ¨¡å¼ (å³åˆ°å·¦ï¼Œç¶ è‰²è™›ç·š) - AutoCAD Crossing Selection */
      .selection-rect-crossing {
        fill: rgba(34, 197, 94, 0.15);
        stroke: #22c55e;
        stroke-width: 2;
        stroke-dasharray: 6, 3;
        pointer-events: none;
      }

      /* AutoCAD é¢¨æ ¼åå­—ç·šæ¸¸æ¨™ */
      .autocad-crosshair {
        cursor: crosshair !important;
      }

      /* Hover æ™‚çš„ Tooltip */
      .segment-tooltip {
        position: fixed;
        background: rgba(30, 30, 30, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        pointer-events: none;
        z-index: 1000;
        white-space: nowrap;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.15s, visibility 0.15s;
      }

      .segment-tooltip.show {
        opacity: 1;
        visibility: visible;
      }

      /* æª¢è¦–æ¨¡å¼æŒ‰éˆ•æ´»å‹•ç‹€æ…‹ */
      .tool-btn.inspect-active {
        background: linear-gradient(135deg, #3b82f6, #2563eb) !important;
        color: white !important;
        border-color: #3b82f6 !important;
      }

      /* ==================== çµ±è¨ˆåŠŸèƒ½æ¨£å¼ ==================== */

      /* ç•¶å‰é¸å–è³‡è¨Š */
      .selection-info {
        font-size: 12px;
        color: var(--text-muted);
        text-align: center;
        padding: 10px;
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 8px;
      }

      .selection-info.has-selection {
        color: var(--primary);
        background: #fef3c7;
        border-color: var(--primary-light);
      }

      /* çµ±è¨ˆçµæœåˆ—è¡¨å®¹å™¨ */
      .saved-stats-list {
        flex: 1;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 4px;
        min-height: 150px;
        max-height: 400px;
      }

      /* çµ±è¨ˆçµæœå¡ç‰‡ */
      .stats-result-card {
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 12px;
        overflow: hidden;
        transition: all 0.2s;
        flex-shrink: 0;
      }

      .stats-result-card:hover {
        border-color: var(--primary-light);
        box-shadow: 0 2px 8px rgba(217, 119, 6, 0.15);
      }

      .stats-result-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 14px;
        background: linear-gradient(135deg, #f8f8f7, #f0eeeb);
        border-bottom: 1px solid var(--border-color);
      }

      .stats-result-title {
        font-size: 13px;
        font-weight: 600;
        color: var(--text-primary);
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .stats-result-actions {
        display: flex;
        gap: 4px;
      }

      .stats-result-actions button {
        width: 24px;
        height: 24px;
        border: none;
        background: transparent;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0.6;
        transition: all 0.15s;
      }

      .stats-result-actions button:hover {
        background: rgba(0, 0, 0, 0.08);
        opacity: 1;
      }

      .stats-result-actions button.delete:hover {
        background: #fef2f2;
        color: #ef4444;
      }

      .stats-result-body {
        padding: 12px 14px;
      }

      .stats-result-summary {
        display: flex;
        justify-content: space-between;
        padding: 8px 0;
        border-bottom: 1px solid var(--border-color);
      }

      .stats-result-summary:last-child {
        border-bottom: none;
      }

      .stats-result-label {
        font-size: 12px;
        color: var(--text-secondary);
      }

      .stats-result-value {
        font-size: 13px;
        font-weight: 600;
        color: var(--text-primary);
      }

      .stats-result-total {
        background: linear-gradient(135deg, #fef3c7, #fde68a);
        padding: 10px 14px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .stats-result-total .label {
        font-size: 12px;
        font-weight: 500;
        color: var(--primary-dark);
      }

      .stats-result-total .value {
        font-size: 16px;
        font-weight: 700;
        color: var(--primary-dark);
      }

      /* çµ±è¨ˆçµæœå±¤ç´šå±•é–‹ */
      .stats-layer-list {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
      }

      .stats-layer-list.expanded {
        max-height: 300px;
        overflow-y: auto;
      }

      .stats-layer-item {
        display: flex;
        justify-content: space-between;
        padding: 6px 14px;
        font-size: 11px;
        border-bottom: 1px solid #f5f5f4;
      }

      .stats-layer-item:last-child {
        border-bottom: none;
      }

      .stats-layer-name {
        color: var(--text-secondary);
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .stats-layer-name .color-dot {
        width: 8px;
        height: 8px;
        border-radius: 2px;
      }

      .stats-layer-length {
        font-weight: 500;
        color: var(--text-primary);
      }

      /* çµ±è¨ˆé è¦½ */
      .stats-preview {
        background: #f7f7f5;
        border-radius: 8px;
        padding: 12px;
        max-height: 250px;
        overflow-y: auto;
      }

      .stats-preview-row {
        display: flex;
        justify-content: space-between;
        padding: 6px 0;
        border-bottom: 1px solid var(--border-color);
        font-size: 12px;
      }

      .stats-preview-row:last-child {
        border-bottom: none;
      }

      .stats-preview-total {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 2px solid var(--primary);
        display: flex;
        justify-content: space-between;
        font-weight: 600;
      }

      /* å±•é–‹/æ”¶åˆæŒ‰éˆ• */
      .expand-btn {
        font-size: 10px;
        cursor: pointer;
        user-select: none;
      }

      /* ==================== é¡å‹æŒ‡æ´¾åŠŸèƒ½æ¨£å¼ ==================== */

      /* é¡å‹é¸æ“‡é …ç›® */
      .type-option {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s;
        margin-bottom: 8px;
      }

      .type-option:hover {
        border-color: var(--primary-light);
        background: #fef9f3;
      }

      .type-option .color-swatch {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        flex-shrink: 0;
      }

      .type-option .type-name {
        flex: 1;
        font-size: 13px;
        font-weight: 500;
      }

      .type-option .type-count {
        font-size: 11px;
        color: var(--text-muted);
      }

      .type-option .assign-btn {
        padding: 4px 10px;
        font-size: 11px;
        background: var(--primary);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.15s;
      }

      .type-option .assign-btn:hover {
        background: var(--primary-dark);
      }

      /* ç„¡é¡å‹æç¤º */
      .no-types-hint {
        text-align: center;
        padding: 16px;
        color: var(--text-muted);
        font-size: 12px;
        background: #f9f9f8;
        border-radius: 8px;
      }
    </style>
  </head>

  <body>
    <!-- è¼‰å…¥å‹•ç•« -->
    <div class="loading-overlay" id="loading">
      <div class="spinner"></div>
      <div class="loading-text">è™•ç†ä¸­...</div>
    </div>

    <!-- é€šçŸ¥è¨Šæ¯ -->
    <div class="notification" id="notification"></div>

    <!-- ç·šæ®µæ‡¸åœ Tooltip -->
    <div class="segment-tooltip" id="segmentTooltip">
      <span id="tooltipContent"></span>
    </div>

    <!-- ä¸»å®¹å™¨ -->
    <div class="app-container">
      <!-- å·¦å´å´é‚Šæ¬„ -->
      <aside class="sidebar" id="sidebar">
        <!-- æ‘ºç–ŠæŒ‰éˆ• -->
        <button
          class="sidebar-toggle"
          id="sidebarToggle"
          title="å±•é–‹/æ”¶åˆå´é‚Šæ¬„"
        >
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>

        <!-- å´é‚Šæ¬„é ­éƒ¨ -->
        <div class="sidebar-header">
          <div class="sidebar-logo">
            <div class="sidebar-logo-icon">ğŸ—ï¸</div>
            <span class="sidebar-logo-text">ç‰†é‡è¨ˆç®—</span>
          </div>
          <div class="tab-switch">
            <button class="tab-btn active" data-tab="layers">åœ–å±¤</button>
            <button class="tab-btn" data-tab="stats">çµ±è¨ˆ</button>
          </div>
        </div>

        <!-- å´é‚Šæ¬„å…§å®¹ -->
        <div class="sidebar-content">
          <!-- åœ–å±¤é¢æ¿ -->
          <div class="tab-panel active" id="layersPanel">
            <div class="sidebar-actions">
              <button class="btn btn-primary" id="uploadBtn">
                <span>ğŸ“</span> ä¸Šå‚³ DXF æª”æ¡ˆ
              </button>
              <button
                class="btn btn-secondary"
                id="manageLayersBtn"
                style="display: none"
              >
                <span>âš™ï¸</span> ç®¡ç†é¡¯ç¤ºåœ–å±¤
              </button>
              <button
                class="btn btn-secondary"
                id="layerCalcSettingsBtn"
                style="display: none"
              >
                <span>ğŸ“</span> åœ–å±¤è¨ˆç®—è¨­å®š
              </button>
              <div class="file-status" id="fileStatus">å°šæœªé¸æ“‡æª”æ¡ˆ</div>
            </div>

            <div
              class="layer-management"
              id="layerManagement"
              style="display: none"
            >
              <span class="layer-count">
                é¡¯ç¤º <strong id="layerCount">0</strong> å€‹åœ–å±¤
              </span>
              <div class="quick-actions">
                <button
                  class="quick-btn"
                  onclick="toggleAllLayersVisible(true)"
                >
                  å…¨é¡¯ç¤º
                </button>
                <button
                  class="quick-btn"
                  onclick="toggleAllLayersVisible(false)"
                >
                  å…¨éš±è—
                </button>
              </div>
            </div>

            <div class="search-box" id="layerSearchBox" style="display: none">
              <input
                type="text"
                id="sidebarSearchInput"
                placeholder="æœå°‹åœ–å±¤..."
                oninput="filterSidebarLayers()"
              />
            </div>

            <div class="layer-list" id="layerList">
              <div class="empty-state">
                <div class="empty-state-icon">ğŸ“„</div>
                <div class="empty-state-text">è«‹å…ˆä¸Šå‚³ DXF æª”æ¡ˆ</div>
              </div>
            </div>
          </div>

          <!-- çµ±è¨ˆé¢æ¿ -->
          <div class="tab-panel" id="statsPanel">
            <div class="stats-content">
              <!-- æª”æ¡ˆè³‡è¨Šå€ -->
              <div class="stats-section">
                <div class="stats-section-title">æª”æ¡ˆè³‡è¨Š</div>
                <div class="stats-card">
                  <div class="stats-row">
                    <span class="stats-label">æª”æ¡ˆåç¨±</span>
                    <span class="stats-value" id="fileName">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-label">åœ–å±¤æ•¸é‡</span>
                    <span class="stats-value" id="layerCountInfo">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-label">ç·šæ®µç¸½æ•¸</span>
                    <span class="stats-value" id="segmentCountInfo">-</span>
                  </div>
                </div>
              </div>

              <!-- çµ±è¨ˆæ“ä½œå€ -->
              <div class="stats-section">
                <div class="stats-section-title">é¸å–çµ±è¨ˆ</div>
                <button
                  class="btn btn-primary"
                  id="calculateStatsBtn"
                  style="width: 100%; margin-bottom: 12px"
                >
                  <span>ğŸ“Š</span> çµ±è¨ˆé¸å–çš„ç‰©ä»¶
                </button>
                <div id="currentSelectionInfo" class="selection-info">
                  å°šæœªé¸å–ç‰©ä»¶
                </div>
              </div>

              <!-- å·²å„²å­˜çš„çµ±è¨ˆçµæœåˆ—è¡¨ -->
              <div
                class="stats-section"
                style="
                  flex: 1;
                  display: flex;
                  flex-direction: column;
                  min-height: 0;
                "
              >
                <div
                  class="stats-section-title"
                  style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                  "
                >
                  <span>çµ±è¨ˆçµæœ</span>
                  <span
                    id="savedStatsCount"
                    style="font-size: 11px; color: var(--text-muted)"
                    >0 ç­†</span
                  >
                </div>
                <div id="savedStatsList" class="saved-stats-list">
                  <div class="empty-state" style="padding: 30px 20px">
                    <div
                      style="font-size: 32px; margin-bottom: 8px; opacity: 0.5"
                    >
                      ğŸ“‹
                    </div>
                    <div style="font-size: 13px">
                      é¸å–ç‰©ä»¶å¾Œé»æ“Šã€Œçµ±è¨ˆé¸å–çš„ç‰©ä»¶ã€
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </aside>

      <!-- ä¸»å…§å®¹å€ -->
      <main class="main-content">
        <!-- é ‚éƒ¨å·¥å…·åˆ— -->
        <div class="toolbar">
          <div class="toolbar-left">
            <span class="toolbar-title" id="canvasTitle">çµæ§‹å¹³é¢åœ–</span>
            <span class="toolbar-info" id="infoText">ç­‰å¾…ä¸Šå‚³ DXF æª”æ¡ˆ...</span>
          </div>
          <div class="toolbar-tools">
            <button
              class="tool-btn"
              id="assignTypeBtn"
              title="æŒ‡æ´¾é¡å‹ - ç‚ºé¸å–çš„ç‰©ä»¶è¨­å®šè‡ªå®šç¾©é¡å‹"
            >
              ğŸ·ï¸
            </button>
            <button
              class="tool-btn"
              id="inspectModeBtn"
              title="æª¢è¦–æ¨¡å¼ - æ‡¸åœé¡¯ç¤ºç‰©ä»¶è³‡è¨Š (æŒ‰ I éµåˆ‡æ›)"
            >
              ğŸ‘ï¸
            </button>
          </div>
        </div>

        <!-- ç•«å¸ƒå€åŸŸ -->
        <div class="canvas-wrapper" id="canvasContainer">
          <canvas id="mainCanvas"></canvas>
        </div>

        <!-- ç‹€æ…‹åˆ— -->
        <div class="statusbar">
          <span id="statusLeft">æº–å‚™å°±ç·’ - è«‹ä¸Šå‚³ DXF æª”æ¡ˆé–‹å§‹</span>
          <span id="statusRight">åº§æ¨™: 0, 0 | ç¸®æ”¾: 100%</span>
        </div>
      </main>
    </div>

    <!-- éš±è—çš„æª”æ¡ˆè¼¸å…¥ -->
    <input type="file" id="fileInput" accept=".dxf" />

    <!-- æ–°å¢ç‰†é¡å‹å°è©±æ¡† -->
    <div class="modal-overlay" id="categoryModal">
      <div class="modal">
        <div class="modal-header">
          <span class="modal-title">è¨­å®šç‰†é¡å‹</span>
          <button class="modal-close" onclick="closeCategoryModal()">
            &times;
          </button>
        </div>
        <div class="modal-body">
          <div id="categoryFormList">
            <!-- å‹•æ…‹ç”Ÿæˆé¡å‹è¡¨å–® -->
          </div>
          <button
            class="btn btn-outline"
            style="width: 100%; margin-top: 10px"
            onclick="addCategoryRow()"
          >
            + æ–°å¢é¡å‹
          </button>
        </div>
        <div class="modal-footer">
          <button class="btn btn-outline" onclick="closeCategoryModal()">
            å–æ¶ˆ
          </button>
          <button class="btn btn-primary" onclick="saveCategories()">
            å„²å­˜
          </button>
        </div>
      </div>
    </div>

    <!-- æ–°å¢æ£Ÿ/æ¨“å±¤å°è©±æ¡† -->
    <div class="modal-overlay" id="structureModal">
      <div class="modal">
        <div class="modal-header">
          <span class="modal-title" id="structureModalTitle">æ–°å¢çµæ§‹ç‰©</span>
          <button class="modal-close" onclick="closeStructureModal()">
            &times;
          </button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label class="form-label">åç¨±</label>
            <input
              type="text"
              class="form-input"
              id="structureName"
              placeholder="ä¾‹å¦‚ï¼šAæ£Ÿã€B1F"
            />
          </div>
          <div class="form-group" id="floorRangeGroup" style="display: none">
            <label class="form-label">æ¨“å±¤ç¯„åœï¼ˆé¸å¡«ï¼‰</label>
            <input
              type="text"
              class="form-input"
              id="floorRange"
              placeholder="ä¾‹å¦‚ï¼š7~8F"
            />
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-outline" onclick="closeStructureModal()">
            å–æ¶ˆ
          </button>
          <button class="btn btn-primary" onclick="saveStructure()">
            æ–°å¢
          </button>
        </div>
      </div>
    </div>

    <!-- åœ–å±¤é¸æ“‡å°è©±æ¡† -->
    <div class="modal-overlay" id="layerSelectModal">
      <div class="modal" style="width: 600px; max-width: 90%">
        <div class="modal-header">
          <span class="modal-title">ğŸ“‹ é¸æ“‡è¦é¡¯ç¤ºçš„åœ–å±¤</span>
          <button class="modal-close" onclick="closeLayerSelectModal()">
            &times;
          </button>
        </div>
        <div class="modal-body" style="max-height: 60vh">
          <div
            style="
              margin-bottom: 15px;
              display: flex;
              justify-content: space-between;
              align-items: center;
            "
          >
            <span style="font-size: 13px; color: #666">
              å…± <span id="totalLayerCount">0</span> å€‹åœ–å±¤ï¼Œå·²é¸æ“‡
              <span id="selectedLayerCount">0</span> å€‹
            </span>
            <div style="display: flex; gap: 10px">
              <button
                class="btn btn-outline"
                style="padding: 6px 12px; font-size: 12px"
                onclick="selectAllLayers()"
              >
                å…¨é¸
              </button>
              <button
                class="btn btn-outline"
                style="padding: 6px 12px; font-size: 12px"
                onclick="deselectAllLayers()"
              >
                å…¨ä¸é¸
              </button>
              <button
                class="btn btn-outline"
                style="padding: 6px 12px; font-size: 12px"
                onclick="selectWallLayers()"
              >
                åªé¸ç‰†é¡
              </button>
            </div>
          </div>
          <div style="margin-bottom: 10px">
            <input
              type="text"
              class="form-input"
              id="modalSearchInput"
              placeholder="ğŸ” æœå°‹åœ–å±¤åç¨±..."
              style="width: 100%"
              oninput="filterLayerList()"
            />
          </div>
          <div
            id="layerSelectList"
            style="
              max-height: 400px;
              overflow-y: auto;
              border: 1px solid #eee;
              border-radius: 4px;
            "
          >
            <!-- å‹•æ…‹ç”Ÿæˆåœ–å±¤åˆ—è¡¨ -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-outline" onclick="closeLayerSelectModal()">
            å–æ¶ˆ
          </button>
          <button class="btn btn-primary" onclick="confirmLayerSelection()">
            ç¢ºèªé¸æ“‡
          </button>
        </div>
      </div>
    </div>

    <!-- çµ±è¨ˆçµæœå‘½åå°è©±æ¡† -->
    <div class="modal-overlay" id="statsNameModal">
      <div class="modal" style="width: 450px">
        <div class="modal-header">
          <span class="modal-title">ğŸ“Š å„²å­˜çµ±è¨ˆçµæœ</span>
          <button class="modal-close" onclick="closeStatsNameModal()">
            &times;
          </button>
        </div>
        <div class="modal-body">
          <div style="margin-bottom: 16px">
            <label
              style="
                display: block;
                font-size: 13px;
                font-weight: 500;
                margin-bottom: 8px;
              "
              >çµ±è¨ˆåç¨±</label
            >
            <input
              type="text"
              class="form-input"
              id="statsNameInput"
              placeholder="ä¾‹å¦‚ï¼šAæ£Ÿ 1F å¤–ç‰†"
              style="width: 100%"
            />
          </div>
          <div id="statsPreview" class="stats-preview">
            <!-- çµ±è¨ˆé è¦½ -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-outline" onclick="closeStatsNameModal()">
            å–æ¶ˆ
          </button>
          <button class="btn btn-primary" onclick="saveStatsResult()">
            <span>ğŸ’¾</span> å„²å­˜çµ±è¨ˆ
          </button>
        </div>
      </div>
    </div>

    <!-- é¡å‹æŒ‡æ´¾å°è©±æ¡† -->
    <div class="modal-overlay" id="assignTypeModal">
      <div class="modal" style="width: 420px">
        <div class="modal-header">
          <span class="modal-title">ğŸ·ï¸ æŒ‡æ´¾é¡å‹</span>
          <button class="modal-close" onclick="closeAssignTypeModal()">
            &times;
          </button>
        </div>
        <div class="modal-body">
          <div
            style="
              margin-bottom: 16px;
              font-size: 13px;
              color: var(--text-secondary);
            "
          >
            å·²é¸å– <strong id="assignTypeCount">0</strong> å€‹ç‰©ä»¶
          </div>

          <!-- ç¾æœ‰é¡å‹åˆ—è¡¨ -->
          <div id="existingTypesList" style="margin-bottom: 16px">
            <!-- å‹•æ…‹ç”Ÿæˆ -->
          </div>

          <!-- æ–°å¢é¡å‹å€å¡Š -->
          <div
            style="border-top: 1px solid var(--border-color); padding-top: 16px"
          >
            <div style="font-size: 13px; font-weight: 600; margin-bottom: 12px">
              â• å»ºç«‹æ–°é¡å‹
            </div>
            <div style="display: flex; gap: 10px; align-items: flex-end">
              <div style="flex: 1">
                <label
                  style="display: block; font-size: 12px; margin-bottom: 4px"
                  >é¡å‹åç¨±</label
                >
                <input
                  type="text"
                  class="form-input"
                  id="newTypeName"
                  placeholder="ä¾‹å¦‚ï¼šå®¤å¤–ç‰†"
                  style="width: 100%"
                />
              </div>
              <div>
                <label
                  style="display: block; font-size: 12px; margin-bottom: 4px"
                  >é¡è‰²</label
                >
                <input
                  type="color"
                  id="newTypeColor"
                  value="#E74C3C"
                  style="
                    width: 50px;
                    height: 36px;
                    border: 1px solid var(--border-color);
                    border-radius: 6px;
                    cursor: pointer;
                  "
                />
              </div>
              <button
                class="btn btn-primary"
                onclick="createAndAssignType()"
                style="height: 36px"
              >
                å»ºç«‹ä¸¦æŒ‡æ´¾
              </button>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-outline" onclick="closeAssignTypeModal()">
            å–æ¶ˆ
          </button>
          <button
            class="btn btn-outline"
            onclick="clearSegmentTypes()"
            style="color: #ef4444"
          >
            ğŸ—‘ï¸ æ¸…é™¤é¡å‹
          </button>
        </div>
      </div>
    </div>

    <!-- åœ–å±¤è¨ˆç®—è¨­å®šå°è©±æ¡† -->
    <div class="modal-overlay" id="layerCalcSettingsModal">
      <div class="modal" style="width: 600px">
        <div class="modal-header">
          <span class="modal-title">ğŸ“ åœ–å±¤è¨ˆç®—è¨­å®š</span>
          <button class="modal-close" onclick="closeLayerCalcSettingsModal()">
            &times;
          </button>
        </div>
        <div class="modal-body">
          <div
            style="
              margin-bottom: 16px;
              font-size: 13px;
              color: var(--text-secondary);
            "
          >
            <strong>å¹³è¡Œç·šæª¢æ¸¬æ³•ï¼š</strong
            >è¨­å®šç‰†åšå¾Œï¼Œç³»çµ±æœƒè‡ªå‹•æª¢æ¸¬åŒåœ–å±¤çš„å¹³è¡Œé›™ç·šç‰†ï¼Œåªè¨ˆç®—è¼ƒé•·çš„ç·šæ®µã€‚
          </div>

          <!-- åœ–å±¤è¨­å®šåˆ—è¡¨ -->
          <div
            style="
              max-height: 400px;
              overflow-y: auto;
              border: 1px solid var(--border-color);
              border-radius: 8px;
            "
          >
            <table
              style="width: 100%; border-collapse: collapse; font-size: 13px"
            >
              <thead>
                <tr style="background: #f7f7f5; position: sticky; top: 0">
                  <th
                    style="
                      padding: 10px 12px;
                      text-align: left;
                      border-bottom: 1px solid var(--border-color);
                    "
                  >
                    åœ–å±¤åç¨±
                  </th>
                  <th
                    style="
                      padding: 10px 12px;
                      text-align: center;
                      width: 100px;
                      border-bottom: 1px solid var(--border-color);
                    "
                    title="ç‰†åš(cm)ï¼šè¨­å®šå¾Œç³»çµ±æœƒè‡ªå‹•åµæ¸¬åŒåœ–å±¤ä¸­è·é›¢=ç‰†åšçš„å¹³è¡Œç·šå°ï¼Œåªè¨ˆç®—è¼ƒé•·è€…"
                  >
                    ç‰†åš(cm)
                  </th>
                </tr>
              </thead>
              <tbody id="layerCalcSettingsList">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
              </tbody>
            </table>
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="btn btn-outline"
            onclick="closeLayerCalcSettingsModal()"
          >
            å–æ¶ˆ
          </button>
          <button class="btn btn-primary" onclick="saveLayerCalcSettings()">
            <span>ğŸ’¾</span> å„²å­˜è¨­å®š
          </button>
        </div>
      </div>
    </div>

    <script>
      // ==================== å…¨åŸŸç‹€æ…‹ ====================
      const state = {
        projectId: null,
        segments: [],
        allSegments: [], // æ‰€æœ‰ç·šæ®µï¼ˆæœªç¯©é¸ï¼‰
        categories: [],
        buildings: [],
        floors: [],
        selectedSegments: [],
        selectedBuilding: null,
        selectedFloor: null,
        currentTool: "select",
        zoom: 1,
        panX: 0,
        panY: 0,
        isDragging: false,
        dragStart: { x: 0, y: 0 },
        showGrid: true,
        structureModalMode: "building", // 'building' or 'floor'
        // æ–°å¢ï¼šæ»‘é¼ ä¸­éµæ‹–æ›³å¹³ç§»ç‹€æ…‹
        isMiddleMousePanning: false,
        middleMouseStart: { x: 0, y: 0, panX: 0, panY: 0 },
        // æ–°å¢ï¼šåœ–å±¤é¡è‰²å°æ‡‰è¡¨
        layerColors: {},
        // æ–°å¢ï¼šåœ–å±¤å¯è¦‹æ€§ç‹€æ…‹ (true = é¡¯ç¤º, false = éš±è—)
        layerVisibility: {},
        // æ–°å¢ï¼šæ‰€æœ‰åœ–å±¤è³‡è¨Šï¼ˆç”¨æ–¼é¸æ“‡è¦–çª—ï¼‰
        allLayers: {},
        // æ–°å¢ï¼šä½¿ç”¨è€…é¸æ“‡çš„åœ–å±¤åˆ—è¡¨ï¼ˆç›®å‰é¸ä¸­çš„ï¼‰
        selectedLayers: [],
        // æ–°å¢ï¼šæŒä¹…åŒ–çš„åœ–å±¤åˆ—è¡¨ï¼ˆæ›¾è¢«é¸å–éçš„ï¼Œä¸æœƒå› å–æ¶ˆå‹¾é¸è€Œæ¶ˆå¤±ï¼‰
        permanentLayers: [],
        // æ–°å¢ï¼šæš«å­˜çš„è§£æè³‡æ–™ï¼ˆåœ–å±¤é¸æ“‡å‰ï¼‰
        pendingParseData: null,
        pendingFilename: null,
        // DXF å–®ä½è¨­å®š
        dimscale: 1.0, // DIMSCALEï¼ˆèˆŠç‰ˆï¼Œä¿ç•™ç›¸å®¹æ€§ï¼‰
        insunits: 0, // INSUNITS å–®ä½ä»£ç¢¼ï¼ˆä¸»è¦ä½¿ç”¨ï¼‰
        // INSUNITS å°ç…§ï¼š0=ç„¡å–®ä½, 1=è‹±å‹, 2=è‹±å°º, 4=æ¯«ç±³, 5=å…¬åˆ†, 6=å…¬å°º
        // æ–°å¢ï¼šæ¡†é¸åŠŸèƒ½ç‹€æ…‹ (AutoCAD é¢¨æ ¼ï¼šæŒ‰ä½æ‹–æ›³)
        isBoxSelecting: false, // æ­£åœ¨é€²è¡Œæ¡†é¸ï¼ˆå·²è¶…éé–¾å€¼ï¼‰
        potentialBoxSelect: false, // æº–å‚™æ¡†é¸ï¼ˆæŒ‰ä½å·¦éµï¼Œå°šæœªè¶…éæ‹–æ›³é–¾å€¼ï¼‰
        boxSelectStart: null, // { x, y } è¢å¹•åº§æ¨™ - æ¡†é¸èµ·é»
        boxSelectCurrent: null, // { x, y } è¢å¹•åº§æ¨™ - ç•¶å‰æ»‘é¼ ä½ç½®
        boxSelectThreshold: 5, // æ‹–æ›³è·é›¢é–¾å€¼ï¼ˆåƒç´ ï¼‰ï¼Œè¶…éæ­¤å€¼æ‰é–‹å§‹æ¡†é¸
        // æ–°å¢ï¼šæ‡¸åœæª¢è¦–åŠŸèƒ½
        inspectMode: false, // æª¢è¦–æ¨¡å¼é–‹é—œ
        hoveredSegment: null, // ç•¶å‰æ»‘é¼ æ‡¸åœçš„ç·šæ®µ
        // æ–°å¢ï¼šçµ±è¨ˆåŠŸèƒ½
        savedStats: [], // å·²å„²å­˜çš„çµ±è¨ˆçµæœé™£åˆ—
        pendingStats: null, // å¾…å„²å­˜çš„çµ±è¨ˆçµæœï¼ˆæš«å­˜ï¼‰
        statsIdCounter: 0, // çµ±è¨ˆçµæœ ID è¨ˆæ•¸å™¨
        // æ–°å¢ï¼šè‡ªå®šç¾©é¡å‹åŠŸèƒ½
        customTypes: [], // ä½¿ç”¨è€…å®šç¾©çš„é¡å‹é™£åˆ— [{ id, name, color }]
        customTypeIdCounter: 0, // é¡å‹ ID è¨ˆæ•¸å™¨
        // æ–°å¢ï¼šåœ–å±¤è¨ˆç®—è¨­å®š { layerName: { coefficient: 0.5, thicknessThreshold: 0.2 } }
        layerSettings: {},
      };

      // ==================== å–®ä½è½‰æ› ====================
      // INSUNITS å–®ä½ä»£ç¢¼å°ç…§è¡¨
      // åƒè€ƒ: AutoCAD DXF $INSUNITS æ¨™é ­è®Šæ•¸
      const INSUNITS_MAP = {
        0: { name: "ç„¡å–®ä½", toMeters: 0.001 }, // é è¨­ç•¶ä½œæ¯«ç±³
        1: { name: "è‹±å‹", toMeters: 0.0254 }, // 1 inch = 0.0254 m
        2: { name: "è‹±å°º", toMeters: 0.3048 }, // 1 foot = 0.3048 m
        3: { name: "è‹±é‡Œ", toMeters: 1609.344 }, // 1 mile = 1609.344 m
        4: { name: "æ¯«ç±³", toMeters: 0.001 }, // 1 mm = 0.001 m
        5: { name: "å…¬åˆ†", toMeters: 0.01 }, // 1 cm = 0.01 m
        6: { name: "å…¬å°º", toMeters: 1.0 }, // 1 m = 1 m
        7: { name: "å…¬é‡Œ", toMeters: 1000.0 }, // 1 km = 1000 m
        8: { name: "å¾®è‹±å‹", toMeters: 0.0000000254 },
        9: { name: "å¯†çˆ¾", toMeters: 0.0000254 },
        10: { name: "ç¢¼", toMeters: 0.9144 },
        11: { name: "åŸƒ", toMeters: 1e-10 },
        12: { name: "å¥ˆç±³", toMeters: 1e-9 },
        13: { name: "å¾®ç±³", toMeters: 1e-6 },
        14: { name: "åˆ†ç±³", toMeters: 0.1 },
        15: { name: "åç±³", toMeters: 10.0 },
        16: { name: "ç™¾ç±³", toMeters: 100.0 },
        17: { name: "ç™¾è¬å…¬é‡Œ", toMeters: 1e9 },
        18: { name: "å¤©æ–‡å–®ä½", toMeters: 1.495979e11 },
        19: { name: "å…‰å¹´", toMeters: 9.4607e15 },
        20: { name: "ç§’å·®è·", toMeters: 3.0857e16 },
      };

      /**
       * å°‡ DXF åŸå§‹é•·åº¦è½‰æ›ç‚ºå…¬å°º
       * @param {number} length - DXF åŸå§‹é•·åº¦ï¼ˆç¹ªåœ–å–®ä½ï¼‰
       * @param {number} insunits - INSUNITS å–®ä½ä»£ç¢¼
       * @returns {number} - é•·åº¦ï¼ˆå…¬å°ºï¼‰
       */
      function convertToMeters(length, insunits) {
        const unitInfo = INSUNITS_MAP[insunits] || INSUNITS_MAP[0];
        return length * unitInfo.toMeters;
      }

      /**
       * å–å¾—å–®ä½åç¨±
       * @param {number} insunits - INSUNITS å–®ä½ä»£ç¢¼
       * @returns {string} - å–®ä½åç¨±
       */
      function getUnitName(insunits) {
        const unitInfo = INSUNITS_MAP[insunits] || INSUNITS_MAP[0];
        return unitInfo.name;
      }

      /**
       * è¨ˆç®—æœ‰æ•ˆç‰†é•·ï¼ˆå¹³è¡Œç·šæª¢æ¸¬å¾Œï¼‰
       * @param {Object} seg - ç·šæ®µç‰©ä»¶
       * @returns {number} - æœ‰æ•ˆç‰†é•·ï¼ˆå…¬å°ºï¼‰ï¼Œå¦‚æœæ˜¯å¹³è¡Œå°ä¸­çš„çŸ­ç·šå‰‡è¿”å› 0
       */
      function getEffectiveWallLength(seg) {
        const lengthInMeters = convertToMeters(seg.length, state.insunits);

        // å¦‚æœè©²ç·šæ®µè¢«æ¨™è¨˜ç‚ºã€Œé…å°ä¸­çš„çŸ­ç·šã€ï¼Œè¿”å› 0ï¼ˆä¸è¨ˆå…¥çµ±è¨ˆï¼‰
        if (seg._isParallelShort) {
          return 0;
        }

        return lengthInMeters;
      }

      /**
       * æª¢æ¸¬ä¸¦æ¨™è¨˜å¹³è¡Œç·šæ®µå°
       * åŒåœ–å±¤å…§ï¼Œè·é›¢ç­‰æ–¼ç‰†åšçš„å¹³è¡Œç·šæ®µï¼Œåªä¿ç•™è¼ƒé•·çš„
       */
      function detectAndMarkParallelWalls() {
        console.log("========================================");
        console.log("[detectAndMarkParallelWalls] é–‹å§‹æª¢æ¸¬å¹³è¡Œç·šæ®µ...");
        console.log("[DEBUG] state.segments æ•¸é‡:", state.segments.length);
        console.log(
          "[DEBUG] state.layerSettings:",
          JSON.stringify(state.layerSettings, null, 2)
        );
        console.log("[DEBUG] state.insunits:", state.insunits);

        // æ¸…é™¤ä¹‹å‰çš„æ¨™è¨˜
        state.segments.forEach((seg) => {
          seg._isParallelShort = false;
          seg._parallelPairId = null;
        });

        // æŒ‰åœ–å±¤åˆ†çµ„
        const layerGroups = {};
        state.segments.forEach((seg) => {
          if (!layerGroups[seg.layer]) {
            layerGroups[seg.layer] = [];
          }
          layerGroups[seg.layer].push(seg);
        });

        console.log(
          "[DEBUG] åœ–å±¤åˆ†çµ„:",
          Object.keys(layerGroups).map(
            (k) => `${k}: ${layerGroups[k].length}æ¢`
          )
        );

        let pairCount = 0;

        // å°æ¯å€‹åœ–å±¤é€²è¡Œå¹³è¡Œç·šæª¢æ¸¬
        Object.entries(layerGroups).forEach(([layerName, segments]) => {
          const settings = state.layerSettings[layerName] || {};
          const wallThicknessCm = settings.wallThickness || 0;

          console.log(
            `[DEBUG] è™•ç†åœ–å±¤ "${layerName}": ${
              segments.length
            }æ¢ç·šæ®µ, è¨­å®š=${JSON.stringify(settings)}`
          );

          if (wallThicknessCm <= 0) {
            console.log(`[DEBUG] åœ–å±¤ "${layerName}" æ²’æœ‰è¨­å®šç‰†åšï¼Œè·³é`);
            return; // æ²’è¨­å®šç‰†åšå°±è·³é
          }

          // å°‡ cm è½‰ç‚º m ä»¥ä¾¿èˆ‡ distanceInMeters æ¯”è¼ƒ
          const wallThicknessM = wallThicknessCm / 100;
          const toleranceM = 0.01; // å›ºå®šå®¹å·® Â±1cm (0.01m)ï¼Œç¬¦åˆå·¥ç¨‹å¯¦å‹™éœ€æ±‚

          console.log(
            `[DEBUG] åœ–å±¤ ${layerName}: ç‰†åš=${wallThicknessCm}cm = ${wallThicknessM}m, å®¹å·®=Â±${(
              toleranceM * 100
            ).toFixed(2)}cm`
          );

          // æª¢æ¸¬å¹³è¡Œç·šæ®µå°
          let comparisonCount = 0;
          for (let i = 0; i < segments.length; i++) {
            if (segments[i]._parallelPairId) continue; // å·²é…å°

            for (let j = i + 1; j < segments.length; j++) {
              if (segments[j]._parallelPairId) continue; // å·²é…å°

              const seg1 = segments[i];
              const seg2 = segments[j];
              comparisonCount++;

              // æª¢æŸ¥æ˜¯å¦å¹³è¡Œ
              const isParallel = areSegmentsParallel(seg1, seg2);
              if (!isParallel) {
                if (comparisonCount <= 5) {
                  console.log(
                    `[DEBUG] æ¯”è¼ƒ #${comparisonCount}: seg[${i}] vs seg[${j}] - ä¸å¹³è¡Œ`
                  );
                }
                continue;
              }

              // è¨ˆç®—å¹³è¡Œç·šæ®µä¹‹é–“çš„è·é›¢ï¼ˆDXF å–®ä½ï¼‰
              const distance = getParallelSegmentDistance(seg1, seg2);
              // è½‰æ›ç‚ºå…¬å°º
              const distanceInMeters = convertToMeters(
                distance,
                state.insunits
              );
              const distanceCm = distanceInMeters * 100;

              console.log(
                `[DEBUG] æ¯”è¼ƒ #${comparisonCount}: seg[${i}] vs seg[${j}] - å¹³è¡Œ! è·é›¢=${distanceCm.toFixed(
                  2
                )}cm (DXFè·é›¢=${distance.toFixed(2)})`
              );
              console.log(
                `[DEBUG]   seg1: length=${
                  seg1.length
                }, start=(${seg1.startX?.toFixed(2)}, ${seg1.startY?.toFixed(
                  2
                )}), end=(${seg1.endX?.toFixed(2)}, ${seg1.endY?.toFixed(2)})`
              );
              console.log(
                `[DEBUG]   seg2: length=${
                  seg2.length
                }, start=(${seg2.startX?.toFixed(2)}, ${seg2.startY?.toFixed(
                  2
                )}), end=(${seg2.endX?.toFixed(2)}, ${seg2.endY?.toFixed(2)})`
              );
              console.log(
                `[DEBUG]   åˆ¤æ–·: |${distanceCm.toFixed(
                  2
                )} - ${wallThicknessCm}| = ${Math.abs(
                  distanceCm - wallThicknessCm
                ).toFixed(2)}cm, å®¹å·®=${(toleranceM * 100).toFixed(2)}cm`
              );

              // å¦‚æœè·é›¢æ¥è¿‘ç‰†åšï¼Œè¦–ç‚ºé›™ç·šç‰†
              if (Math.abs(distanceInMeters - wallThicknessM) <= toleranceM) {
                pairCount++;
                const pairId = `pair_${pairCount}`;

                seg1._parallelPairId = pairId;
                seg2._parallelPairId = pairId;

                // æ¨™è¨˜è¼ƒçŸ­çš„ç·šæ®µï¼ˆæˆ–å…©æ¢ä¸€æ¨£é•·æ™‚æ¨™è¨˜ç¬¬äºŒæ¢ï¼‰
                const len1 = seg1.length;
                const len2 = seg2.length;

                if (len1 >= len2) {
                  seg2._isParallelShort = true;
                  console.log(
                    `[DEBUG] âœ“ é…å°æˆåŠŸ! seg[${j}] è¢«æ¨™è¨˜ç‚ºçŸ­ç·š (len1=${len1} >= len2=${len2})`
                  );
                } else {
                  seg1._isParallelShort = true;
                  console.log(
                    `[DEBUG] âœ“ é…å°æˆåŠŸ! seg[${i}] è¢«æ¨™è¨˜ç‚ºçŸ­ç·š (len1=${len1} < len2=${len2})`
                  );
                }

                break; // æ‰¾åˆ°é…å°å°±è·³å‡º
              } else {
                console.log(
                  `[DEBUG] âœ— è·é›¢ä¸ç¬¦åˆ: ${distanceCm.toFixed(
                    2
                  )}cm â‰  ${wallThicknessCm}cm (è¶…å‡ºå®¹å·®)`
                );
              }
            }
          }
          console.log(
            `[DEBUG] åœ–å±¤ "${layerName}" å®Œæˆï¼Œå…±æ¯”è¼ƒ ${comparisonCount} æ¬¡`
          );
        });

        // çµ±è¨ˆè¢«æ¨™è¨˜çš„ç·šæ®µ
        const markedCount = state.segments.filter(
          (s) => s._isParallelShort
        ).length;
        console.log(
          `[detectAndMarkParallelWalls] æª¢æ¸¬å®Œæˆï¼Œå…±ç™¼ç¾ ${pairCount} å°å¹³è¡Œç‰†ï¼Œæ¨™è¨˜äº† ${markedCount} æ¢çŸ­ç·š`
        );
        console.log("========================================");
        return pairCount;
      }

      /**
       * é‡å°é¸å–çš„ç·šæ®µé€²è¡Œå¹³è¡Œç‰†åµæ¸¬
       * åªåœ¨ä½¿ç”¨è€…é»æ“Šçµ±è¨ˆæŒ‰éˆ•æ™‚å‘¼å«ï¼Œé¿å…è™•ç†å…¨éƒ¨ç·šæ®µå°è‡´æ•ˆèƒ½å•é¡Œ
       * @param {Array} selectedSegments - ä½¿ç”¨è€…é¸å–çš„ç·šæ®µé™£åˆ—
       * @returns {number} - åµæ¸¬åˆ°çš„å¹³è¡Œå°æ•¸é‡
       */
      function detectParallelWallsInSelection(selectedSegments) {
        console.log("========================================");
        console.log(
          "[detectParallelWallsInSelection] é–‹å§‹æª¢æ¸¬é¸å–ç·šæ®µä¸­çš„å¹³è¡Œç·š..."
        );
        console.log("[DEBUG] é¸å–ç·šæ®µæ•¸é‡:", selectedSegments.length);
        console.log(
          "[DEBUG] state.layerSettings:",
          JSON.stringify(state.layerSettings, null, 2)
        );

        // æ¸…é™¤é¸å–ç·šæ®µçš„æ¨™è¨˜
        selectedSegments.forEach((seg) => {
          seg._isParallelShort = false;
          seg._parallelPairId = null;
        });

        // æŒ‰åœ–å±¤åˆ†çµ„
        const layerGroups = {};
        selectedSegments.forEach((seg) => {
          if (!layerGroups[seg.layer]) {
            layerGroups[seg.layer] = [];
          }
          layerGroups[seg.layer].push(seg);
        });

        console.log(
          "[DEBUG] é¸å–ç·šæ®µåœ–å±¤åˆ†çµ„:",
          Object.keys(layerGroups).map(
            (k) => `${k}: ${layerGroups[k].length}æ¢`
          )
        );

        let pairCount = 0;

        // å°æ¯å€‹åœ–å±¤é€²è¡Œå¹³è¡Œç·šæª¢æ¸¬
        Object.entries(layerGroups).forEach(([layerName, segments]) => {
          const settings = state.layerSettings[layerName] || {};
          const wallThicknessCm = settings.wallThickness || 0;

          console.log(
            `[DEBUG] è™•ç†åœ–å±¤ "${layerName}": ${segments.length}æ¢ç·šæ®µ, ç‰†åš=${wallThicknessCm}cm`
          );

          if (wallThicknessCm <= 0) {
            console.log(
              `[DEBUG] åœ–å±¤ "${layerName}" æ²’æœ‰è¨­å®šç‰†åšï¼Œè·³éå¹³è¡Œåµæ¸¬`
            );
            return;
          }

          // å°‡ cm è½‰ç‚º m ä»¥ä¾¿èˆ‡ distanceInMeters æ¯”è¼ƒ
          const wallThicknessM = wallThicknessCm / 100;
          const toleranceM = 0.01; // å›ºå®šå®¹å·® Â±1cm (0.01m)ï¼Œç¬¦åˆå·¥ç¨‹å¯¦å‹™éœ€æ±‚

          console.log(
            `[DEBUG] åœ–å±¤ ${layerName}: ç‰†åš=${wallThicknessCm}cm = ${wallThicknessM}m, å®¹å·®=Â±${(
              toleranceM * 100
            ).toFixed(2)}cm`
          );

          // æª¢æ¸¬å¹³è¡Œç·šæ®µå°
          for (let i = 0; i < segments.length; i++) {
            if (segments[i]._parallelPairId) continue; // å·²é…å°

            for (let j = i + 1; j < segments.length; j++) {
              if (segments[j]._parallelPairId) continue; // å·²é…å°

              const seg1 = segments[i];
              const seg2 = segments[j];

              // æª¢æŸ¥æ˜¯å¦å¹³è¡Œ
              if (!areSegmentsParallel(seg1, seg2)) continue;

              // è¨ˆç®—å¹³è¡Œç·šæ®µä¹‹é–“çš„è·é›¢ï¼ˆDXF å–®ä½ï¼‰ï¼Œè½‰æ›ç‚ºå…¬å°º
              const distance = getParallelSegmentDistance(seg1, seg2);
              const distanceInMeters = convertToMeters(
                distance,
                state.insunits
              );

              // å¦‚æœè·é›¢æ¥è¿‘ç‰†åšï¼Œè¦–ç‚ºé›™ç·šç‰†
              if (Math.abs(distanceInMeters - wallThicknessM) <= toleranceM) {
                pairCount++;
                const pairId = `pair_${pairCount}`;

                seg1._parallelPairId = pairId;
                seg2._parallelPairId = pairId;

                // æ¨™è¨˜è¼ƒçŸ­çš„ç·šæ®µ
                if (seg1.length >= seg2.length) {
                  seg2._isParallelShort = true;
                  console.log(
                    `[DEBUG] âœ“ é…å°æˆåŠŸ! è¼ƒçŸ­ç·šæ®µè¢«æ¨™è¨˜ (len1=${seg1.length?.toFixed(
                      2
                    )} >= len2=${seg2.length?.toFixed(2)})`
                  );
                } else {
                  seg1._isParallelShort = true;
                  console.log(
                    `[DEBUG] âœ“ é…å°æˆåŠŸ! è¼ƒçŸ­ç·šæ®µè¢«æ¨™è¨˜ (len1=${seg1.length?.toFixed(
                      2
                    )} < len2=${seg2.length?.toFixed(2)})`
                  );
                }

                break; // æ‰¾åˆ°é…å°å°±è·³å‡º
              }
            }
          }
        });

        const markedCount = selectedSegments.filter(
          (s) => s._isParallelShort
        ).length;
        console.log(
          `[detectParallelWallsInSelection] å®Œæˆï¼Œå…±ç™¼ç¾ ${pairCount} å°å¹³è¡Œç‰†ï¼Œæ¨™è¨˜äº† ${markedCount} æ¢çŸ­ç·š`
        );
        console.log("========================================");
        return pairCount;
      }

      /**
       * åˆ¤æ–·å…©æ¢ç·šæ®µæ˜¯å¦å¹³è¡Œ
       */
      function areSegmentsParallel(seg1, seg2) {
        // è¨ˆç®—ç·šæ®µæ–¹å‘å‘é‡
        const v1 = getSegmentVector(seg1);
        const v2 = getSegmentVector(seg2);

        // è¨ˆç®—å‰ç©ï¼ˆå¹³è¡Œæ™‚å‰ç©ç‚º 0ï¼‰
        const cross = v1.x * v2.y - v1.y * v2.x;
        const len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
        const len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);

        if (len1 === 0 || len2 === 0) return false;

        // æ­£è¦åŒ–å¾Œçš„å‰ç©ï¼Œç”¨æ–¼åˆ¤æ–·å¹³è¡Œåº¦
        const normalizedCross = Math.abs(cross) / (len1 * len2);

        // é–¾å€¼ï¼šå°æ–¼ 0.1 è¦–ç‚ºå¹³è¡Œï¼ˆç´„ 5.7 åº¦ï¼‰
        return normalizedCross < 0.1;
      }

      /**
       * å–å¾—ç·šæ®µçš„æ–¹å‘å‘é‡
       */
      function getSegmentVector(seg) {
        if (seg.vertices && seg.vertices.length >= 2) {
          // å¤šæ®µç·šï¼šä½¿ç”¨ç¬¬ä¸€æ®µçš„æ–¹å‘ï¼ˆç°¡åŒ–è™•ç†ï¼‰
          return {
            x: seg.vertices[1][0] - seg.vertices[0][0],
            y: seg.vertices[1][1] - seg.vertices[0][1],
          };
        }
        return {
          x: seg.endX - seg.startX,
          y: seg.endY - seg.startY,
        };
      }

      /**
       * è¨ˆç®—å…©æ¢å¹³è¡Œç·šæ®µä¹‹é–“çš„è·é›¢
       */
      function getParallelSegmentDistance(seg1, seg2) {
        // å–å¾—ç·šæ®µçš„èµ·é»å’Œæ–¹å‘
        const p1 = getSegmentStartPoint(seg1);
        const v1 = getSegmentVector(seg1);
        const p2 = getSegmentStartPoint(seg2);

        // è¨ˆç®— p2 åˆ° seg1 æ‰€åœ¨ç›´ç·šçš„è·é›¢
        const len = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
        if (len === 0) return Infinity;

        // ä½¿ç”¨é»åˆ°ç›´ç·šè·é›¢å…¬å¼
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const distance = Math.abs(dx * v1.y - dy * v1.x) / len;

        return distance;
      }

      /**
       * å–å¾—ç·šæ®µçš„èµ·é»
       */
      function getSegmentStartPoint(seg) {
        if (seg.vertices && seg.vertices.length >= 1) {
          return { x: seg.vertices[0][0], y: seg.vertices[0][1] };
        }
        return { x: seg.startX, y: seg.startY };
      }

      // AutoCAD Color Index (ACI) è½‰ RGB é¡è‰²è¡¨
      // é€™æ˜¯ AutoCAD æ¨™æº–çš„ 256 è‰²èª¿è‰²ç›¤
      const ACI_COLORS = {
        0: "#000000", // ByBlock
        1: "#FF0000", // ç´…è‰²
        2: "#FFFF00", // é»ƒè‰²
        3: "#00FF00", // ç¶ è‰²
        4: "#00FFFF", // é’è‰²
        5: "#0000FF", // è—è‰²
        6: "#FF00FF", // æ´‹ç´…è‰²
        7: "#FFFFFF", // ç™½è‰²/é»‘è‰² (ä¾èƒŒæ™¯)
        8: "#808080", // æ·±ç°è‰²
        9: "#C0C0C0", // æ·ºç°è‰²
        10: "#FF0000",
        11: "#FF7F7F",
        12: "#CC0000",
        13: "#CC6666",
        14: "#990000",
        15: "#994C4C",
        16: "#7F0000",
        17: "#7F3F3F",
        18: "#4C0000",
        19: "#4C2626",
        20: "#FF3F00",
        21: "#FF9F7F",
        22: "#CC3200",
        23: "#CC7F66",
        24: "#992600",
        25: "#995F4C",
        26: "#7F1F00",
        27: "#7F4F3F",
        28: "#4C1300",
        28: "#4C2F26",
        30: "#FF7F00",
        31: "#FFBF7F",
        32: "#CC6600",
        33: "#CC9966",
        34: "#994C00",
        35: "#99724C",
        36: "#7F3F00",
        37: "#7F5F3F",
        38: "#4C2600",
        39: "#4C3926",
        40: "#FFBF00",
        41: "#FFDF7F",
        42: "#CC9900",
        43: "#CCB266",
        44: "#997200",
        45: "#99854C",
        46: "#7F5F00",
        47: "#7F6F3F",
        48: "#4C3900",
        49: "#4C4226",
        50: "#FFFF00",
        51: "#FFFF7F",
        52: "#CCCC00",
        53: "#CCCC66",
        54: "#999900",
        55: "#99994C",
        56: "#7F7F00",
        57: "#7F7F3F",
        58: "#4C4C00",
        59: "#4C4C26",
        60: "#BFFF00",
        61: "#DFFF7F",
        62: "#99CC00",
        63: "#B2CC66",
        64: "#729900",
        65: "#85994C",
        66: "#5F7F00",
        67: "#6F7F3F",
        68: "#394C00",
        69: "#424C26",
        70: "#7FFF00",
        71: "#BFFF7F",
        72: "#66CC00",
        73: "#99CC66",
        74: "#4C9900",
        75: "#72994C",
        76: "#3F7F00",
        77: "#5F7F3F",
        78: "#264C00",
        79: "#394C26",
        80: "#3FFF00",
        81: "#9FFF7F",
        82: "#32CC00",
        83: "#7FCC66",
        84: "#269900",
        85: "#5F994C",
        86: "#1F7F00",
        87: "#4F7F3F",
        88: "#134C00",
        89: "#2F4C26",
        90: "#00FF00",
        91: "#7FFF7F",
        92: "#00CC00",
        93: "#66CC66",
        94: "#009900",
        95: "#4C994C",
        96: "#007F00",
        97: "#3F7F3F",
        98: "#004C00",
        99: "#264C26",
        100: "#00FF3F",
        101: "#7FFF9F",
        102: "#00CC32",
        103: "#66CC7F",
        104: "#009926",
        105: "#4C995F",
        106: "#007F1F",
        107: "#3F7F4F",
        108: "#004C13",
        109: "#264C2F",
        110: "#00FF7F",
        111: "#7FFFBF",
        112: "#00CC66",
        113: "#66CC99",
        114: "#00994C",
        115: "#4C9972",
        116: "#007F3F",
        117: "#3F7F5F",
        118: "#004C26",
        119: "#264C39",
        120: "#00FFBF",
        121: "#7FFFDF",
        122: "#00CC99",
        123: "#66CCB2",
        124: "#009972",
        125: "#4C9985",
        126: "#007F5F",
        127: "#3F7F6F",
        128: "#004C39",
        129: "#264C42",
        130: "#00FFFF",
        131: "#7FFFFF",
        132: "#00CCCC",
        133: "#66CCCC",
        134: "#009999",
        135: "#4C9999",
        136: "#007F7F",
        137: "#3F7F7F",
        138: "#004C4C",
        139: "#264C4C",
        140: "#00BFFF",
        141: "#7FDFFF",
        142: "#0099CC",
        143: "#66B2CC",
        144: "#007299",
        145: "#4C8599",
        146: "#005F7F",
        147: "#3F6F7F",
        148: "#00394C",
        149: "#26424C",
        150: "#007FFF",
        151: "#7FBFFF",
        152: "#0066CC",
        153: "#6699CC",
        154: "#004C99",
        155: "#4C7299",
        156: "#003F7F",
        157: "#3F5F7F",
        158: "#00264C",
        159: "#26394C",
        160: "#003FFF",
        161: "#7F9FFF",
        162: "#0032CC",
        163: "#667FCC",
        164: "#002699",
        165: "#4C5F99",
        166: "#001F7F",
        167: "#3F4F7F",
        168: "#00134C",
        169: "#262F4C",
        170: "#0000FF",
        171: "#7F7FFF",
        172: "#0000CC",
        173: "#6666CC",
        174: "#000099",
        175: "#4C4C99",
        176: "#00007F",
        177: "#3F3F7F",
        178: "#00004C",
        179: "#26264C",
        180: "#3F00FF",
        181: "#9F7FFF",
        182: "#3200CC",
        183: "#7F66CC",
        184: "#260099",
        185: "#5F4C99",
        186: "#1F007F",
        187: "#4F3F7F",
        188: "#13004C",
        189: "#2F264C",
        190: "#7F00FF",
        191: "#BF7FFF",
        192: "#6600CC",
        193: "#9966CC",
        194: "#4C0099",
        195: "#724C99",
        196: "#3F007F",
        197: "#5F3F7F",
        198: "#26004C",
        199: "#39264C",
        200: "#BF00FF",
        201: "#DF7FFF",
        202: "#9900CC",
        203: "#B266CC",
        204: "#720099",
        205: "#854C99",
        206: "#5F007F",
        207: "#6F3F7F",
        208: "#39004C",
        209: "#42264C",
        210: "#FF00FF",
        211: "#FF7FFF",
        212: "#CC00CC",
        213: "#CC66CC",
        214: "#990099",
        215: "#994C99",
        216: "#7F007F",
        217: "#7F3F7F",
        218: "#4C004C",
        219: "#4C264C",
        220: "#FF00BF",
        221: "#FF7FDF",
        222: "#CC0099",
        223: "#CC66B2",
        224: "#990072",
        225: "#994C85",
        226: "#7F005F",
        227: "#7F3F6F",
        228: "#4C0039",
        229: "#4C2642",
        230: "#FF007F",
        231: "#FF7FBF",
        232: "#CC0066",
        233: "#CC6699",
        234: "#99004C",
        235: "#994C72",
        236: "#7F003F",
        237: "#7F3F5F",
        238: "#4C0026",
        239: "#4C2639",
        240: "#FF003F",
        241: "#FF7F9F",
        242: "#CC0032",
        243: "#CC667F",
        244: "#990026",
        245: "#994C5F",
        246: "#7F001F",
        247: "#7F3F4F",
        248: "#4C0013",
        249: "#4C262F",
        250: "#333333",
        251: "#505050",
        252: "#696969",
        253: "#828282",
        254: "#BEBEBE",
        255: "#FFFFFF",
        256: "#000000", // ByLayer - æœƒä½¿ç”¨åœ–å±¤é¡è‰²
      };

      /**
       * å°‡ AutoCAD é¡è‰²ç·¨è™Ÿ (ACI) è½‰æ›ç‚º HEX é¡è‰²ç¢¼
       * @param {number} aciColor - AutoCAD é¡è‰²ç·¨è™Ÿ (0-256)
       * @returns {string} - HEX é¡è‰²ç¢¼ï¼Œä¾‹å¦‚ '#FF0000'
       */
      function aciToHex(aciColor) {
        if (aciColor === undefined || aciColor === null) {
          return "#808080"; // é è¨­ç°è‰²
        }
        // ç¢ºä¿æ˜¯æ•¸å­—
        const colorNum = parseInt(aciColor);
        if (isNaN(colorNum) || colorNum < 0 || colorNum > 256) {
          return "#808080"; // ç„¡æ•ˆé¡è‰²è¿”å›ç°è‰²
        }
        return ACI_COLORS[colorNum] || "#808080";
      }

      // Canvas ç›¸é—œ
      const canvas = document.getElementById("mainCanvas");
      const ctx = canvas.getContext("2d");
      const container = document.getElementById("canvasContainer");

      // ==================== åˆå§‹åŒ– ====================
      function init() {
        resizeCanvas();
        setupEventListeners();
        render();
        loadDefaultCategories();
      }

      function resizeCanvas() {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        render();
      }

      function loadDefaultCategories() {
        // é è¨­ç‰†é¡å‹
        state.categories = [
          {
            id: 1,
            code: "EXT",
            name: "å¤–ç‰†",
            heightType: "æ¨“é«˜-æ¢æ·±",
            color: "#E74C3C",
          },
          {
            id: 2,
            code: "INT",
            name: "å…§ç‰†",
            heightType: "æ¨“é«˜-æ¢æ·±",
            color: "#3498DB",
          },
          {
            id: 3,
            code: "RC",
            name: "RCç‰†",
            heightType: "åŒæ¨“é«˜",
            color: "#2ECC71",
          },
          {
            id: 4,
            code: "PART",
            name: "è¼•éš”é–“",
            heightType: "æ¨“é«˜-æ¢æ·±",
            color: "#F1C40F",
          },
          {
            id: 5,
            code: "BALC",
            name: "é™½å°ç‰†",
            heightType: "1.2m",
            color: "#9B59B6",
          },
          {
            id: 6,
            code: "PARAPET",
            name: "å¥³å…’ç‰†",
            heightType: "1.5m",
            color: "#E67E22",
          },
        ];
        updateCategoryList();
        updateCategoryFilter();
      }

      // ==================== äº‹ä»¶ç›£è½ ====================
      function setupEventListeners() {
        // è¦–çª—å¤§å°æ”¹è®Š
        window.addEventListener("resize", resizeCanvas);

        // æª”æ¡ˆä¸Šå‚³
        document.getElementById("uploadBtn").addEventListener("click", () => {
          document.getElementById("fileInput").click();
        });
        document
          .getElementById("fileInput")
          .addEventListener("change", handleFileSelect);

        // ç®¡ç†åœ–å±¤æŒ‰éˆ•
        const manageLayersBtn = document.getElementById("manageLayersBtn");
        if (manageLayersBtn) {
          manageLayersBtn.addEventListener("click", () => {
            openLayerSelectModal(state.allLayers);
          });
        }

        // åœ–å±¤è¨ˆç®—è¨­å®šæŒ‰éˆ•
        const layerCalcSettingsBtn = document.getElementById(
          "layerCalcSettingsBtn"
        );
        if (layerCalcSettingsBtn) {
          layerCalcSettingsBtn.addEventListener("click", () => {
            openLayerCalcSettingsModal();
          });
        }

        // é ç±¤åˆ‡æ›
        document.querySelectorAll(".tab-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const tabName = btn.dataset.tab;
            switchTab(tabName);
          });
        });

        // å´é‚Šæ¬„æ‘ºç–Šåˆ‡æ›
        const sidebarToggle = document.getElementById("sidebarToggle");
        const sidebar = document.getElementById("sidebar");
        if (sidebarToggle && sidebar) {
          sidebarToggle.addEventListener("click", () => {
            sidebar.classList.toggle("collapsed");
            // æ‘ºç–Šå¾Œéœ€è¦é‡æ–°èª¿æ•´ Canvas å¤§å°
            setTimeout(() => {
              resizeCanvas();
            }, 300);
          });
        }

        // æª¢è¦–æ¨¡å¼æŒ‰éˆ•
        const inspectBtn = document.getElementById("inspectModeBtn");
        if (inspectBtn) {
          inspectBtn.addEventListener("click", () => {
            toggleInspectMode();
          });
        }

        // çµ±è¨ˆé¸å–çš„ç‰©ä»¶æŒ‰éˆ•
        const calculateStatsBtn = document.getElementById("calculateStatsBtn");
        if (calculateStatsBtn) {
          calculateStatsBtn.addEventListener("click", () => {
            calculateSelectedStats();
          });
        }

        // é¡å‹æŒ‡æ´¾æŒ‰éˆ•
        const assignTypeBtn = document.getElementById("assignTypeBtn");
        if (assignTypeBtn) {
          assignTypeBtn.addEventListener("click", () => {
            openAssignTypeModal();
          });
        }

        // Canvas äº‹ä»¶
        canvas.addEventListener("mousedown", handleMouseDown);
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        canvas.addEventListener("wheel", handleWheel, { passive: false });
        canvas.addEventListener("contextmenu", (e) => e.preventDefault());

        // ç•¶æ»‘é¼ é›¢é–‹ canvas æ™‚é‡ç½®ç‹€æ…‹
        canvas.addEventListener("mouseleave", () => {
          if (!state.isDragging && !state.isMiddleMousePanning) {
            canvas.style.cursor = "default";
          }
          // éš±è— hover tooltip
          if (state.inspectMode) {
            state.hoveredSegment = null;
            hideSegmentTooltip();
            render();
          }
        });

        // é˜»æ­¢ä¸­éµé»æ“Šçš„é è¨­è¡Œç‚º
        canvas.addEventListener("auxclick", (e) => {
          if (e.button === 1) e.preventDefault();
        });
        canvas.addEventListener("mousedown", (e) => {
          if (e.button === 1) e.preventDefault();
        });

        // éµç›¤å¿«æ·éµ
        document.addEventListener("keydown", handleKeyDown);
      }

      // é ç±¤åˆ‡æ›å‡½æ•¸
      function switchTab(tabName) {
        // æ›´æ–°é ç±¤æŒ‰éˆ•ç‹€æ…‹
        document.querySelectorAll(".tab-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.tab === tabName);
        });

        // æ›´æ–°é¢æ¿é¡¯ç¤º
        document.querySelectorAll(".tab-panel").forEach((panel) => {
          panel.classList.remove("active");
        });

        if (tabName === "layers") {
          document.getElementById("layersPanel").classList.add("active");
        } else if (tabName === "stats") {
          document.getElementById("statsPanel").classList.add("active");
        }
      }

      // å´é‚Šæ¬„åœ–å±¤æœå°‹
      function filterSidebarLayers() {
        const searchText = (
          document.getElementById("sidebarSearchInput")?.value || ""
        ).toLowerCase();
        const items = document.querySelectorAll("#layerList .layer-item");

        items.forEach((item) => {
          const layerName = item.dataset.layer.toLowerCase();
          item.style.display = layerName.includes(searchText) ? "" : "none";
        });
      }

      // åˆ‡æ›æ‰€æœ‰åœ–å±¤å¯è¦‹æ€§
      // ä½¿ç”¨ permanentLayers ç¢ºä¿æ“ä½œæ‰€æœ‰æŒä¹…åŒ–çš„åœ–å±¤
      function toggleAllLayersVisible(visible) {
        state.permanentLayers.forEach((layerName) => {
          state.layerVisibility[layerName] = visible;
        });
        updateSidebarLayerList();
        render();
      }

      // ==================== æª”æ¡ˆè™•ç† ====================
      async function handleFileSelect(e) {
        const file = e.target.files[0];
        if (!file) return;

        if (!file.name.toLowerCase().endsWith(".dxf")) {
          alert("è«‹é¸æ“‡ DXF æª”æ¡ˆ");
          return;
        }

        const statusEl = document.getElementById("fileStatus");
        const infoEl = document.getElementById("infoText");

        try {
          // æ­¥é©Ÿ 1: ä¸Šå‚³æª”æ¡ˆ
          statusEl.textContent = "ä¸Šå‚³ä¸­...";
          infoEl.textContent = "ä¸Šå‚³ DXF æª”æ¡ˆ...";

          const formData = new FormData();
          formData.append("file", file);

          const uploadResp = await fetch("http://localhost:5000/api/upload", {
            method: "POST",
            body: formData,
          });

          if (!uploadResp.ok) {
            throw new Error("ä¸Šå‚³å¤±æ•—");
          }

          const uploadData = await uploadResp.json();
          console.log("ä¸Šå‚³æˆåŠŸ:", uploadData);

          // æ­¥é©Ÿ 2: è§£æ DXF
          statusEl.textContent = "è§£æä¸­...";
          infoEl.textContent = "è§£æ DXF æª”æ¡ˆï¼ˆé€™å¯èƒ½éœ€è¦ 1-3 åˆ†é˜ï¼‰...";

          const parseResp = await fetch("http://localhost:5000/api/parse", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              filepath: uploadData.filepath,
              project_name: file.name,
            }),
          });

          if (!parseResp.ok) {
            throw new Error("è§£æå¤±æ•—");
          }

          const parseData = await parseResp.json();
          console.log("è§£ææˆåŠŸ:", parseData);

          // æ­¥é©Ÿ 3: æš«å­˜è§£æè³‡æ–™ä¸¦é¡¯ç¤ºåœ–å±¤é¸æ“‡è¦–çª—
          state.pendingParseData = parseData;
          state.pendingFilename = file.name;
          state.allLayers = parseData.layers;

          // å„²å­˜å–®ä½è¨­å®šï¼ˆå„ªå…ˆä½¿ç”¨ INSUNITSï¼‰
          state.dimscale = parseData.dimscale || 1.0;
          state.insunits = parseData.insunits ?? 0; // é è¨­ç‚º 0ï¼ˆç„¡å–®ä½ï¼Œç•¶ä½œæ¯«ç±³è™•ç†ï¼‰

          // å„²å­˜åœ–å±¤é¡è‰²å°æ‡‰è¡¨
          state.layerColors = {};
          Object.entries(parseData.layers).forEach(([layerName, layerInfo]) => {
            state.layerColors[layerName] = aciToHex(layerInfo.color);
          });

          // è¼¸å‡ºå–®ä½è³‡è¨Š
          const unitName = getUnitName(state.insunits);
          console.log(`INSUNITS: ${state.insunits} (${unitName})`);
          console.log(`DIMSCALE: ${state.dimscale} (èˆŠç‰ˆï¼Œä¸å†ä½¿ç”¨æ–¼é•·åº¦è¨ˆç®—)`);

          statusEl.textContent = "è«‹é¸æ“‡åœ–å±¤...";
          infoEl.textContent = `å·²è§£æ ${
            Object.keys(parseData.layers).length
          } å€‹åœ–å±¤ï¼Œå–®ä½ï¼š${unitName}`;

          // å½ˆå‡ºåœ–å±¤é¸æ“‡è¦–çª—
          openLayerSelectModal(parseData.layers);
        } catch (error) {
          console.error("éŒ¯èª¤:", error);
          alert("è™•ç†å¤±æ•—: " + error.message);
          statusEl.textContent = "æœªé¸æ“‡æª”æ¡ˆ";
          infoEl.textContent = "ç­‰å¾…ä¸Šå‚³ DXF æª”æ¡ˆ...";
        }
      }

      // ==================== åœ–å±¤é¸æ“‡è¦–çª— ====================

      // åˆ¤æ–·æ˜¯å¦ç‚ºç‰†ç›¸é—œåœ–å±¤
      function isWallLayer(layerName) {
        const lowerName = layerName.toLowerCase();
        return lowerName.includes("wall") || layerName.includes("ç‰†");
      }

      // æ’åºåœ–å±¤ï¼šç‰†ç›¸é—œçš„æ”¾å‰é¢
      function sortLayers(layers) {
        return layers.sort((a, b) => {
          const aIsWall = isWallLayer(a);
          const bIsWall = isWallLayer(b);
          if (aIsWall && !bIsWall) return -1;
          if (!aIsWall && bIsWall) return 1;
          return a.localeCompare(b);
        });
      }

      // é–‹å•Ÿåœ–å±¤é¸æ“‡è¦–çª—
      function openLayerSelectModal(layers) {
        const layerNames = Object.keys(layers);
        const sortedLayers = sortLayers([...layerNames]);

        // å¦‚æœå·²æœ‰ permanentLayersï¼Œå‰‡æ ¹æ“šå¯è¦‹æ€§ç‹€æ…‹ä¾†åˆå§‹åŒ– selectedLayers
        // å¦å‰‡é è¨­é¸æ“‡ç‰†ç›¸é—œåœ–å±¤
        if (state.permanentLayers.length > 0) {
          // é¡¯ç¤ºçš„åœ–å±¤ = permanentLayers ä¸­ visibility ç‚º true çš„
          state.selectedLayers = state.permanentLayers.filter(
            (name) => state.layerVisibility[name] !== false
          );
        } else {
          // é¦–æ¬¡é–‹å•Ÿï¼Œé è¨­é¸æ“‡ç‰†ç›¸é—œåœ–å±¤
          state.selectedLayers = sortedLayers.filter((name) =>
            isWallLayer(name)
          );
        }

        renderLayerSelectList(sortedLayers);
        updateLayerSelectCount();

        document.getElementById("layerSelectModal").classList.add("show");
      }

      // é—œé–‰åœ–å±¤é¸æ“‡è¦–çª—
      function closeLayerSelectModal() {
        document.getElementById("layerSelectModal").classList.remove("show");
      }

      // æ¸²æŸ“åœ–å±¤é¸æ“‡åˆ—è¡¨
      function renderLayerSelectList(layers) {
        const container = document.getElementById("layerSelectList");
        const searchText = (
          document.getElementById("modalSearchInput")?.value || ""
        ).toLowerCase();

        const filteredLayers = layers.filter((name) =>
          name.toLowerCase().includes(searchText)
        );

        container.innerHTML = filteredLayers
          .map((layerName) => {
            const color = state.layerColors[layerName] || "#888888";
            const isSelected = state.selectedLayers.includes(layerName);
            const isWall = isWallLayer(layerName);

            return `
          <div class="layer-select-item" data-layer="${layerName}" 
               style="padding: 10px 12px; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 10px; cursor: pointer; background: ${
                 isSelected ? "#fff8e1" : "white"
               }; transition: background 0.2s;"
               onclick="toggleLayerSelection('${layerName.replace(
                 /'/g,
                 "\\'"
               )}')">
            <input type="checkbox" ${isSelected ? "checked" : ""} 
                   style="width: 18px; height: 18px; cursor: pointer;"
                   onclick="event.stopPropagation(); toggleLayerSelection('${layerName.replace(
                     /'/g,
                     "\\'"
                   )}')">
            <span style="display: inline-block; width: 16px; height: 16px; background: ${color}; border-radius: 3px; flex-shrink: 0;"></span>
            <span style="flex: 1; font-size: 13px; ${
              isWall ? "font-weight: 600; color: #f5a623;" : ""
            }">${layerName}</span>
            ${
              isWall
                ? '<span style="font-size: 11px; background: #f5a623; color: white; padding: 2px 6px; border-radius: 3px;">ç‰†</span>'
                : ""
            }
          </div>
        `;
          })
          .join("");

        document.getElementById("totalLayerCount").textContent = Object.keys(
          state.allLayers
        ).length;
      }

      // åˆ‡æ›åœ–å±¤é¸æ“‡
      function toggleLayerSelection(layerName) {
        console.log("[toggleLayerSelection] åˆ‡æ›åœ–å±¤:", layerName);
        const idx = state.selectedLayers.indexOf(layerName);
        if (idx >= 0) {
          state.selectedLayers.splice(idx, 1);
          console.log(
            "[toggleLayerSelection] ç§»é™¤åœ–å±¤ï¼Œç›®å‰é¸æ“‡æ•¸:",
            state.selectedLayers.length
          );
        } else {
          state.selectedLayers.push(layerName);
          console.log(
            "[toggleLayerSelection] æ–°å¢åœ–å±¤ï¼Œç›®å‰é¸æ“‡æ•¸:",
            state.selectedLayers.length
          );
        }

        // æ›´æ–°è©²é …ç›®çš„ UI
        const item = document.querySelector(
          `.layer-select-item[data-layer="${layerName}"]`
        );
        if (item) {
          const isSelected = state.selectedLayers.includes(layerName);
          item.style.background = isSelected ? "#fff8e1" : "white";
          const checkbox = item.querySelector('input[type="checkbox"]');
          if (checkbox) checkbox.checked = isSelected;
        }

        updateLayerSelectCount();
      }

      // æ›´æ–°é¸æ“‡æ•¸é‡é¡¯ç¤º
      function updateLayerSelectCount() {
        document.getElementById("selectedLayerCount").textContent =
          state.selectedLayers.length;
      }

      // æœå°‹éæ¿¾åœ–å±¤
      function filterLayerList() {
        const sortedLayers = sortLayers([...Object.keys(state.allLayers)]);
        renderLayerSelectList(sortedLayers);
      }

      // å…¨é¸
      function selectAllLayers() {
        state.selectedLayers = [...Object.keys(state.allLayers)];
        filterLayerList();
        updateLayerSelectCount();
      }

      // å…¨ä¸é¸
      function deselectAllLayers() {
        state.selectedLayers = [];
        filterLayerList();
        updateLayerSelectCount();
      }

      // åªé¸ç‰†é¡
      function selectWallLayers() {
        state.selectedLayers = Object.keys(state.allLayers).filter((name) =>
          isWallLayer(name)
        );
        filterLayerList();
        updateLayerSelectCount();
      }

      // ==================== åœ–å±¤è¨ˆç®—è¨­å®šåŠŸèƒ½ ====================

      // é–‹å•Ÿåœ–å±¤è¨ˆç®—è¨­å®šè¦–çª—
      function openLayerCalcSettingsModal() {
        renderLayerCalcSettingsList();
        document.getElementById("layerCalcSettingsModal").classList.add("show");
      }

      // é—œé–‰åœ–å±¤è¨ˆç®—è¨­å®šè¦–çª—
      function closeLayerCalcSettingsModal() {
        document
          .getElementById("layerCalcSettingsModal")
          .classList.remove("show");
      }

      // å¾åœ–å±¤åç¨±æ¨æ–·ç‰†åšåº¦ï¼ˆå¦‚ WALL-12CM â†’ 12ï¼‰
      function inferWallThickness(layerName) {
        const match = layerName.match(/(\d+)\s*CM/i);
        return match ? parseInt(match[1], 10) : null;
      }

      // æ¸²æŸ“åœ–å±¤è¨ˆç®—è¨­å®šåˆ—è¡¨
      function renderLayerCalcSettingsList() {
        const tbody = document.getElementById("layerCalcSettingsList");
        const layers = sortLayers([...state.permanentLayers]);

        if (layers.length === 0) {
          tbody.innerHTML = `<tr><td colspan="2" style="padding: 20px; text-align: center; color: var(--text-muted);">è«‹å…ˆé¸æ“‡è¦é¡¯ç¤ºçš„åœ–å±¤</td></tr>`;
          return;
        }

        tbody.innerHTML = layers
          .map((layerName) => {
            const settings = state.layerSettings[layerName] || {};
            const color = state.layerColors[layerName] || "#888888";
            const isWall = isWallLayer(layerName);

            // è‡ªå‹•æ¨æ–·é è¨­ç‰†åšåº¦ï¼ˆå¦‚æœå°šæœªè¨­å®šï¼‰
            let wallThickness = settings.wallThickness;
            if (!wallThickness || wallThickness === 0) {
              const inferred = inferWallThickness(layerName);
              if (inferred) {
                wallThickness = inferred;
                // è‡ªå‹•å„²å­˜æ¨æ–·çš„å€¼åˆ° state
                if (!state.layerSettings[layerName]) {
                  state.layerSettings[layerName] = {};
                }
                state.layerSettings[layerName].wallThickness = inferred;
              }
            }

            return `
          <tr data-layer="${layerName}" style="border-bottom: 1px solid #f0f0f0;">
            <td style="padding: 10px 12px;">
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="width: 14px; height: 14px; background: ${color}; border-radius: 3px;"></span>
                <span ${
                  isWall
                    ? 'style="font-weight: 600; color: var(--accent-wall);"'
                    : ""
                }>${layerName}</span>
                ${
                  isWall
                    ? '<span style="font-size: 10px; background: var(--accent-wall); color: white; padding: 2px 6px; border-radius: 3px;">ç‰†</span>'
                    : ""
                }
              </div>
            </td>
            <td style="padding: 10px 12px; text-align: center;">
              <input type="number" class="form-input layer-wall-thickness"
                     data-layer="${layerName}"
                     value="${wallThickness || ""}"
                     min="0" step="1"
                     placeholder="12"
                     style="width: 80px; text-align: center; padding: 6px;">
            </td>
          </tr>
        `;
          })
          .join("");
      }

      // å„²å­˜åœ–å±¤è¨ˆç®—è¨­å®š
      function saveLayerCalcSettings() {
        // è®€å–ç‰†åšè¨­å®šï¼ˆå–®ä½ï¼šcmï¼‰
        const wallThicknessInputs = document.querySelectorAll(
          ".layer-wall-thickness"
        );
        wallThicknessInputs.forEach((input) => {
          const layerName = input.dataset.layer;
          const wallThicknessCm = parseFloat(input.value) || 0;

          if (!state.layerSettings[layerName]) {
            state.layerSettings[layerName] = { wallThickness: 0 };
          }
          // å„²å­˜æ™‚ä¿æŒ cm ç‚ºå–®ä½
          state.layerSettings[layerName].wallThickness = wallThicknessCm;
        });

        console.log("[saveLayerCalcSettings] å·²å„²å­˜è¨­å®š:", state.layerSettings);

        // åªå„²å­˜è¨­å®šï¼Œä¸åŸ·è¡Œå…¨åŸŸåµæ¸¬
        // å¹³è¡Œç‰†åµæ¸¬æœƒåœ¨ä½¿ç”¨è€…é»æ“Šã€Œçµ±è¨ˆé¸å–çš„ç‰©ä»¶ã€æ™‚ï¼Œé‡å°é¸å–çš„ç·šæ®µåŸ·è¡Œ
        closeLayerCalcSettingsModal();
        showNotification("åœ–å±¤è¨­å®šå·²å„²å­˜", "success");
      }

      // ç¢ºèªåœ–å±¤é¸æ“‡
      function confirmLayerSelection() {
        if (state.selectedLayers.length === 0) {
          alert("è«‹è‡³å°‘é¸æ“‡ä¸€å€‹åœ–å±¤");
          return;
        }

        closeLayerSelectModal();

        console.log(
          "[confirmLayerSelection] é¸æ“‡çš„åœ–å±¤:",
          state.selectedLayers
        );
        console.log("[confirmLayerSelection] ä¿®æ”¹å‰ permanentLayers:", [
          ...state.permanentLayers,
        ]);

        // å°‡æ–°é¸æ“‡çš„åœ–å±¤åŠ å…¥æŒä¹…åŒ–åˆ—è¡¨ï¼Œä¸¦è¨­å®šç‚ºå¯è¦‹
        state.selectedLayers.forEach((layerName) => {
          // æ–°åœ–å±¤ï¼šåŠ å…¥æŒä¹…åŒ–åˆ—è¡¨
          if (!state.permanentLayers.includes(layerName)) {
            state.permanentLayers.push(layerName);
            console.log(
              "[confirmLayerSelection] æ–°å¢åœ–å±¤åˆ° permanentLayers:",
              layerName
            );
          }
          // ç„¡è«–æ–°èˆŠï¼Œè¢«é¸æ“‡çš„åœ–å±¤éƒ½è¨­ç‚ºå¯è¦‹
          state.layerVisibility[layerName] = true;
        });

        // å°æ–¼è¢«å–æ¶ˆé¸æ“‡çš„åœ–å±¤ï¼Œè¨­å®šç‚ºéš±è—ï¼ˆä½†ä¿ç•™åœ¨ permanentLayers ä¸­ï¼‰
        state.permanentLayers.forEach((layerName) => {
          if (!state.selectedLayers.includes(layerName)) {
            state.layerVisibility[layerName] = false;
          }
        });

        console.log("[confirmLayerSelection] ä¿®æ”¹å¾Œ permanentLayers:", [
          ...state.permanentLayers,
        ]);
        console.log("[confirmLayerSelection] layerVisibility:", {
          ...state.layerVisibility,
        });

        // é‡æ–°éæ¿¾ç·šæ®µï¼ˆåŒ…å«æ‰€æœ‰æŒä¹…åŒ–åœ–å±¤çš„ç·šæ®µï¼‰
        if (state.allSegments && state.allSegments.length > 0) {
          state.segments = state.allSegments.filter((seg) =>
            state.permanentLayers.includes(seg.layer)
          );
          console.log(
            "[confirmLayerSelection] éæ¿¾å¾Œç·šæ®µæ•¸:",
            state.segments.length
          );
        } else if (state.pendingParseData) {
          // å¦‚æœ allSegments é‚„æ²’è¼‰å…¥ï¼Œå¾ pendingParseData è¼‰å…¥
          displaySelectedLayerData(
            state.pendingParseData,
            state.pendingFilename,
            state.selectedLayers
          );
          return;
        }

        // æ›´æ–° UI - é¡¯ç¤ºæŒä¹…åŒ–åœ–å±¤æ•¸é‡
        document.getElementById("layerCount").textContent =
          state.permanentLayers.length;
        document.getElementById("layerCountInfo").textContent =
          state.permanentLayers.length +
          " / " +
          Object.keys(state.allLayers).length;
        document.getElementById("segmentCountInfo").textContent =
          state.segments.length.toLocaleString();

        const statusEl = document.getElementById("fileStatus");
        const infoEl = document.getElementById("infoText");
        statusEl.textContent = `å·²è¼‰å…¥: ${state.pendingFilename}`;
        infoEl.textContent = `å·²é¸æ“‡ ${state.permanentLayers.length} å€‹åœ–å±¤`;

        // æ›´æ–°å´é‚Šæ¬„åœ–å±¤åˆ—è¡¨
        updateSidebarLayerList();

        // é‡æ–°æ¸²æŸ“
        render();
      }

      // é¡¯ç¤ºä½¿ç”¨è€…é¸æ“‡çš„åœ–å±¤è³‡æ–™
      function displaySelectedLayerData(data, filename, selectedLayers) {
        // æ›´æ–°çµ±è¨ˆé¢æ¿
        document.getElementById("fileName").textContent = filename;

        // å°‡é¸æ“‡çš„åœ–å±¤åŠ å…¥æŒä¹…åŒ–åˆ—è¡¨
        selectedLayers.forEach((layerName) => {
          if (!state.permanentLayers.includes(layerName)) {
            state.permanentLayers.push(layerName);
          }
        });

        document.getElementById("layerCountInfo").textContent =
          state.permanentLayers.length +
          " / " +
          Object.keys(data.layers).length;

        // è™•ç†æŒä¹…åŒ–åœ–å±¤çš„ç·šæ®µ
        const permanentSegments = data.segments.filter((seg) =>
          state.permanentLayers.includes(seg.layer)
        );
        document.getElementById("segmentCountInfo").textContent =
          permanentSegments.length.toLocaleString();

        // åˆå§‹åŒ–åœ–å±¤å¯è¦‹æ€§ï¼ˆæ–°é¸æ“‡çš„åœ–å±¤é¡¯ç¤ºï¼Œä¹‹å‰æœªé¸çš„ä½†åœ¨ permanentLayers ä¸­çš„è¨­ç‚ºéš±è—ï¼‰
        state.permanentLayers.forEach((layerName) => {
          if (state.layerVisibility[layerName] === undefined) {
            // å¦‚æœæ˜¯é€™æ¬¡æ–°é¸æ“‡çš„ï¼Œé¡¯ç¤ºï¼›å¦å‰‡éš±è—
            state.layerVisibility[layerName] =
              selectedLayers.includes(layerName);
          }
        });

        // é¡¯ç¤ºç®¡ç†ç›¸é—œ UI
        document.getElementById("manageLayersBtn").style.display = "";
        document.getElementById("layerCalcSettingsBtn").style.display = "";
        document.getElementById("layerManagement").style.display = "";
        document.getElementById("layerSearchBox").style.display = "";

        // æ›´æ–°åœ–å±¤æ•¸é‡ï¼ˆæŒä¹…åŒ–åœ–å±¤ï¼‰
        document.getElementById("layerCount").textContent =
          state.permanentLayers.length;

        // æ›´æ–°å´é‚Šæ¬„åœ–å±¤åˆ—è¡¨
        updateSidebarLayerList();

        // å„²å­˜æ‰€æœ‰ç·šæ®µï¼ˆæœªç¯©é¸ï¼‰
        state.allSegments = data.segments.map((seg, index) => ({
          id: index + 1,
          layer: seg.layer,
          startX: seg.start_point[0],
          startY: seg.start_point[1],
          endX: seg.end_point[0],
          endY: seg.end_point[1],
          length: seg.length,
          vertices: seg.vertices || null,
          entityType: seg.entity_type || "LINE",
          categoryId: null,
        }));

        // é¡¯ç¤ºæŒä¹…åŒ–åœ–å±¤çš„ç·šæ®µ
        state.segments = state.allSegments.filter((seg) =>
          state.permanentLayers.includes(seg.layer)
        );

        console.log(
          "å·²è¼‰å…¥",
          state.segments.length,
          "æ¢ç·šæ®µï¼ˆå¾",
          state.allSegments.length,
          "æ¢ä¸­ç¯©é¸ï¼‰"
        );

        // æ›´æ–°çµ±è¨ˆè¡¨æ ¼
        const tbody = document.querySelector("#summaryTable tbody");
        tbody.innerHTML = `<tr><td colspan="3" style="text-align:center;color:var(--text-muted);padding:24px;">å·²é¸æ“‡ ${state.permanentLayers.length} å€‹åœ–å±¤<br><span style="font-size:11px;">(çµ±è¨ˆåŠŸèƒ½é–‹ç™¼ä¸­)</span></td></tr>`;

        // è‡ªå‹•ç¸®æ”¾ä»¥é©åˆè¦–çª—
        zoomFit();
      }

      // æ›´æ–°å´é‚Šæ¬„åœ–å±¤åˆ—è¡¨
      // ä½¿ç”¨ permanentLayers ç¢ºä¿åœ–å±¤ä¸æœƒå› é—œé–‰é¡¯ç¤ºè€Œå¾åˆ—è¡¨æ¶ˆå¤±
      function updateSidebarLayerList() {
        console.log(
          "[updateSidebarLayerList] permanentLayers:",
          state.permanentLayers
        );
        console.log(
          "[updateSidebarLayerList] layerColors æ•¸é‡:",
          Object.keys(state.layerColors).length
        );

        const layerList = document.getElementById("layerList");
        // ä½¿ç”¨ permanentLayersï¼ˆæŒä¹…åŒ–åœ–å±¤åˆ—è¡¨ï¼‰ï¼Œè€Œé selectedLayers
        const sortedLayers = sortLayers([...state.permanentLayers]);

        console.log(
          "[updateSidebarLayerList] æ’åºå¾Œåœ–å±¤æ•¸:",
          sortedLayers.length
        );

        layerList.innerHTML = sortedLayers
          .map((layer) => {
            const color = state.layerColors[layer] || "#888888";
            const isVisible = state.layerVisibility[layer] !== false;
            const isWall = isWallLayer(layer);
            return `
            <div class="layer-item ${
              isVisible ? "" : "hidden"
            }" data-layer="${layer}">
              <div class="layer-color" style="background:${color};"></div>
              ${isWall ? '<span class="layer-badge">ç‰†</span>' : ""}
              <span class="layer-name ${
                isWall ? "wall-type" : ""
              }" title="${layer}">${layer}</span>
              <button class="layer-toggle" data-layer="${layer}" title="${
              isVisible ? "éš±è—" : "é¡¯ç¤º"
            }">
                ${isVisible ? "ğŸ‘ï¸" : "ğŸš«"}
              </button>
            </div>`;
          })
          .join("");

        // ç¶å®šåœ–å±¤åˆ‡æ›äº‹ä»¶ - åªåˆ‡æ›å¯è¦‹æ€§ï¼Œä¸å¾åˆ—è¡¨ç§»é™¤
        layerList.querySelectorAll(".layer-toggle").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const layerName = btn.dataset.layer;

            console.log("[layer-toggle] é»æ“Šåœ–å±¤:", layerName);
            console.log("[layer-toggle] åˆ‡æ›å‰ permanentLayers:", [
              ...state.permanentLayers,
            ]);
            console.log(
              "[layer-toggle] åˆ‡æ›å‰ layerVisibility:",
              state.layerVisibility[layerName]
            );

            // åˆ‡æ›å¯è¦‹æ€§ç‹€æ…‹
            state.layerVisibility[layerName] =
              !state.layerVisibility[layerName];
            const isVisible = state.layerVisibility[layerName];

            console.log("[layer-toggle] åˆ‡æ›å¾Œ isVisible:", isVisible);

            // æ›´æ–°æŒ‰éˆ•é¡¯ç¤º
            btn.textContent = isVisible ? "ğŸ‘ï¸" : "ğŸš«";
            btn.title = isVisible ? "éš±è—" : "é¡¯ç¤º";

            // æ›´æ–°åœ–å±¤é …ç›®çš„æ¨£å¼ï¼ˆéš±è—åœ–å±¤æœƒæœ‰æ·¡åŒ–æ•ˆæœï¼‰
            const layerItem = btn.closest(".layer-item");
            if (layerItem) {
              layerItem.classList.toggle("hidden", !isVisible);
            }

            console.log("[layer-toggle] æº–å‚™èª¿ç”¨ render()");
            console.log("[layer-toggle] permanentLayers æ‡‰ä¿æŒä¸è®Š:", [
              ...state.permanentLayers,
            ]);

            // æ³¨æ„ï¼šä¸å¾ permanentLayers ç§»é™¤åœ–å±¤ï¼Œåªæ˜¯åˆ‡æ›å¯è¦‹æ€§
            render();

            console.log("[layer-toggle] render() å®Œæˆå¾Œ permanentLayers:", [
              ...state.permanentLayers,
            ]);
          });
        });
      }

      // é¡¯ç¤º DXF è³‡æ–™ï¼ˆèˆŠç‰ˆï¼Œä¿ç•™å‚™ç”¨ï¼‰
      function displayDxfData(data, filename) {
        // æ›´æ–°å³å´çµ±è¨ˆé¢æ¿
        document.getElementById("fileName").textContent = filename;
        document.getElementById("layerCountInfo").textContent = Object.keys(
          data.layers
        ).length;
        document.getElementById("segmentCountInfo").textContent =
          data.total_segment_count.toLocaleString();

        // è¨ˆç®—å„åœ–å±¤çµ±è¨ˆ
        const layerStats = {};
        data.segments.forEach((seg) => {
          const layer = seg.layer;
          if (!layerStats[layer]) {
            layerStats[layer] = { count: 0, length: 0 };
          }
          layerStats[layer].count++;
          layerStats[layer].length += seg.length;
        });

        // å„²å­˜åœ–å±¤é¡è‰²å°æ‡‰è¡¨
        state.layerColors = {};
        Object.entries(data.layers).forEach(([layerName, layerInfo]) => {
          // å°‡ ACI é¡è‰²è½‰æ›ç‚º HEX é¡è‰²
          state.layerColors[layerName] = aciToHex(layerInfo.color);
        });
        console.log(
          "å·²è¼‰å…¥åœ–å±¤é¡è‰²",
          Object.keys(state.layerColors).length,
          "å€‹"
        );

        // æŒ‰ç·šæ®µæ•¸æ’åºï¼Œå–å‰ 20 å
        const sorted = Object.entries(layerStats)
          .sort((a, b) => b[1].count - a[1].count)
          .slice(0, 20);

        // æ›´æ–°çµ±è¨ˆè¡¨æ ¼ï¼ˆåŠ å…¥é¡è‰²æŒ‡ç¤ºï¼‰
        const tbody = document.querySelector("#summaryTable tbody");
        tbody.innerHTML = sorted
          .map(([layer, stats]) => {
            const color = state.layerColors[layer] || "#888888";
            return `<tr>
                    <td><span style="display:inline-block;width:12px;height:12px;background:${color};border-radius:2px;margin-right:6px;vertical-align:middle;"></span>${layer}</td>
                    <td>${stats.count.toLocaleString()}</td>
                    <td>${(stats.length / 1000).toFixed(2)}</td>
                </tr>`;
          })
          .join("");

        // æ›´æ–°å·¦å´åœ–å±¤åˆ—è¡¨ï¼ˆåŠ å…¥é¡è‰²æŒ‡ç¤ºï¼‰
        document.getElementById("layerCount").textContent = `${
          Object.keys(data.layers).length
        } å€‹åœ–å±¤`;
        const layerList = document.getElementById("layerList");

        // åˆå§‹åŒ–åœ–å±¤å¯è¦‹æ€§ï¼ˆé è¨­å…¨éƒ¨é¡¯ç¤ºï¼‰- ä½¿ç”¨æ‰€æœ‰åœ–å±¤
        state.layerVisibility = {};
        const allLayers = Object.keys(data.layers);
        allLayers.forEach((layerName) => {
          state.layerVisibility[layerName] = true;
        });

        // æŒ‰åç¨±æ’åºåœ–å±¤
        const sortedLayers = allLayers.sort((a, b) => a.localeCompare(b));

        layerList.innerHTML = sortedLayers
          .map((layer) => {
            const color = state.layerColors[layer] || "#888888";
            const isVisible = state.layerVisibility[layer] !== false;
            return `<div class="layer-item" data-layer="${layer}" style="padding: 6px 8px; border-bottom: 1px solid #eee; font-size: 12px; display: flex; align-items: center; justify-content: space-between; opacity: ${
              isVisible ? 1 : 0.5
            };">
                      <div style="display: flex; align-items: center; flex: 1; min-width: 0;">
                        <span style="display:inline-block;width:12px;height:12px;background:${color};border-radius:2px;margin-right:6px;flex-shrink:0;"></span>
                        <span style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${layer}">${layer}</span>
                      </div>
                      <button class="layer-toggle-btn" data-layer="${layer}" title="${
              isVisible ? "éš±è—" : "é¡¯ç¤º"
            }" style="background:none;border:none;cursor:pointer;font-size:14px;padding:0 4px;opacity:${
              isVisible ? 1 : 0.3
            };">
                        ${isVisible ? "ğŸ‘ï¸" : "ğŸš«"}
                      </button>
                </div>`;
          })
          .join("");

        // ç¶å®šåœ–å±¤åˆ‡æ›äº‹ä»¶
        layerList.querySelectorAll(".layer-toggle-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const layerName = btn.dataset.layer;
            state.layerVisibility[layerName] =
              !state.layerVisibility[layerName];
            const isVisible = state.layerVisibility[layerName];
            btn.textContent = isVisible ? "ğŸ‘ï¸" : "ğŸš«";
            btn.style.opacity = isVisible ? 1 : 0.3;
            btn.title = isVisible ? "éš±è—" : "é¡¯ç¤º";
            const layerItem = btn.closest(".layer-item");
            if (layerItem) {
              layerItem.style.opacity = isVisible ? 1 : 0.5;
            }
            console.log("[Layer Toggle]", layerName, isVisible ? "ON" : "OFF");
            render();
          });
        });

        // è½‰æ›ç·šæ®µè³‡æ–™æ ¼å¼ä¸¦å„²å­˜åˆ° state
        // æ³¨æ„ï¼šä¿ç•™é ‚é»è³‡è¨Šä»¥æ­£ç¢ºç¹ªè£½å¤šæ®µç·š
        state.segments = data.segments.map((seg, index) => ({
          id: index + 1,
          layer: seg.layer,
          startX: seg.start_point[0],
          startY: seg.start_point[1],
          endX: seg.end_point[0],
          endY: seg.end_point[1],
          length: seg.length,
          vertices: seg.vertices || null, // ä¿ç•™å¤šæ®µç·šé ‚é»
          entityType: seg.entity_type || "LINE", // ä¿ç•™å¯¦é«”é¡å‹
          categoryId: null, // å°šæœªåˆ†é¡
        }));

        console.log("å·²è¼‰å…¥", state.segments.length, "æ¢ç·šæ®µ");

        // è‡ªå‹•ç¸®æ”¾ä»¥é©åˆè¦–çª—
        zoomFit();
      }

      async function simulateFileProcessing(file) {
        // æ¨¡æ“¬ API è™•ç†å»¶é²
        await new Promise((resolve) => setTimeout(resolve, 1000));

        // è¼‰å…¥ç¤ºç¯„è³‡æ–™
        state.buildings = [
          { id: 1, name: "Aæ£Ÿ" },
          { id: 2, name: "Bæ£Ÿ" },
          { id: 3, name: "åœ°ä¸‹å±¤ï¼ˆå…±ç”¨ï¼‰" },
        ];

        state.floors = [
          { id: 1, buildingId: 1, name: "1F" },
          { id: 2, buildingId: 1, name: "2~5F" },
          { id: 3, buildingId: 1, name: "6F" },
          { id: 4, buildingId: 1, name: "RF" },
          { id: 5, buildingId: 2, name: "1F" },
          { id: 6, buildingId: 2, name: "2~8F" },
          { id: 7, buildingId: 2, name: "RF" },
          { id: 8, buildingId: 3, name: "B1F" },
          { id: 9, buildingId: 3, name: "B2F" },
        ];

        // ç”Ÿæˆç¤ºç¯„ç·šæ®µ
        state.segments = generateDemoSegments();

        updateBuildingList();
        updateBuildingFilter();
        updateSummary();
        render();
      }

      function generateDemoSegments() {
        const segments = [];
        let id = 1;

        // å¤–ç‰†ï¼ˆç´…è‰²çŸ©å½¢ï¼‰
        const walls = [
          { x1: 0, y1: 0, x2: 15000, y2: 0, cat: 1 },
          { x1: 15000, y1: 0, x2: 15000, y2: 10000, cat: 1 },
          { x1: 15000, y1: 10000, x2: 0, y2: 10000, cat: 1 },
          { x1: 0, y1: 10000, x2: 0, y2: 0, cat: 1 },
          // å…§ç‰†
          { x1: 5000, y1: 0, x2: 5000, y2: 7000, cat: 2 },
          { x1: 10000, y1: 0, x2: 10000, y2: 10000, cat: 2 },
          { x1: 0, y1: 5000, x2: 10000, y2: 5000, cat: 2 },
          // RCç‰†
          { x1: 5000, y1: 7000, x2: 5000, y2: 10000, cat: 3 },
          // è¼•éš”é–“
          { x1: 2500, y1: 0, x2: 2500, y2: 5000, cat: 4 },
          { x1: 7500, y1: 0, x2: 7500, y2: 5000, cat: 4 },
          // é™½å°ç‰†
          { x1: 15000, y1: 3000, x2: 17000, y2: 3000, cat: 5 },
          { x1: 17000, y1: 3000, x2: 17000, y2: 7000, cat: 5 },
          { x1: 17000, y1: 7000, x2: 15000, y2: 7000, cat: 5 },
        ];

        walls.forEach((w) => {
          const length = Math.sqrt((w.x2 - w.x1) ** 2 + (w.y2 - w.y1) ** 2);
          segments.push({
            id: id,
            uid: `seg_${String(id).padStart(5, "0")}`,
            layer: `A-WALL-${
              state.categories.find((c) => c.id === w.cat)?.code || "UNKNOWN"
            }`,
            categoryId: w.cat,
            buildingId: 1,
            floorId: 1,
            startX: w.x1,
            startY: w.y1,
            endX: w.x2,
            endY: w.y2,
            length: length,
          });
          id++;
        });

        return segments;
      }

      // ==================== ç¹ªåœ–åŠŸèƒ½ ====================

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ç¹ªè£½èƒŒæ™¯
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ç¹ªè£½ç¶²æ ¼
        if (state.showGrid) {
          drawGrid();
        }

        // ç¹ªè£½æ‰€æœ‰ç·šæ®µ
        const filteredSegments = getFilteredSegments();
        filteredSegments.forEach((seg) => {
          drawSegment(seg, state.selectedSegments.includes(seg));
        });
      }

      function drawGrid() {
        const gridSize = 1000 * state.zoom; // 1m ç¶²æ ¼

        ctx.strokeStyle = "#f0f0f0";
        ctx.lineWidth = 1;
        ctx.beginPath();

        // è¨ˆç®—å¯è¦‹ç¯„åœ
        const startX = Math.floor(-state.panX / gridSize) * gridSize;
        const startY = Math.floor(-state.panY / gridSize) * gridSize;

        for (let x = startX; x < canvas.width - state.panX; x += gridSize) {
          const screenX = x + state.panX;
          ctx.moveTo(screenX, 0);
          ctx.lineTo(screenX, canvas.height);
        }

        for (let y = startY; y < canvas.height - state.panY; y += gridSize) {
          const screenY = canvas.height - (y + state.panY);
          ctx.moveTo(0, screenY);
          ctx.lineTo(canvas.width, screenY);
        }

        ctx.stroke();
      }

      function drawSegment(seg, isSelected) {
        // é¡è‰²å„ªå…ˆé †åºï¼š1.è‡ªå®šç¾©é¡å‹ 2.åˆ†é¡é¡è‰² 3.åœ–å±¤åŸå§‹é¡è‰² 4.é è¨­ç°è‰²
        let color;
        if (seg.customTypeColor) {
          // å„ªå…ˆä½¿ç”¨è‡ªå®šç¾©é¡å‹çš„é¡è‰²
          color = seg.customTypeColor;
        } else {
          const category = state.categories.find(
            (c) => c.id === seg.categoryId
          );
          if (category) {
            color = category.color;
          } else if (state.layerColors && state.layerColors[seg.layer]) {
            color = state.layerColors[seg.layer];
          } else {
            color = "#808080";
          }
        }

        // æª¢æŸ¥æ˜¯å¦æ˜¯ hover ç‹€æ…‹ï¼ˆæª¢è¦–æ¨¡å¼ä¸‹ï¼‰
        const isHovered = state.inspectMode && state.hoveredSegment === seg;

        // è¨­å®šç¹ªåœ–æ¨£å¼
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        // Hover ç‹€æ…‹ - ç™¼å…‰æ•ˆæœ
        if (isHovered) {
          ctx.shadowColor = "#3b82f6";
          ctx.shadowBlur = 15;
          ctx.lineWidth = 3;
        }

        // é¸å–ç‹€æ…‹ - è—è‰²è¦†è“‹
        if (isSelected) {
          ctx.lineWidth = 3;
        }

        ctx.beginPath();

        // æª¢æŸ¥æ˜¯å¦æœ‰å¤šæ®µç·šé ‚é»
        if (seg.vertices && seg.vertices.length >= 2) {
          for (let i = 0; i < seg.vertices.length; i++) {
            const vx = (seg.vertices[i][0] * state.zoom) / 1000 + state.panX;
            const vy =
              canvas.height -
              ((seg.vertices[i][1] * state.zoom) / 1000 + state.panY);
            if (i === 0) {
              ctx.moveTo(vx, vy);
            } else {
              ctx.lineTo(vx, vy);
            }
          }
        } else {
          const x1 = (seg.startX * state.zoom) / 1000 + state.panX;
          const y1 =
            canvas.height - ((seg.startY * state.zoom) / 1000 + state.panY);
          const x2 = (seg.endX * state.zoom) / 1000 + state.panX;
          const y2 =
            canvas.height - ((seg.endY * state.zoom) / 1000 + state.panY);
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
        }

        ctx.stroke();
        ctx.shadowBlur = 0;

        // é¸å–ç‹€æ…‹ - ç¹ªè£½è—è‰²åŠé€æ˜è¦†è“‹
        if (isSelected) {
          ctx.strokeStyle = "rgba(59, 130, 246, 0.6)";
          ctx.lineWidth = 5;
          ctx.stroke();
        }
      }

      function getFilteredSegments() {
        let filtered = state.segments;

        // æª¢æŸ¥åœ–å±¤å¯è¦‹æ€§
        filtered = filtered.filter((seg) => {
          const isVisible = state.layerVisibility[seg.layer];
          return isVisible !== false;
        });

        const buildingFilter = document.getElementById("buildingFilter");
        const floorFilter = document.getElementById("floorFilter");
        const categoryFilter = document.getElementById("categoryFilter");

        if (buildingFilter && buildingFilter.value) {
          filtered = filtered.filter(
            (s) => s.buildingId === parseInt(buildingFilter.value)
          );
        }
        if (floorFilter && floorFilter.value) {
          filtered = filtered.filter(
            (s) => s.floorId === parseInt(floorFilter.value)
          );
        }
        if (categoryFilter && categoryFilter.value) {
          filtered = filtered.filter(
            (s) => s.categoryId === parseInt(categoryFilter.value)
          );
        }

        return filtered;
      }

      // ==================== æ¡†é¸åŠŸèƒ½ ====================

      // ç¹ªè£½é¸å–çŸ©å½¢
      function drawSelectionRect() {
        if (!state.boxSelectStart || !state.boxSelectCurrent) return;

        const rect = canvas.getBoundingClientRect();
        const startX = state.boxSelectStart.x - rect.left;
        const startY = state.boxSelectStart.y - rect.top;
        const currentX = state.boxSelectCurrent.x - rect.left;
        const currentY = state.boxSelectCurrent.y - rect.top;

        const x = Math.min(startX, currentX);
        const y = Math.min(startY, currentY);
        const width = Math.abs(currentX - startX);
        const height = Math.abs(currentY - startY);

        // åˆ¤æ–·é¸å–æ¨¡å¼ï¼šå·¦åˆ°å³=çª—é¸(è—è‰²)ï¼Œå³åˆ°å·¦=è·¨é¸(ç¶ è‰²)
        const isCrossing = currentX < startX;

        ctx.save();

        if (isCrossing) {
          // è·¨é¸æ¨¡å¼ - ç¶ è‰²
          ctx.fillStyle = "rgba(34, 197, 94, 0.15)";
          ctx.strokeStyle = "#22c55e";
        } else {
          // çª—é¸æ¨¡å¼ - è—è‰²
          ctx.fillStyle = "rgba(59, 130, 246, 0.15)";
          ctx.strokeStyle = "#3b82f6";
        }

        ctx.lineWidth = 2;
        // Window çª—é¸ä½¿ç”¨å¯¦ç·šï¼ŒCrossing æ¡†é¸ä½¿ç”¨è™›ç·š
        if (isCrossing) {
          ctx.setLineDash([6, 3]);
        } else {
          ctx.setLineDash([]); // å¯¦ç·š
        }
        ctx.fillRect(x, y, width, height);
        ctx.strokeRect(x, y, width, height);

        ctx.restore();
      }

      // ===== AutoCAD é¢¨æ ¼æ¡†é¸å®Œæˆ =====
      // å°‡æ¡†é¸ç¯„åœå…§çš„ç‰©ä»¶ã€ŒåŠ å…¥ã€ç¾æœ‰é¸å–é›†ï¼ˆä¸æ¸…ç©ºç¾æœ‰é¸å–ï¼‰
      function finishBoxSelection() {
        if (!state.boxSelectStart || !state.boxSelectCurrent) return;

        const rect = canvas.getBoundingClientRect();
        const startX = state.boxSelectStart.x - rect.left;
        const startY = state.boxSelectStart.y - rect.top;
        const currentX = state.boxSelectCurrent.x - rect.left;
        const currentY = state.boxSelectCurrent.y - rect.top;

        // åˆ¤æ–·é¸å–æ¨¡å¼ï¼ˆAutoCAD æ¨™æº–ï¼‰
        // Window çª—é¸ï¼šP2.x > P1.xï¼ˆç”±å·¦å‘å³æ‹–æ›³ï¼‰
        // Crossing æ¡†é¸ï¼šP2.x < P1.xï¼ˆç”±å³å‘å·¦æ‹–æ›³ï¼‰
        const isCrossing = currentX < startX;

        const selectionRect = {
          x1: Math.min(startX, currentX),
          y1: Math.min(startY, currentY),
          x2: Math.max(startX, currentX),
          y2: Math.max(startY, currentY),
        };

        // æ‰¾å‡ºæ¡†é¸ç¯„åœå…§çš„ç·šæ®µ
        const filteredSegments = getFilteredSegments();
        const selectedInBox = filteredSegments.filter((seg) => {
          return isSegmentInSelectionRect(seg, selectionRect, isCrossing);
        });

        // AutoCAD è¡Œç‚ºï¼šå°‡é¸ä¸­çš„ç‰©ä»¶åŠ å…¥é¸å–é›†ï¼ˆä¸æ¸…ç©ºç¾æœ‰é¸å–ï¼‰
        selectedInBox.forEach((seg) => {
          if (!state.selectedSegments.includes(seg)) {
            state.selectedSegments.push(seg);
          }
        });

        updatePropertiesPanel();
      }

      // ===== è¨ˆç®—ç‰©ä»¶çš„é‚Šç•Œæ¡† =====
      // æ”¯æ´å¤šæ®µç·šï¼šä½¿ç”¨æ‰€æœ‰é ‚é»è¨ˆç®—é‚Šç•Œæ¡†
      function getSegmentBoundingBox(seg) {
        let minX, minY, maxX, maxY;

        if (seg.vertices && seg.vertices.length >= 2) {
          // å¤šæ®µç·šï¼šä½¿ç”¨æ‰€æœ‰é ‚é»
          minX = maxX = seg.vertices[0][0];
          minY = maxY = seg.vertices[0][1];
          for (let i = 1; i < seg.vertices.length; i++) {
            const vx = seg.vertices[i][0];
            const vy = seg.vertices[i][1];
            minX = Math.min(minX, vx);
            maxX = Math.max(maxX, vx);
            minY = Math.min(minY, vy);
            maxY = Math.max(maxY, vy);
          }
        } else {
          // å–®ä¸€ç·šæ®µ
          minX = Math.min(seg.startX, seg.endX);
          maxX = Math.max(seg.startX, seg.endX);
          minY = Math.min(seg.startY, seg.endY);
          maxY = Math.max(seg.startY, seg.endY);
        }

        return { minX, minY, maxX, maxY };
      }

      // ===== æª¢æŸ¥ç‰©ä»¶æ˜¯å¦åœ¨é¸å–çŸ©å½¢å…§ =====
      // Window çª—é¸ï¼šç‰©ä»¶å¿…é ˆã€Œå®Œå…¨ã€è½åœ¨çŸ©å½¢å…§
      // Crossing æ¡†é¸ï¼šç‰©ä»¶èˆ‡çŸ©å½¢æœ‰ä»»æ„ç›¸äº¤å³é¸ä¸­
      function isSegmentInSelectionRect(seg, rect, isCrossing) {
        // å–å¾—ç‰©ä»¶çš„ä¸–ç•Œåº§æ¨™é‚Šç•Œæ¡†
        const bbox = getSegmentBoundingBox(seg);

        // è½‰æ›åˆ°è¢å¹•åº§æ¨™
        const screenMinX = (bbox.minX * state.zoom) / 1000 + state.panX;
        const screenMaxX = (bbox.maxX * state.zoom) / 1000 + state.panX;
        const screenMinY =
          canvas.height - ((bbox.maxY * state.zoom) / 1000 + state.panY);
        const screenMaxY =
          canvas.height - ((bbox.minY * state.zoom) / 1000 + state.panY);

        if (isCrossing) {
          // ===== Crossing æ¡†é¸ =====
          // é¸å–æ‰€æœ‰ã€Œèˆ‡ R ç”¢ç”Ÿä»»æ„å¹¾ä½•ç›¸äº¤æˆ–è½åœ¨ R å…§ã€çš„ç‰©ä»¶
          // ä½¿ç”¨å¤šæ®µç·šçš„æ¯å€‹ç·šæ®µé€²è¡Œç²¾ç¢ºç›¸äº¤æª¢æ¸¬
          return isSegmentCrossingRect(seg, rect);
        } else {
          // ===== Window çª—é¸ =====
          // åªé¸å–ã€Œå®Œå…¨è½åœ¨ R å…§ã€çš„ç‰©ä»¶
          // ç‰©ä»¶çš„å¹¾ä½•é‚Šç•Œå¿…é ˆæ•´é«”åŒ…å«æ–¼ R ä¹‹å…§
          return (
            screenMinX >= rect.x1 &&
            screenMaxX <= rect.x2 &&
            screenMinY >= rect.y1 &&
            screenMaxY <= rect.y2
          );
        }
      }

      // ===== Crossing æ¡†é¸ï¼šç²¾ç¢ºçš„ç·šæ®µ-çŸ©å½¢ç›¸äº¤æª¢æ¸¬ =====
      function isSegmentCrossingRect(seg, rect) {
        // å–å¾—ç‰©ä»¶çš„ä¸–ç•Œåº§æ¨™é‚Šç•Œæ¡†
        const bbox = getSegmentBoundingBox(seg);

        // è½‰æ›åˆ°è¢å¹•åº§æ¨™
        const screenMinX = (bbox.minX * state.zoom) / 1000 + state.panX;
        const screenMaxX = (bbox.maxX * state.zoom) / 1000 + state.panX;
        const screenMinY =
          canvas.height - ((bbox.maxY * state.zoom) / 1000 + state.panY);
        const screenMaxY =
          canvas.height - ((bbox.minY * state.zoom) / 1000 + state.panY);

        // å¿«é€Ÿæ’é™¤ï¼šé‚Šç•Œæ¡†å®Œå…¨ä¸ç›¸äº¤
        if (
          screenMaxX < rect.x1 ||
          screenMinX > rect.x2 ||
          screenMaxY < rect.y1 ||
          screenMinY > rect.y2
        ) {
          return false;
        }

        // é‚Šç•Œæ¡†å®Œå…¨åœ¨çŸ©å½¢å…§
        if (
          screenMinX >= rect.x1 &&
          screenMaxX <= rect.x2 &&
          screenMinY >= rect.y1 &&
          screenMaxY <= rect.y2
        ) {
          return true;
        }

        // ç²¾ç¢ºæª¢æ¸¬ï¼šæª¢æŸ¥æ¯å€‹ç·šæ®µæ˜¯å¦èˆ‡çŸ©å½¢ç›¸äº¤
        if (seg.vertices && seg.vertices.length >= 2) {
          // å¤šæ®µç·š
          for (let i = 0; i < seg.vertices.length - 1; i++) {
            const x1 = (seg.vertices[i][0] * state.zoom) / 1000 + state.panX;
            const y1 =
              canvas.height -
              ((seg.vertices[i][1] * state.zoom) / 1000 + state.panY);
            const x2 =
              (seg.vertices[i + 1][0] * state.zoom) / 1000 + state.panX;
            const y2 =
              canvas.height -
              ((seg.vertices[i + 1][1] * state.zoom) / 1000 + state.panY);

            if (lineSegmentIntersectsRect(x1, y1, x2, y2, rect)) {
              return true;
            }
          }
          return false;
        } else {
          // å–®ä¸€ç·šæ®µ
          const x1 = (seg.startX * state.zoom) / 1000 + state.panX;
          const y1 =
            canvas.height - ((seg.startY * state.zoom) / 1000 + state.panY);
          const x2 = (seg.endX * state.zoom) / 1000 + state.panX;
          const y2 =
            canvas.height - ((seg.endY * state.zoom) / 1000 + state.panY);

          return lineSegmentIntersectsRect(x1, y1, x2, y2, rect);
        }
      }

      // ===== ç²¾ç¢ºçš„ç·šæ®µ-çŸ©å½¢ç›¸äº¤æ¼”ç®—æ³• =====
      // ä½¿ç”¨ Cohen-Sutherland ç·šæ®µè£å‰ªæ¼”ç®—æ³•çš„æ¦‚å¿µ
      function lineSegmentIntersectsRect(x1, y1, x2, y2, rect) {
        // æª¢æŸ¥ç«¯é»æ˜¯å¦åœ¨çŸ©å½¢å…§
        const p1Inside =
          x1 >= rect.x1 && x1 <= rect.x2 && y1 >= rect.y1 && y1 <= rect.y2;
        const p2Inside =
          x2 >= rect.x1 && x2 <= rect.x2 && y2 >= rect.y1 && y2 <= rect.y2;

        if (p1Inside || p2Inside) return true;

        // æª¢æŸ¥ç·šæ®µæ˜¯å¦èˆ‡çŸ©å½¢çš„å››æ¢é‚Šç›¸äº¤
        // ä¸Šé‚Š
        if (
          lineSegmentsIntersect(
            x1,
            y1,
            x2,
            y2,
            rect.x1,
            rect.y1,
            rect.x2,
            rect.y1
          )
        )
          return true;
        // ä¸‹é‚Š
        if (
          lineSegmentsIntersect(
            x1,
            y1,
            x2,
            y2,
            rect.x1,
            rect.y2,
            rect.x2,
            rect.y2
          )
        )
          return true;
        // å·¦é‚Š
        if (
          lineSegmentsIntersect(
            x1,
            y1,
            x2,
            y2,
            rect.x1,
            rect.y1,
            rect.x1,
            rect.y2
          )
        )
          return true;
        // å³é‚Š
        if (
          lineSegmentsIntersect(
            x1,
            y1,
            x2,
            y2,
            rect.x2,
            rect.y1,
            rect.x2,
            rect.y2
          )
        )
          return true;

        return false;
      }

      // ===== å…©ç·šæ®µç›¸äº¤æª¢æ¸¬ =====
      function lineSegmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        // è¨ˆç®—å‘é‡å‰ç©
        function cross(ax, ay, bx, by) {
          return ax * by - ay * bx;
        }

        const d1 = cross(x4 - x3, y4 - y3, x1 - x3, y1 - y3);
        const d2 = cross(x4 - x3, y4 - y3, x2 - x3, y2 - y3);
        const d3 = cross(x2 - x1, y2 - y1, x3 - x1, y3 - y1);
        const d4 = cross(x2 - x1, y2 - y1, x4 - x1, y4 - y1);

        if (
          ((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
          ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))
        ) {
          return true;
        }

        // æª¢æŸ¥å…±ç·šæƒ…æ³
        const eps = 1e-10;
        if (Math.abs(d1) < eps && onSegment(x3, y3, x4, y4, x1, y1))
          return true;
        if (Math.abs(d2) < eps && onSegment(x3, y3, x4, y4, x2, y2))
          return true;
        if (Math.abs(d3) < eps && onSegment(x1, y1, x2, y2, x3, y3))
          return true;
        if (Math.abs(d4) < eps && onSegment(x1, y1, x2, y2, x4, y4))
          return true;

        return false;
      }

      // ===== æª¢æŸ¥é»æ˜¯å¦åœ¨ç·šæ®µä¸Š =====
      function onSegment(x1, y1, x2, y2, px, py) {
        return (
          px >= Math.min(x1, x2) &&
          px <= Math.max(x1, x2) &&
          py >= Math.min(y1, y2) &&
          py <= Math.max(y1, y2)
        );
      }

      // ==================== æª¢è¦–æ¨¡å¼åŠŸèƒ½ ====================

      // åˆ‡æ›æª¢è¦–æ¨¡å¼
      function toggleInspectMode() {
        state.inspectMode = !state.inspectMode;
        const btn = document.getElementById("inspectModeBtn");
        if (btn) {
          btn.classList.toggle("inspect-active", state.inspectMode);
        }

        if (!state.inspectMode) {
          state.hoveredSegment = null;
          hideSegmentTooltip();
          render();
        }
      }

      // é¡¯ç¤ºç·šæ®µ tooltip
      function showSegmentTooltip(seg, mouseX, mouseY) {
        const tooltip = document.getElementById("segmentTooltip");
        const content = document.getElementById("tooltipContent");

        if (!tooltip || !content) return;

        // è¨ˆç®—é•·åº¦ï¼šä½¿ç”¨ INSUNITS é€²è¡Œå–®ä½è½‰æ›ï¼Œçµ±ä¸€é¡¯ç¤ºç‚ºå…¬å°º
        const lengthInMeters = convertToMeters(seg.length, state.insunits);

        // ä½¿ç”¨ getSegmentDisplayName å–å¾—é¡¯ç¤ºåç¨±
        // ç·¨è¼¯éçš„ç‰©ä»¶æœƒé¡¯ç¤ºã€Œé¡å‹åç¨±*ã€ï¼Œæœªç·¨è¼¯çš„é¡¯ç¤ºåœ–å±¤åç¨±
        const displayName = getSegmentDisplayName(seg);

        // æª¢æŸ¥æ˜¯å¦ç‚ºå¹³è¡Œå°ä¸­çš„çŸ­ç·š
        if (seg._isParallelShort) {
          content.textContent = `${displayName} | ${lengthInMeters.toFixed(
            2
          )}m (é€ åš)`;
        } else {
          content.textContent = `${displayName} | ${lengthInMeters.toFixed(
            2
          )}m`;
        }

        tooltip.style.left = mouseX + 15 + "px";
        tooltip.style.top = mouseY - 10 + "px";
        tooltip.classList.add("show");
      }

      // éš±è— tooltip
      function hideSegmentTooltip() {
        const tooltip = document.getElementById("segmentTooltip");
        if (tooltip) {
          tooltip.classList.remove("show");
        }
      }

      // ==================== æ»‘é¼ äº‹ä»¶ ====================
      // ã€å„ªåŒ–ã€‘é¡ä¼¼ AutoCAD çš„æ“ä½œæ–¹å¼ï¼š
      // - æ»¾è¼ªï¼šç¸®æ”¾ç•«å¸ƒ
      // - ä¸­éµæ‹–æ›³ï¼šå¹³ç§»ç•«å¸ƒ
      // - å³éµæ‹–æ›³ï¼šå¹³ç§»ç•«å¸ƒ
      // - å·¦éµï¼šé¸å–ç·šæ®µ / æ¡†é¸

      function handleMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // ä¸­éµæ‹–æ›³å¹³ç§»ï¼ˆä»»ä½•æ™‚å€™éƒ½å¯ç”¨ï¼‰
        if (e.button === 1) {
          e.preventDefault();
          state.isMiddleMousePanning = true;
          state.middleMouseStart = {
            x: e.clientX,
            y: e.clientY,
            panX: state.panX,
            panY: state.panY,
          };
          canvas.style.cursor = "grabbing";
          return;
        }

        // å³éµæ‹–æ›³å¹³ç§»ï¼ˆä»»ä½•æ™‚å€™éƒ½å¯ç”¨ï¼‰
        if (e.button === 2) {
          state.isDragging = true;
          state.dragStart = {
            x: e.clientX,
            y: e.clientY,
            panX: state.panX,
            panY: state.panY,
          };
          canvas.style.cursor = "grabbing";
          return;
        }

        // å·¦éµé»æ“Š - AutoCAD é¢¨æ ¼é¸å–é‚è¼¯
        if (e.button === 0) {
          // æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°ç·šæ®µ
          const clicked = findSegmentAtPoint(x, y);

          if (clicked) {
            // ===== é»é¸æ¨¡å¼ =====
            // é»æ“Šåˆ°ç‰©ä»¶ï¼šåˆ‡æ›é¸å–ç‹€æ…‹ï¼ˆAutoCAD è¡Œç‚ºï¼‰
            // - è‹¥è©²ç‰©ä»¶ç›®å‰æœªåœ¨é¸å–é›†ï¼Œå°‡å…¶åŠ å…¥é¸å–é›†
            // - è‹¥è©²ç‰©ä»¶å·²åœ¨é¸å–é›†ï¼Œå°‡å…¶è‡ªé¸å–é›†ä¸­ç§»é™¤
            const idx = state.selectedSegments.indexOf(clicked);
            if (idx >= 0) {
              // å·²åœ¨é¸å–é›†ä¸­ -> ç§»é™¤
              state.selectedSegments.splice(idx, 1);
            } else {
              // ä¸åœ¨é¸å–é›†ä¸­ -> åŠ å…¥
              state.selectedSegments.push(clicked);
            }
            updatePropertiesPanel();
            render();
          } else {
            // ===== æº–å‚™æ¡†é¸æ¨¡å¼ =====
            // é»æ“Šç©ºç™½å€åŸŸï¼šä¸æ”¹è®Šé¸å–é›†ï¼Œæº–å‚™é–‹å§‹æ¡†é¸
            // è¨˜éŒ„èµ·å§‹é»ï¼Œä½†å°šæœªé€²å…¥æ¡†é¸ç‹€æ…‹ï¼ˆéœ€è¦æ‹–æ›³æ‰è§¸ç™¼ï¼‰
            state.potentialBoxSelect = true;
            state.boxSelectStart = { x: e.clientX, y: e.clientY };
            state.boxSelectCurrent = { x: e.clientX, y: e.clientY };
          }
        }
      }

      function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // æ›´æ–°åº§æ¨™é¡¯ç¤º
        const worldX = (((x - state.panX) / state.zoom) * 1000).toFixed(0);
        const worldY = (
          ((canvas.height - y - state.panY) / state.zoom) *
          1000
        ).toFixed(0);
        document.getElementById(
          "statusRight"
        ).textContent = `åº§æ¨™: ${worldX}, ${worldY} | ç¸®æ”¾: ${Math.round(
          state.zoom * 100
        )}%`;

        // ä¸­éµæ‹–æ›³å¹³ç§»
        if (state.isMiddleMousePanning) {
          const dx = e.clientX - state.middleMouseStart.x;
          const dy = e.clientY - state.middleMouseStart.y;
          state.panX = state.middleMouseStart.panX + dx;
          state.panY = state.middleMouseStart.panY - dy;
          render();
          return;
        }

        // å³éµæ‹–æ›³å¹³ç§»
        if (state.isDragging) {
          const dx = e.clientX - state.dragStart.x;
          const dy = e.clientY - state.dragStart.y;
          state.panX = state.dragStart.panX + dx;
          state.panY = state.dragStart.panY - dy;
          render();
          return;
        }

        // ===== AutoCAD é¢¨æ ¼æ¡†é¸é‚è¼¯ =====
        // æº–å‚™æ¡†é¸ç‹€æ…‹ï¼šæª¢æŸ¥æ˜¯å¦è¶…éæ‹–æ›³é–¾å€¼
        if (state.potentialBoxSelect && state.boxSelectStart) {
          const dx = e.clientX - state.boxSelectStart.x;
          const dy = e.clientY - state.boxSelectStart.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // è¶…éé–¾å€¼æ‰é–‹å§‹çœŸæ­£çš„æ¡†é¸
          if (distance > state.boxSelectThreshold) {
            state.potentialBoxSelect = false;
            state.isBoxSelecting = true;
            canvas.classList.add("autocad-crosshair");
          }
        }

        // æ¡†é¸æ›´æ–°ï¼šå³æ™‚é¡¯ç¤ºé¸å–çŸ©å½¢
        if (state.isBoxSelecting) {
          state.boxSelectCurrent = { x: e.clientX, y: e.clientY };
          render();
          drawSelectionRect();
          return;
        }

        // æª¢è¦–æ¨¡å¼ - hover åµæ¸¬
        if (state.inspectMode) {
          const hovered = findSegmentAtPoint(x, y);
          if (hovered !== state.hoveredSegment) {
            state.hoveredSegment = hovered;
            render();
          }

          // æ›´æ–° tooltip
          if (hovered) {
            showSegmentTooltip(hovered, e.clientX, e.clientY);
          } else {
            hideSegmentTooltip();
          }
        }
      }

      function handleMouseUp(e) {
        // çµæŸä¸­éµå¹³ç§»
        if (state.isMiddleMousePanning) {
          state.isMiddleMousePanning = false;
        }

        // çµæŸå³éµæ‹–æ›³å¹³ç§»
        if (state.isDragging) {
          state.isDragging = false;
        }

        // ===== AutoCAD é¢¨æ ¼æ¡†é¸å®Œæˆ =====
        // æ”¾é–‹å·¦éµæ™‚ï¼šå¦‚æœæ­£åœ¨æ¡†é¸ä¸­ï¼Œå®Œæˆæ¡†é¸
        if (e.button === 0) {
          if (state.isBoxSelecting) {
            // å®Œæˆæ¡†é¸ï¼šå°‡æ¡†é¸å…§çš„ç‰©ä»¶åŠ å…¥é¸å–é›†
            state.boxSelectCurrent = { x: e.clientX, y: e.clientY };
            finishBoxSelection();

            // é‡ç½®æ¡†é¸ç‹€æ…‹
            state.isBoxSelecting = false;
            state.potentialBoxSelect = false;
            state.boxSelectStart = null;
            state.boxSelectCurrent = null;
            canvas.classList.remove("autocad-crosshair");
            render();
          } else if (state.potentialBoxSelect) {
            // æ²’æœ‰çœŸæ­£é–‹å§‹æ¡†é¸ï¼ˆæ²’è¶…éé–¾å€¼ï¼‰ï¼šåªæ˜¯å–®ç´”é»æ“Šç©ºç™½è™•
            // æ ¹æ“š AutoCAD è¦å‰‡ï¼šå–®æ“Šç©ºç™½å€åŸŸä¸æ”¹è®Šé¸å–é›†
            state.potentialBoxSelect = false;
            state.boxSelectStart = null;
            state.boxSelectCurrent = null;
          }
        }

        canvas.style.cursor = "default";
      }

      function handleWheel(e) {
        e.preventDefault();

        // å¦‚æœæ­£åœ¨æ‹–æ›³ä¸­ï¼Œå¿½ç•¥æ»¾è¼ªäº‹ä»¶ï¼ˆé˜²æ­¢è¡çªï¼‰
        if (state.isMiddleMousePanning || state.isDragging) {
          return;
        }

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // ã€æ“ä½œæ–¹å¼ã€‘æ»¾è¼ªï¼šç¸®æ”¾ï¼›ä¸­éµæ‹–æ›³ï¼šå¹³ç§»
        // Shift + æ»¾è¼ªï¼šæ°´å¹³å¹³ç§»ï¼ˆå¯é¸ï¼‰
        if (e.shiftKey) {
          console.log("[Canvas] Shift+Wheel horizontal pan, deltaY:", e.deltaY);
          // Shift + æ»¾è¼ªï¼šæ°´å¹³å¹³ç§»
          const panSpeed = 50;
          state.panX -= e.deltaY > 0 ? panSpeed : -panSpeed;
        } else {
          // æ»¾è¼ªç¸®æ”¾ï¼ˆä»¥æ»‘é¼ ä½ç½®ç‚ºä¸­å¿ƒï¼‰- ç„¡é™ç¸®æ”¾
          console.log("[Canvas] Wheel zoom, deltaY:", e.deltaY);
          const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
          // ç„¡é™ç¸®æ”¾ï¼šåªè¨­æ¥µå°çš„ä¸‹é™é¿å…æ•¸å­¸éŒ¯èª¤ï¼Œç„¡ä¸Šé™
          const newZoom = Math.max(0.0001, state.zoom * zoomFactor);

          // è¨ˆç®—ç¸®æ”¾å¾Œçš„å¹³ç§»åç§»ï¼Œä¿æŒæ»‘é¼ ä½ç½®ä¸è®Š
          state.panX = mouseX - (mouseX - state.panX) * (newZoom / state.zoom);
          state.panY =
            canvas.height -
            mouseY -
            (canvas.height - mouseY - state.panY) * (newZoom / state.zoom);
          state.zoom = newZoom;
        }

        render();

        // æ›´æ–°åº§æ¨™é¡¯ç¤º
        const worldX = (((mouseX - state.panX) / state.zoom) * 1000).toFixed(0);
        const worldY = (
          ((canvas.height - mouseY - state.panY) / state.zoom) *
          1000
        ).toFixed(0);
        document.getElementById(
          "statusRight"
        ).textContent = `åº§æ¨™: ${worldX}, ${worldY} | ç¸®æ”¾: ${Math.round(
          state.zoom * 100
        )}%`;
      }

      function handleKeyDown(e) {
        if (e.ctrlKey && e.key === "f") {
          e.preventDefault();
          openSearch();
        }
        if (e.key === "Escape") {
          // å–æ¶ˆæ¡†é¸ï¼ˆåŒ…æ‹¬æº–å‚™ç‹€æ…‹å’Œé€²è¡Œä¸­ç‹€æ…‹ï¼‰
          if (state.isBoxSelecting || state.potentialBoxSelect) {
            state.isBoxSelecting = false;
            state.potentialBoxSelect = false;
            state.boxSelectStart = null;
            state.boxSelectCurrent = null;
            canvas.classList.remove("autocad-crosshair");
            render();
            return;
          }
          // å–æ¶ˆé¸å–ï¼šæ¸…ç©ºé¸å–é›†
          state.selectedSegments = [];
          updatePropertiesPanel();
          render();
        }
        // I éµåˆ‡æ›æª¢è¦–æ¨¡å¼
        if (e.key === "i" || e.key === "I") {
          toggleInspectMode();
        }
      }

      function findSegmentAtPoint(x, y) {
        const threshold = 8;
        const filtered = getFilteredSegments();

        for (const seg of filtered) {
          // æª¢æŸ¥æ˜¯å¦æœ‰å¤šæ®µç·šé ‚é»
          if (seg.vertices && seg.vertices.length >= 2) {
            // å¤šæ®µç·šï¼šæª¢æŸ¥æ¯ä¸€æ®µ
            for (let i = 0; i < seg.vertices.length - 1; i++) {
              const x1 = (seg.vertices[i][0] * state.zoom) / 1000 + state.panX;
              const y1 =
                canvas.height -
                ((seg.vertices[i][1] * state.zoom) / 1000 + state.panY);
              const x2 =
                (seg.vertices[i + 1][0] * state.zoom) / 1000 + state.panX;
              const y2 =
                canvas.height -
                ((seg.vertices[i + 1][1] * state.zoom) / 1000 + state.panY);

              const dist = distanceToLineSegment(x, y, x1, y1, x2, y2);
              if (dist < threshold) {
                return seg;
              }
            }
          } else {
            // å–®ä¸€ç·šæ®µ
            const x1 = (seg.startX * state.zoom) / 1000 + state.panX;
            const y1 =
              canvas.height - ((seg.startY * state.zoom) / 1000 + state.panY);
            const x2 = (seg.endX * state.zoom) / 1000 + state.panX;
            const y2 =
              canvas.height - ((seg.endY * state.zoom) / 1000 + state.panY);

            const dist = distanceToLineSegment(x, y, x1, y1, x2, y2);
            if (dist < threshold) {
              return seg;
            }
          }
        }
        return null;
      }

      function distanceToLineSegment(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSq = dx * dx + dy * dy;

        if (lengthSq === 0) {
          return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
        }

        let t = Math.max(
          0,
          Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSq)
        );
        const projX = x1 + t * dx;
        const projY = y1 + t * dy;

        return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
      }

      // ==================== å·¥å…·æ“ä½œ ====================
      function selectTool(tool) {
        state.currentTool = tool;
        document.querySelectorAll(".canvas-tool-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.tool === tool);
        });
        canvas.style.cursor = tool === "pan" ? "grab" : "default";
      }

      function zoomIn() {
        state.zoom = Math.min(10, state.zoom * 1.2);
        render();
      }

      function zoomOut() {
        state.zoom = Math.max(0.1, state.zoom / 1.2);
        render();
      }

      function zoomFit() {
        if (state.segments.length === 0) return;

        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;

        state.segments.forEach((seg) => {
          minX = Math.min(minX, seg.startX, seg.endX);
          minY = Math.min(minY, seg.startY, seg.endY);
          maxX = Math.max(maxX, seg.startX, seg.endX);
          maxY = Math.max(maxY, seg.startY, seg.endY);
        });

        const width = (maxX - minX) / 1000;
        const height = (maxY - minY) / 1000;
        const padding = 50;

        state.zoom = Math.min(
          (canvas.width - padding * 2) / width,
          (canvas.height - padding * 2) / height
        );
        state.zoom = Math.max(0.1, Math.min(10, state.zoom));

        state.panX = padding - (minX * state.zoom) / 1000;
        state.panY = padding - (minY * state.zoom) / 1000;

        render();
      }

      function toggleGrid() {
        state.showGrid = !state.showGrid;
        document
          .getElementById("toggleGridBtn")
          .classList.toggle("active", state.showGrid);
        render();
      }

      function openSearch() {
        showNotification("æœå°‹åŠŸèƒ½é–‹ç™¼ä¸­", "info");
      }

      function toggleFullscreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      }

      // ==================== UI æ›´æ–° ====================
      function updateBuildingList() {
        const list = document.getElementById("buildingList");

        if (state.buildings.length === 0) {
          list.innerHTML =
            '<div class="empty-state" style="padding: 20px;"><div style="font-size: 12px;">è«‹å…ˆä¸Šå‚³ DXF æª”æ¡ˆ</div></div>';
          return;
        }

        list.innerHTML = state.buildings
          .map(
            (b) => `
                <div class="tree-item ${
                  state.selectedBuilding === b.id ? "selected" : ""
                }"
                     onclick="selectBuilding(${b.id})">
                    <span class="icon">ğŸ¢</span>
                    <span>${b.name}</span>
                </div>
            `
          )
          .join("");
      }

      function updateFloorList() {
        const list = document.getElementById("floorList");

        if (!state.selectedBuilding) {
          list.innerHTML =
            '<div class="empty-state" style="padding: 20px;"><div style="font-size: 12px;">è«‹é¸æ“‡çµæ§‹ç‰©</div></div>';
          return;
        }

        const floors = state.floors.filter(
          (f) => f.buildingId === state.selectedBuilding
        );

        if (floors.length === 0) {
          list.innerHTML =
            '<div class="empty-state" style="padding: 20px;"><div style="font-size: 12px;">ç„¡æ¨“å±¤è³‡æ–™</div></div>';
          return;
        }

        list.innerHTML = floors
          .map(
            (f) => `
                <div class="tree-item ${
                  state.selectedFloor === f.id ? "selected" : ""
                }"
                     onclick="selectFloor(${f.id})">
                    <span class="icon">ğŸ“Š</span>
                    <span>${f.name}</span>
                </div>
            `
          )
          .join("");
      }

      function updateCategoryList() {
        const list = document.getElementById("categoryList");

        if (state.categories.length === 0) {
          list.innerHTML =
            '<div class="empty-state" style="padding: 20px;"><div style="font-size: 12px;">å°šæœªè¨­å®š</div></div>';
          return;
        }

        list.innerHTML = state.categories
          .map((cat) => {
            const count = state.segments.filter(
              (s) => s.categoryId === cat.id
            ).length;
            const length =
              state.segments
                .filter((s) => s.categoryId === cat.id)
                .reduce((sum, s) => sum + s.length, 0) / 1000;

            return `
                    <div class="category-item" onclick="filterByCategory(${
                      cat.id
                    })">
                        <div class="category-color" style="background: ${
                          cat.color
                        }"></div>
                        <div class="category-info">
                            <div class="category-name">${cat.name} (${
              cat.code
            })</div>
                            <div class="category-stats">${count} æ¢ Â· ${length.toFixed(
              2
            )} m</div>
                        </div>
                    </div>
                `;
          })
          .join("");
      }

      function updateBuildingFilter() {
        const select = document.getElementById("buildingFilter");
        select.innerHTML =
          '<option value="">å…¨éƒ¨</option>' +
          state.buildings
            .map((b) => `<option value="${b.id}">${b.name}</option>`)
            .join("");
      }

      function updateFloorFilter() {
        const select = document.getElementById("floorFilter");
        const buildingId = document.getElementById("buildingFilter").value;

        let floors = state.floors;
        if (buildingId) {
          floors = floors.filter((f) => f.buildingId === parseInt(buildingId));
        }

        select.innerHTML =
          '<option value="">å…¨éƒ¨</option>' +
          floors
            .map((f) => `<option value="${f.id}">${f.name}</option>`)
            .join("");
      }

      function updateCategoryFilter() {
        const select = document.getElementById("categoryFilter");
        select.innerHTML =
          '<option value="">å…¨éƒ¨</option>' +
          state.categories
            .map((c) => `<option value="${c.id}">${c.name}</option>`)
            .join("");
      }

      function updatePropertiesPanel() {
        const noSel = document.getElementById("noSelection");
        const props = document.getElementById("selectionProperties");

        if (state.selectedSegments.length === 0) {
          noSel.style.display = "block";
          props.style.display = "none";
          return;
        }

        noSel.style.display = "none";
        props.style.display = "block";

        const seg = state.selectedSegments[0];
        document.getElementById("propId").textContent = seg.uid;
        document.getElementById("propLayer").textContent = seg.layer;
        document.getElementById("propLength").textContent = `${(
          seg.length / 1000
        ).toFixed(3)} m`;

        // æ›´æ–°ä¸‹æ‹‰é¸å–®
        const buildingSelect = document.getElementById("propBuilding");
        buildingSelect.innerHTML =
          '<option value="">æœªæŒ‡å®š</option>' +
          state.buildings
            .map(
              (b) =>
                `<option value="${b.id}" ${
                  seg.buildingId === b.id ? "selected" : ""
                }>${b.name}</option>`
            )
            .join("");

        const floorSelect = document.getElementById("propFloor");
        const floors = state.floors.filter(
          (f) => !seg.buildingId || f.buildingId === seg.buildingId
        );
        floorSelect.innerHTML =
          '<option value="">æœªæŒ‡å®š</option>' +
          floors
            .map(
              (f) =>
                `<option value="${f.id}" ${
                  seg.floorId === f.id ? "selected" : ""
                }>${f.name}</option>`
            )
            .join("");

        const categorySelect = document.getElementById("propCategory");
        categorySelect.innerHTML =
          '<option value="">æœªåˆ†é¡</option>' +
          state.categories
            .map(
              (c) =>
                `<option value="${c.id}" ${
                  seg.categoryId === c.id ? "selected" : ""
                }>${c.name}</option>`
            )
            .join("");

        updateStatusBar();
      }

      function updateSummary() {
        const tbody = document.querySelector("#summaryTable tbody");

        if (state.categories.length === 0 || state.segments.length === 0) {
          tbody.innerHTML =
            '<tr><td colspan="3" class="empty-state">å°šç„¡è³‡æ–™</td></tr>';
          return;
        }

        let totalCount = 0;
        let totalLength = 0;

        const rows = state.categories
          .map((cat) => {
            const segs = state.segments.filter((s) => s.categoryId === cat.id);
            const count = segs.length;
            const length = segs.reduce((sum, s) => sum + s.length, 0) / 1000;

            totalCount += count;
            totalLength += length;

            return `
                    <tr>
                        <td><span style="display:inline-block;width:10px;height:10px;background:${
                          cat.color
                        };border-radius:2px;margin-right:6px;"></span>${
              cat.name
            }</td>
                        <td>${count}</td>
                        <td>${length.toFixed(2)}</td>
                    </tr>
                `;
          })
          .join("");

        tbody.innerHTML =
          rows +
          `
                <tr class="summary-total">
                    <td>ç¸½è¨ˆ</td>
                    <td>${totalCount}</td>
                    <td>${totalLength.toFixed(2)}</td>
                </tr>
            `;
      }

      function updateStatusBar() {
        const count = state.selectedSegments.length;
        if (count === 0) {
          document.getElementById("statusLeft").textContent = `å…± ${
            state.segments.length
          } æ¢ç·šæ®µ | ç¯©é¸é¡¯ç¤º ${getFilteredSegments().length} æ¢`;
        } else if (count === 1) {
          const seg = state.selectedSegments[0];
          document.getElementById("statusLeft").textContent = `å·²é¸å–: ${
            seg.uid
          } | é•·åº¦: ${(seg.length / 1000).toFixed(2)}m`;
        } else {
          const totalLength = state.selectedSegments.reduce(
            (sum, s) => sum + s.length,
            0
          );
          document.getElementById(
            "statusLeft"
          ).textContent = `å·²é¸å– ${count} æ¢ç·šæ®µ | ç¸½é•·åº¦: ${(
            totalLength / 1000
          ).toFixed(2)}m`;
        }
      }

      // ==================== é¸æ“‡æ“ä½œ ====================
      function selectBuilding(id) {
        state.selectedBuilding = id;
        state.selectedFloor = null;
        updateBuildingList();
        updateFloorList();
        document.getElementById("buildingFilter").value = id;
        updateFloorFilter();
        applyFilters();
      }

      function selectFloor(id) {
        state.selectedFloor = id;
        updateFloorList();
        document.getElementById("floorFilter").value = id;
        applyFilters();
      }

      function filterByCategory(categoryId) {
        document.getElementById("categoryFilter").value = categoryId;
        applyFilters();
      }

      function applyFilters() {
        updateFloorFilter();
        render();
        updateStatusBar();

        // æ›´æ–°æ¨™é¡Œ
        const building = state.buildings.find(
          (b) =>
            b.id === parseInt(document.getElementById("buildingFilter").value)
        );
        const floor = state.floors.find(
          (f) => f.id === parseInt(document.getElementById("floorFilter").value)
        );

        let title = "çµæ§‹å¹³é¢åœ–";
        if (building) title += ` - ${building.name}`;
        if (floor) title += ` ${floor.name}`;
        if (!building && !floor) title += " (æ‰€æœ‰æ¨“å±¤åˆä½µ)";

        document.getElementById("canvasTitle").textContent = title;
      }

      function applyProperties() {
        const buildingId = document.getElementById("propBuilding").value;
        const floorId = document.getElementById("propFloor").value;
        const categoryId = document.getElementById("propCategory").value;

        state.selectedSegments.forEach((seg) => {
          if (buildingId) seg.buildingId = parseInt(buildingId);
          if (floorId) seg.floorId = parseInt(floorId);
          if (categoryId) seg.categoryId = parseInt(categoryId);
        });

        updateCategoryList();
        updateSummary();
        render();
        showNotification("å±¬æ€§å·²æ›´æ–°", "success");
      }

      // ==================== é¢æ¿åˆ‡æ› ====================
      function switchPanel(panel) {
        document.querySelectorAll(".panel-tab").forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.panel === panel);
        });

        document.getElementById("propertiesPanel").style.display =
          panel === "properties" ? "block" : "none";
        document.getElementById("summaryPanel").style.display =
          panel === "summary" ? "block" : "none";
      }

      // ==================== Modal å°è©±æ¡† ====================
      function openCategoryModal() {
        document.getElementById("categoryModal").classList.add("show");
        renderCategoryForm();
      }

      function closeCategoryModal() {
        document.getElementById("categoryModal").classList.remove("show");
      }

      function renderCategoryForm() {
        const container = document.getElementById("categoryFormList");
        container.innerHTML = state.categories
          .map(
            (cat, idx) => `
                <div class="form-group" style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <input type="color" value="${
                      cat.color
                    }" data-idx="${idx}" class="cat-color" style="width: 40px; height: 36px; border: none; cursor: pointer;">
                    <input type="text" class="form-input cat-code" data-idx="${idx}" value="${
              cat.code
            }" placeholder="ä»£ç¢¼" style="width: 80px;">
                    <input type="text" class="form-input cat-name" data-idx="${idx}" value="${
              cat.name
            }" placeholder="åç¨±" style="flex: 1; min-width: 100px;">
                    <input type="text" class="form-input cat-height" data-idx="${idx}" value="${
              cat.heightType
            }" placeholder="é«˜åº¦é¡å‹" style="width: 100px;">
                    <div class="thickness-input-group">
                        <input type="number" class="form-input cat-thickness" data-idx="${idx}" value="${
              cat.wallThickness || ""
            }" placeholder="ç‰†åš" step="1" min="0" style="width: 70px;">
                        <span class="thickness-unit">mm</span>
                    </div>
                    <button class="btn btn-outline" onclick="removeCategoryRow(${idx})" style="padding: 8px;">âœ•</button>
                </div>
            `
          )
          .join("");
      }

      function addCategoryRow() {
        state.categories.push({
          id: Date.now(),
          code: "",
          name: "",
          heightType: "",
          color: "#888888",
          wallThickness: null,
        });
        renderCategoryForm();
      }

      function removeCategoryRow(idx) {
        state.categories.splice(idx, 1);
        renderCategoryForm();
      }

      function saveCategories() {
        document.querySelectorAll(".cat-code").forEach((input, idx) => {
          state.categories[idx].code = input.value;
        });
        document.querySelectorAll(".cat-name").forEach((input, idx) => {
          state.categories[idx].name = input.value;
        });
        document.querySelectorAll(".cat-height").forEach((input, idx) => {
          state.categories[idx].heightType = input.value;
        });
        document.querySelectorAll(".cat-color").forEach((input, idx) => {
          state.categories[idx].color = input.value;
        });
        document.querySelectorAll(".cat-thickness").forEach((input, idx) => {
          const value = parseFloat(input.value);
          state.categories[idx].wallThickness = isNaN(value) ? null : value;
        });

        // åŒæ­¥ç‰†åšåº¦åˆ°å¾Œç«¯ï¼ˆå¦‚æœæœ‰ projectIdï¼‰
        if (state.projectId) {
          state.categories.forEach(async (cat) => {
            if (cat.wallThickness) {
              try {
                await fetch(`/api/categories/${cat.id}/thickness`, {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    wall_thickness: cat.wallThickness,
                    wall_thickness_tolerance: 1.0,
                  }),
                });
              } catch (e) {
                console.error("[saveCategories] åŒæ­¥ç‰†åšåº¦å¤±æ•—:", e);
              }
            }
          });
        }

        updateCategoryList();
        updateCategoryFilter();
        updateSummary();
        render();
        closeCategoryModal();
        showNotification("ç‰†é¡å‹å·²æ›´æ–°", "success");
      }

      function addBuilding() {
        state.structureModalMode = "building";
        document.getElementById("structureModalTitle").textContent =
          "æ–°å¢çµæ§‹ç‰©";
        document.getElementById("floorRangeGroup").style.display = "none";
        document.getElementById("structureName").value = "";
        document.getElementById("structureModal").classList.add("show");
      }

      function addFloor() {
        if (!state.selectedBuilding) {
          showNotification("è«‹å…ˆé¸æ“‡çµæ§‹ç‰©", "error");
          return;
        }
        state.structureModalMode = "floor";
        document.getElementById("structureModalTitle").textContent = "æ–°å¢æ¨“å±¤";
        document.getElementById("floorRangeGroup").style.display = "block";
        document.getElementById("structureName").value = "";
        document.getElementById("floorRange").value = "";
        document.getElementById("structureModal").classList.add("show");
      }

      function closeStructureModal() {
        document.getElementById("structureModal").classList.remove("show");
      }

      function saveStructure() {
        const name = document.getElementById("structureName").value.trim();
        if (!name) {
          showNotification("è«‹è¼¸å…¥åç¨±", "error");
          return;
        }

        if (state.structureModalMode === "building") {
          state.buildings.push({
            id: Date.now(),
            name: name,
          });
          updateBuildingList();
          updateBuildingFilter();
        } else {
          state.floors.push({
            id: Date.now(),
            buildingId: state.selectedBuilding,
            name: name,
          });
          updateFloorList();
          updateFloorFilter();
        }

        closeStructureModal();
        showNotification("å·²æ–°å¢", "success");
      }

      // ==================== åŒ¯å‡ºåŠŸèƒ½ ====================
      function exportExcel() {
        showNotification("åŒ¯å‡º Excel åŠŸèƒ½é–‹ç™¼ä¸­", "info");
      }

      function exportDxf() {
        showNotification("åŒ¯å‡º AutoCAD åŠŸèƒ½é–‹ç™¼ä¸­", "info");
      }

      function exportCsv() {
        showNotification("åŒ¯å‡º CSV åŠŸèƒ½é–‹ç™¼ä¸­", "info");
      }

      // ==================== åœ–å±¤é¸æ“‡åŠŸèƒ½ ====================
      function openLayerSelectionModal() {
        showNotification("åœ–å±¤é¸æ“‡åŠŸèƒ½é–‹ç™¼ä¸­", "info");
      }

      // ==================== é¸å–ç‹€æ…‹æ›´æ–° ====================
      // æ›´æ–°ç‹€æ…‹åˆ—é¡¯ç¤ºé¸å–æ•¸é‡
      function updatePropertiesPanel() {
        const statusLeft = document.getElementById("statusLeft");
        if (statusLeft) {
          const count = state.selectedSegments.length;
          if (count === 0) {
            statusLeft.textContent =
              "æº–å‚™å°±ç·’ - é»é¸ç‰©ä»¶å¯åŠ å…¥/ç§»é™¤é¸å–ï¼Œæ‹–æ›³æ¡†é¸å¤šå€‹ç‰©ä»¶";
          } else {
            statusLeft.textContent = `å·²é¸å– ${count} å€‹ç‰©ä»¶`;
          }
        }

        // åŒæ™‚æ›´æ–°çµ±è¨ˆé¢æ¿ä¸­çš„é¸å–è³‡è¨Š
        updateCurrentSelectionInfo();
      }

      // ==================== è¼”åŠ©å‡½æ•¸ ====================
      function showLoading(show, text = "è™•ç†ä¸­...") {
        const overlay = document.getElementById("loading");
        overlay.querySelector(".loading-text").textContent = text;
        overlay.classList.toggle("show", show);
      }

      function showNotification(message, type = "info") {
        const notif = document.getElementById("notification");
        notif.textContent = message;
        notif.className = `notification ${type} show`;

        setTimeout(() => {
          notif.classList.remove("show");
        }, 3000);
      }

      // ==================== çµ±è¨ˆåŠŸèƒ½ ====================

      /**
       * è¨ˆç®—é¸å–ç‰©ä»¶çš„çµ±è¨ˆè³‡æ–™
       * æœƒå…ˆé€²è¡Œå¹³è¡Œç‰†åµæ¸¬ï¼Œå†æ’é™¤è¢«æ¨™è¨˜ç‚ºè¼ƒçŸ­ç·šæ®µçš„ç‰©ä»¶
       */
      function calculateSelectedStats() {
        if (state.selectedSegments.length === 0) {
          showNotification("è«‹å…ˆé¸å–ç‰©ä»¶å†é€²è¡Œçµ±è¨ˆ", "error");
          return;
        }

        // å…ˆé‡å°é¸å–çš„ç·šæ®µé€²è¡Œå¹³è¡Œç‰†åµæ¸¬
        const pairCount = detectParallelWallsInSelection(
          state.selectedSegments
        );
        if (pairCount > 0) {
          console.log(`[calculateSelectedStats] æª¢æ¸¬åˆ° ${pairCount} å°å¹³è¡Œç‰†`);
        }

        // éæ¿¾æ‰è¢«æ¨™è¨˜ç‚ºå¹³è¡Œå°çŸ­ç·šçš„ç·šæ®µ
        let effectiveSegments = state.selectedSegments.filter(
          (seg) => !seg._isParallelShort
        );
        const parallelExcludedCount =
          state.selectedSegments.length - effectiveSegments.length;

        if (parallelExcludedCount > 0) {
          console.log(
            `[calculateSelectedStats] æ’é™¤ ${parallelExcludedCount} æ¢å¹³è¡Œå°çŸ­ç·š`
          );
        }

        // éæ¿¾æ‰ã€Œé•·åº¦ç­‰æ–¼ç‰†åšåº¦ã€çš„ç·šæ®µï¼ˆé€™äº›æ˜¯æ¨™ç¤ºç‰†åšçš„çŸ­ç·šï¼‰
        const beforeThicknessFilter = effectiveSegments.length;
        effectiveSegments = effectiveSegments.filter((seg) => {
          const settings = state.layerSettings[seg.layer] || {};
          const wallThicknessCm = settings.wallThickness || 0;
          
          if (wallThicknessCm <= 0) {
            return true; // æ²’è¨­å®šç‰†åšå°±ä¿ç•™
          }
          
          // å°‡ç‰†åšå¾ cm è½‰ç‚º DXF å–®ä½ï¼Œä»¥ä¾¿èˆ‡ seg.length æ¯”è¼ƒ
          const wallThicknessM = wallThicknessCm / 100; // cm -> m
          const unitInfo = INSUNITS_MAP[state.insunits] || INSUNITS_MAP[0];
          const wallThicknessDxf = wallThicknessM / unitInfo.toMeters; // m -> DXF å–®ä½
          
          // å…è¨± Â±0.5cm çš„å®¹å·®
          const toleranceM = 0.005; // 0.5cm = 0.005m
          const toleranceDxf = toleranceM / unitInfo.toMeters;
          
          const isThicknessLine = Math.abs(seg.length - wallThicknessDxf) <= toleranceDxf;
          
          if (isThicknessLine) {
            console.log(`[calculateSelectedStats] æ’é™¤ç‰†åšæ¨™ç¤ºç·š: layer=${seg.layer}, length=${seg.length.toFixed(2)} â‰ˆ ç‰†åš=${wallThicknessDxf.toFixed(2)}`);
          }
          
          return !isThicknessLine;
        });
        const thicknessExcludedCount = beforeThicknessFilter - effectiveSegments.length;

        if (thicknessExcludedCount > 0) {
          console.log(
            `[calculateSelectedStats] æ’é™¤ ${thicknessExcludedCount} æ¢ç‰†åšæ¨™ç¤ºç·š`
          );
        }

        // ä¾é¡¯ç¤ºåç¨±åˆ†çµ„çµ±è¨ˆï¼ˆè‡ªå®šç¾©é¡å‹å„ªå…ˆï¼Œå¦å‰‡æŒ‰åœ–å±¤ï¼‰
        const groupStats = {};
        let totalLength = 0;
        let totalCount = effectiveSegments.length;

        effectiveSegments.forEach((seg) => {
          // ä½¿ç”¨é¡¯ç¤ºåç¨±ä½œç‚ºåˆ†çµ„éµï¼ˆè‡ªå®šç¾©é¡å‹æœƒæœ‰æ˜Ÿè™Ÿï¼‰
          const groupName = getSegmentDisplayName(seg);
          const groupColor = getSegmentDisplayColor(seg);

          if (!groupStats[groupName]) {
            groupStats[groupName] = {
              layer: groupName, // ä¿æŒ layer å±¬æ€§åä»¥ç›¸å®¹ç¾æœ‰ç¨‹å¼ç¢¼
              count: 0,
              length: 0,
              color: groupColor,
            };
          }
          groupStats[groupName].count++;
          groupStats[groupName].length += seg.length || 0;
          totalLength += seg.length || 0;
        });

        // è½‰æ›ç‚ºé™£åˆ—ä¸¦æ’åºï¼ˆæŒ‰é•·åº¦é™åºï¼‰
        const groupStatsArray = Object.values(groupStats).sort(
          (a, b) => b.length - a.length
        );

        // æš«å­˜çµ±è¨ˆçµæœ
        state.pendingStats = {
          timestamp: new Date().toISOString(),
          totalCount: totalCount,
          totalLength: totalLength,
          totalMeters: convertToMeters(totalLength, state.insunits),
          layers: groupStatsArray, // ä¿æŒ layers å±¬æ€§åä»¥ç›¸å®¹ç¾æœ‰ç¨‹å¼ç¢¼
          insunits: state.insunits,
        };

        // é¡¯ç¤ºçµ±è¨ˆé è¦½ä¸¦æ‰“é–‹å‘½åå°è©±æ¡†
        showStatsPreview(state.pendingStats);
        openStatsNameModal();
      }

      /**
       * é¡¯ç¤ºçµ±è¨ˆé è¦½
       */
      function showStatsPreview(stats) {
        const previewEl = document.getElementById("statsPreview");
        if (!previewEl) return;

        let html = "";

        // å„åœ–å±¤çµ±è¨ˆï¼ˆåªé¡¯ç¤ºåˆ†åœ–å±¤ï¼Œä¸é¡¯ç¤ºç¸½è¨ˆï¼‰
        stats.layers.forEach((layer) => {
          const lengthM = convertToMeters(layer.length, stats.insunits);
          html += `
          <div class="stats-preview-row">
            <span style="display: flex; align-items: center; gap: 6px;">
              <span style="width: 10px; height: 10px; background: ${
                layer.color
              }; border-radius: 2px;"></span>
              ${layer.layer}
            </span>
            <span>${lengthM.toFixed(2)}m (${layer.count}å€‹)</span>
          </div>
        `;
        });

        previewEl.innerHTML = html;
      }

      /**
       * é–‹å•Ÿçµ±è¨ˆå‘½åå°è©±æ¡†
       */
      function openStatsNameModal() {
        // è‡ªå‹•ç”Ÿæˆé è¨­åç¨±
        const now = new Date();
        const defaultName = `çµ±è¨ˆ ${
          now.getMonth() + 1
        }/${now.getDate()} ${now.getHours()}:${String(
          now.getMinutes()
        ).padStart(2, "0")}`;

        const nameInput = document.getElementById("statsNameInput");
        if (nameInput) {
          nameInput.value = defaultName;
          nameInput.select();
        }

        document.getElementById("statsNameModal").classList.add("show");
      }

      /**
       * é—œé–‰çµ±è¨ˆå‘½åå°è©±æ¡†
       */
      function closeStatsNameModal() {
        document.getElementById("statsNameModal").classList.remove("show");
        state.pendingStats = null;
      }

      /**
       * å„²å­˜çµ±è¨ˆçµæœ
       */
      function saveStatsResult() {
        if (!state.pendingStats) {
          showNotification("æ²’æœ‰å¾…å„²å­˜çš„çµ±è¨ˆè³‡æ–™", "error");
          return;
        }

        const nameInput = document.getElementById("statsNameInput");
        const name =
          nameInput?.value?.trim() || `çµ±è¨ˆ #${state.statsIdCounter + 1}`;

        // å»ºç«‹çµ±è¨ˆçµæœç‰©ä»¶
        const statsResult = {
          id: ++state.statsIdCounter,
          name: name,
          ...state.pendingStats,
          createdAt: new Date().toISOString(),
        };

        // å„²å­˜åˆ°é™£åˆ—
        state.savedStats.unshift(statsResult); // æ–°çš„æ”¾å‰é¢

        // é—œé–‰å°è©±æ¡†
        closeStatsNameModal();

        // æ›´æ–° UI
        renderSavedStatsList();
        updateStatsCount();

        // åˆ‡æ›åˆ°çµ±è¨ˆé ç±¤
        switchTab("stats");

        showNotification(`å·²å„²å­˜ã€Œ${name}ã€`, "success");
      }

      /**
       * æ¸²æŸ“å·²å„²å­˜çš„çµ±è¨ˆçµæœåˆ—è¡¨
       */
      function renderSavedStatsList() {
        const listEl = document.getElementById("savedStatsList");
        if (!listEl) return;

        if (state.savedStats.length === 0) {
          listEl.innerHTML = `
          <div class="empty-state" style="padding: 30px 20px;">
            <div style="font-size: 32px; margin-bottom: 8px; opacity: 0.5;">ğŸ“‹</div>
            <div style="font-size: 13px;">é¸å–ç‰©ä»¶å¾Œé»æ“Šã€Œçµ±è¨ˆé¸å–çš„ç‰©ä»¶ã€</div>
          </div>
        `;
          return;
        }

        listEl.innerHTML = state.savedStats
          .map((stats) => {
            // æ¸²æŸ“æ‰€æœ‰åœ–å±¤çš„çµ±è¨ˆ
            const allLayersHtml = stats.layers
              .map((l) => {
                const lengthM = convertToMeters(l.length, stats.insunits);
                return `
            <div class="stats-layer-item">
              <span class="stats-layer-name">
                <span class="color-dot" style="background: ${l.color};"></span>
                ${l.layer}
              </span>
              <span class="stats-layer-length">${lengthM.toFixed(2)}m</span>
            </div>
          `;
              })
              .join("");

            return `
          <div class="stats-result-card" data-stats-id="${stats.id}">
            <div class="stats-result-header">
              <span class="stats-result-title">
                <span>ğŸ“Š</span> ${stats.name}
              </span>
              <div class="stats-result-actions">
                <button class="expand" onclick="toggleStatsDetails(${stats.id})" title="å±•é–‹/æ”¶åˆ">
                  <span class="expand-btn" id="expand-btn-${stats.id}">â–¼</span>
                </button>
                <button class="delete" onclick="deleteStats(${stats.id})" title="åˆªé™¤">ğŸ—‘ï¸</button>
              </div>
            </div>
            <div class="stats-result-body">
              <div class="stats-result-summary">
                <span class="stats-result-label">ç‰©ä»¶æ•¸</span>
                <span class="stats-result-value">${stats.totalCount} å€‹</span>
              </div>
              <div class="stats-result-summary">
                <span class="stats-result-label">åœ–å±¤æ•¸</span>
                <span class="stats-result-value">${stats.layers.length} å€‹</span>
              </div>
            </div>
            <div class="stats-layer-list" id="stats-layers-${stats.id}">
              ${allLayersHtml}
            </div>
          </div>
        `;
          })
          .join("");
      }

      /**
       * å±•é–‹/æ”¶åˆçµ±è¨ˆè©³æƒ…
       */
      function toggleStatsDetails(statsId) {
        const layerList = document.getElementById(`stats-layers-${statsId}`);
        const expandBtn = document.getElementById(`expand-btn-${statsId}`);

        if (layerList) {
          layerList.classList.toggle("expanded");
          if (expandBtn) {
            expandBtn.textContent = layerList.classList.contains("expanded")
              ? "â–²"
              : "â–¼";
          }
        }
      }

      /**
       * åˆªé™¤çµ±è¨ˆçµæœ
       */
      function deleteStats(statsId) {
        const idx = state.savedStats.findIndex((s) => s.id === statsId);
        if (idx >= 0) {
          const name = state.savedStats[idx].name;
          state.savedStats.splice(idx, 1);
          renderSavedStatsList();
          updateStatsCount();
          showNotification(`å·²åˆªé™¤ã€Œ${name}ã€`, "info");
        }
      }

      /**
       * æ›´æ–°çµ±è¨ˆæ•¸é‡é¡¯ç¤º
       */
      function updateStatsCount() {
        const countEl = document.getElementById("savedStatsCount");
        if (countEl) {
          countEl.textContent = `${state.savedStats.length} ç­†`;
        }
      }

      /**
       * æ›´æ–°ç•¶å‰é¸å–è³‡è¨Šé¡¯ç¤ºï¼ˆåœ¨çµ±è¨ˆé¢æ¿ä¸­ï¼‰
       */
      function updateCurrentSelectionInfo() {
        const infoEl = document.getElementById("currentSelectionInfo");
        if (!infoEl) return;

        const count = state.selectedSegments.length;
        if (count === 0) {
          infoEl.textContent = "å°šæœªé¸å–ç‰©ä»¶";
          infoEl.classList.remove("has-selection");
        } else {
          infoEl.innerHTML = `å·²é¸å– <strong>${count}</strong> å€‹ç‰©ä»¶`;
          infoEl.classList.add("has-selection");
        }
      }

      // ==================== é¡å‹æŒ‡æ´¾åŠŸèƒ½ ====================

      /**
       * é–‹å•Ÿé¡å‹æŒ‡æ´¾å°è©±æ¡†
       */
      function openAssignTypeModal() {
        if (state.selectedSegments.length === 0) {
          showNotification("è«‹å…ˆé¸å–ç‰©ä»¶å†æŒ‡æ´¾é¡å‹", "error");
          return;
        }

        // æ›´æ–°é¸å–æ•¸é‡
        document.getElementById("assignTypeCount").textContent =
          state.selectedSegments.length;

        // æ¸²æŸ“ç¾æœ‰é¡å‹åˆ—è¡¨
        renderExistingTypesList();

        // æ¸…ç©ºæ–°é¡å‹è¼¸å…¥
        document.getElementById("newTypeName").value = "";

        // é¡¯ç¤ºå°è©±æ¡†
        document.getElementById("assignTypeModal").classList.add("show");
      }

      /**
       * é—œé–‰é¡å‹æŒ‡æ´¾å°è©±æ¡†
       */
      function closeAssignTypeModal() {
        document.getElementById("assignTypeModal").classList.remove("show");
      }

      /**
       * æ¸²æŸ“ç¾æœ‰é¡å‹åˆ—è¡¨
       */
      function renderExistingTypesList() {
        const listEl = document.getElementById("existingTypesList");
        if (!listEl) return;

        if (state.customTypes.length === 0) {
          listEl.innerHTML = `
          <div class="no-types-hint">
            å°šæœªå»ºç«‹ä»»ä½•é¡å‹ï¼Œè«‹åœ¨ä¸‹æ–¹å»ºç«‹æ–°é¡å‹
          </div>
        `;
          return;
        }

        // è¨ˆç®—æ¯å€‹é¡å‹çš„ç‰©ä»¶æ•¸é‡
        const typeCounts = {};
        state.segments.forEach((seg) => {
          if (seg.customTypeId) {
            typeCounts[seg.customTypeId] =
              (typeCounts[seg.customTypeId] || 0) + 1;
          }
        });

        listEl.innerHTML = state.customTypes
          .map(
            (type) => `
        <div class="type-option">
          <div class="color-swatch" style="background: ${type.color};"></div>
          <span class="type-name">${type.name}</span>
          <span class="type-count">${typeCounts[type.id] || 0} å€‹ç‰©ä»¶</span>
          <button class="assign-btn" onclick="assignTypeToSelected(${
            type.id
          })">æŒ‡æ´¾</button>
        </div>
      `
          )
          .join("");
      }

      /**
       * å»ºç«‹æ–°é¡å‹ä¸¦æŒ‡æ´¾çµ¦é¸å–çš„ç‰©ä»¶
       */
      function createAndAssignType() {
        const nameInput = document.getElementById("newTypeName");
        const colorInput = document.getElementById("newTypeColor");

        const name = nameInput.value.trim();
        if (!name) {
          showNotification("è«‹è¼¸å…¥é¡å‹åç¨±", "error");
          return;
        }

        // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåé¡å‹
        const existing = state.customTypes.find((t) => t.name === name);
        if (existing) {
          showNotification(`é¡å‹ã€Œ${name}ã€å·²å­˜åœ¨ï¼Œå°‡ç›´æ¥æŒ‡æ´¾`, "info");
          assignTypeToSelected(existing.id);
          return;
        }

        // å»ºç«‹æ–°é¡å‹
        const newType = {
          id: ++state.customTypeIdCounter,
          name: name,
          color: colorInput.value,
        };
        state.customTypes.push(newType);

        // æŒ‡æ´¾çµ¦é¸å–çš„ç‰©ä»¶
        assignTypeToSelected(newType.id);

        showNotification(
          `å·²å»ºç«‹é¡å‹ã€Œ${name}ã€ä¸¦æŒ‡æ´¾çµ¦ ${state.selectedSegments.length} å€‹ç‰©ä»¶`,
          "success"
        );
      }

      /**
       * å°‡é¡å‹æŒ‡æ´¾çµ¦é¸å–çš„ç‰©ä»¶
       */
      function assignTypeToSelected(typeId) {
        const type = state.customTypes.find((t) => t.id === typeId);
        if (!type) return;

        // ç‚ºæ¯å€‹é¸å–çš„ç‰©ä»¶è¨­å®šé¡å‹
        state.selectedSegments.forEach((seg) => {
          seg.customTypeId = typeId;
          seg.customTypeName = type.name;
          seg.customTypeColor = type.color;
        });

        // é—œé–‰å°è©±æ¡†
        closeAssignTypeModal();

        // é‡æ–°æ¸²æŸ“
        render();

        showNotification(
          `å·²å°‡ ${state.selectedSegments.length} å€‹ç‰©ä»¶æŒ‡æ´¾ç‚ºã€Œ${type.name}ã€`,
          "success"
        );
      }

      /**
       * æ¸…é™¤é¸å–ç‰©ä»¶çš„é¡å‹
       */
      function clearSegmentTypes() {
        if (state.selectedSegments.length === 0) {
          showNotification("è«‹å…ˆé¸å–ç‰©ä»¶", "error");
          return;
        }

        state.selectedSegments.forEach((seg) => {
          delete seg.customTypeId;
          delete seg.customTypeName;
          delete seg.customTypeColor;
        });

        // é—œé–‰å°è©±æ¡†
        closeAssignTypeModal();

        // é‡æ–°æ¸²æŸ“
        render();

        showNotification(
          `å·²æ¸…é™¤ ${state.selectedSegments.length} å€‹ç‰©ä»¶çš„é¡å‹`,
          "info"
        );
      }

      /**
       * å–å¾—ç‰©ä»¶çš„é¡¯ç¤ºé¡è‰²ï¼ˆå„ªå…ˆä½¿ç”¨è‡ªå®šç¾©é¡å‹é¡è‰²ï¼‰
       */
      function getSegmentDisplayColor(seg) {
        if (seg.customTypeColor) {
          return seg.customTypeColor;
        }
        return state.layerColors[seg.layer] || "#888888";
      }

      /**
       * å–å¾—ç‰©ä»¶çš„é¡¯ç¤ºåç¨±ï¼ˆç”¨æ–¼ tooltip å’Œçµ±è¨ˆï¼‰
       * å¦‚æœæœ‰è‡ªå®šç¾©é¡å‹ï¼Œé¡¯ç¤ºã€Œé¡å‹åç¨±*ã€
       */
      function getSegmentDisplayName(seg) {
        if (seg.customTypeName) {
          return `${seg.customTypeName}*`; // æ˜Ÿè™Ÿè¡¨ç¤ºå·²ç·¨è¼¯
        }
        return seg.layer;
      }

      // ==================== å¹³è¡Œç‰†åˆä½µ API ====================

      // æš«å­˜åµæ¸¬åˆ°çš„å¹³è¡Œç·šå°
      let detectedPairs = {};

      /**
       * åµæ¸¬å¹³è¡Œç‰† API
       */
      async function detectParallelWallsAPI() {
        if (!state.projectId) {
          showNotification("è«‹å…ˆè¼‰å…¥å°ˆæ¡ˆ", "error");
          return;
        }

        try {
          showNotification("æ­£åœ¨åµæ¸¬å¹³è¡Œç‰†...", "info");

          const response = await fetch(
            `/api/projects/${state.projectId}/detect-parallels`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                category_ids: null, // åµæ¸¬å…¨éƒ¨é¡å‹
                auto_apply: false,
              }),
            }
          );

          const result = await response.json();

          if (result.success) {
            detectedPairs = result.pairs_by_category || {};
            const pairsFound = result.pairs_found || 0;

            // æ›´æ–° UI
            document.getElementById("pairsFoundCount").textContent = pairsFound;
            document.getElementById("mergeResult").style.display = "block";

            if (pairsFound > 0) {
              document.getElementById("applyMergingBtn").style.display =
                "block";
              showNotification(`åµæ¸¬åˆ° ${pairsFound} å°å¹³è¡Œç‰†`, "success");
            } else {
              document.getElementById("applyMergingBtn").style.display = "none";
              showNotification(
                "æœªåµæ¸¬åˆ°å¹³è¡Œç‰†ï¼ˆè«‹ç¢ºèªå·²è¨­å®šç‰†åšåº¦ï¼‰",
                "warning"
              );
            }

            // å¦‚æœæœ‰åˆä½µçµ±è¨ˆï¼Œé¡¯ç¤ºæ¸…é™¤æŒ‰éˆ•
            await updateMergeStatistics();
          } else {
            showNotification(
              "åµæ¸¬å¤±æ•—: " + (result.error || "æœªçŸ¥éŒ¯èª¤"),
              "error"
            );
          }
        } catch (e) {
          console.error("[detectParallelWallsAPI] éŒ¯èª¤:", e);
          showNotification("åµæ¸¬å¤±æ•—: " + e.message, "error");
        }
      }

      /**
       * å¥—ç”¨åˆä½µ API
       */
      async function applyMergingAPI() {
        if (!state.projectId || Object.keys(detectedPairs).length === 0) {
          showNotification("æ²’æœ‰å¾…å¥—ç”¨çš„å¹³è¡Œå°", "error");
          return;
        }

        try {
          // å±•å¹³æ‰€æœ‰ pairs
          const allPairs = [];
          Object.values(detectedPairs).forEach((pairs) => {
            pairs.forEach((p) => allPairs.push(p));
          });

          const response = await fetch(
            `/api/projects/${state.projectId}/apply-merging`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ pairs: allPairs }),
            }
          );

          const result = await response.json();

          if (result.success) {
            const merged = result.segments_merged || 0;
            const savedLength = (result.total_length_saved || 0) / 1000; // è½‰æ›ç‚ºå…¬å°º

            // æ›´æ–° UI
            document.getElementById("mergedSegmentCount").textContent = merged;
            document.getElementById("savedLength").textContent =
              savedLength.toFixed(2) + " m";
            document.getElementById("applyMergingBtn").style.display = "none";
            document.getElementById("clearMergingBtn").style.display = "block";

            // æ¸…ç©ºå·²å¥—ç”¨çš„ pairs
            detectedPairs = {};

            showNotification(
              `å·²åˆä½µ ${merged} æ¢ç·šæ®µï¼Œç¯€çœ ${savedLength.toFixed(2)} å…¬å°º`,
              "success"
            );

            // é‡æ–°æ¸²æŸ“ï¼ˆæ¨™è¨˜å·²åˆä½µç·šæ®µï¼‰
            await updateMergeStatistics();
            render();
          } else {
            showNotification(
              "å¥—ç”¨å¤±æ•—: " + (result.error || "æœªçŸ¥éŒ¯èª¤"),
              "error"
            );
          }
        } catch (e) {
          console.error("[applyMergingAPI] éŒ¯èª¤:", e);
          showNotification("å¥—ç”¨å¤±æ•—: " + e.message, "error");
        }
      }

      /**
       * æ¸…é™¤åˆä½µ API
       */
      async function clearMergingAPI() {
        if (!state.projectId) {
          showNotification("è«‹å…ˆè¼‰å…¥å°ˆæ¡ˆ", "error");
          return;
        }

        try {
          const response = await fetch(
            `/api/projects/${state.projectId}/clear-merging`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({}),
            }
          );

          const result = await response.json();

          if (result.success) {
            const cleared = result.segments_cleared || 0;

            // é‡ç½® UI
            document.getElementById("mergedSegmentCount").textContent = "0";
            document.getElementById("savedLength").textContent = "0 m";
            document.getElementById("clearMergingBtn").style.display = "none";

            showNotification(`å·²æ¸…é™¤ ${cleared} æ¢åˆä½µæ¨™è¨˜`, "info");

            // é‡æ–°æ¸²æŸ“
            render();
          } else {
            showNotification(
              "æ¸…é™¤å¤±æ•—: " + (result.error || "æœªçŸ¥éŒ¯èª¤"),
              "error"
            );
          }
        } catch (e) {
          console.error("[clearMergingAPI] éŒ¯èª¤:", e);
          showNotification("æ¸…é™¤å¤±æ•—: " + e.message, "error");
        }
      }

      /**
       * æ›´æ–°åˆä½µçµ±è¨ˆ
       */
      async function updateMergeStatistics() {
        if (!state.projectId) return;

        try {
          const response = await fetch(
            `/api/projects/${state.projectId}/summary`
          );
          const result = await response.json();

          if (result.success && result.data.merge_statistics) {
            const stats = result.data.merge_statistics;
            document.getElementById("mergedSegmentCount").textContent =
              stats.merged_segments || 0;

            const savedLength = (stats.merged_length || 0) / 1000;
            document.getElementById("savedLength").textContent =
              savedLength.toFixed(2) + " m";

            // å¦‚æœæœ‰å·²åˆä½µç·šæ®µï¼Œé¡¯ç¤ºæ¸…é™¤æŒ‰éˆ•
            if (stats.merged_segments > 0) {
              document.getElementById("clearMergingBtn").style.display =
                "block";
            }
          }
        } catch (e) {
          console.error("[updateMergeStatistics] éŒ¯èª¤:", e);
        }
      }

      // åˆå§‹åŒ–
      init();
    </script>
  </body>
</html>
